function nD(n, e) { for (var t = 0; t < e.length; t++) { const i = e[t]; if (typeof i != "string" && !Array.isArray(i)) { for (const r in i) if (r !== "default" && !(r in n)) { const s = Object.getOwnPropertyDescriptor(i, r); s && Object.defineProperty(n, r, s.get ? s : { enumerable: !0, get: () => i[r] }) } } } return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })) } (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = t(r); fetch(r.href, s) } })(); function rb(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } function iD(n) { if (n.__esModule) return n; var e = n.default; if (typeof e == "function") { var t = function i() { if (this instanceof i) { var r = [null]; r.push.apply(r, arguments); var s = Function.bind.apply(e, r); return new s } return e.apply(this, arguments) }; t.prototype = e.prototype } else t = {}; return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function (i) { var r = Object.getOwnPropertyDescriptor(n, i); Object.defineProperty(t, i, r.get ? r : { enumerable: !0, get: function () { return n[i] } }) }), t } var _f = {}, rD = { get exports() { return _f }, set exports(n) { _f = n } }, eg = {}, z = {}, sD = { get exports() { return z }, set exports(n) { z = n } }, Mt = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var od = Symbol.for("react.element"), oD = Symbol.for("react.portal"), aD = Symbol.for("react.fragment"), lD = Symbol.for("react.strict_mode"), uD = Symbol.for("react.profiler"), cD = Symbol.for("react.provider"), fD = Symbol.for("react.context"), dD = Symbol.for("react.forward_ref"), hD = Symbol.for("react.suspense"), pD = Symbol.for("react.memo"), mD = Symbol.for("react.lazy"), kw = Symbol.iterator; function gD(n) { return n === null || typeof n != "object" ? null : (n = kw && n[kw] || n["@@iterator"], typeof n == "function" ? n : null) } var sb = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, ob = Object.assign, ab = {}; function zu(n, e, t) { this.props = n, this.context = e, this.refs = ab, this.updater = t || sb } zu.prototype.isReactComponent = {}; zu.prototype.setState = function (n, e) { if (typeof n != "object" && typeof n != "function" && n != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, n, e, "setState") }; zu.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, "forceUpdate") }; function lb() { } lb.prototype = zu.prototype; function O1(n, e, t) { this.props = n, this.context = e, this.refs = ab, this.updater = t || sb } var k1 = O1.prototype = new lb; k1.constructor = O1; ob(k1, zu.prototype); k1.isPureReactComponent = !0; var Uw = Array.isArray, ub = Object.prototype.hasOwnProperty, U1 = { current: null }, cb = { key: !0, ref: !0, __self: !0, __source: !0 }; function fb(n, e, t) { var i, r = {}, s = null, o = null; if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) ub.call(e, i) && !cb.hasOwnProperty(i) && (r[i] = e[i]); var a = arguments.length - 2; if (a === 1) r.children = t; else if (1 < a) { for (var l = Array(a), f = 0; f < a; f++)l[f] = arguments[f + 2]; r.children = l } if (n && n.defaultProps) for (i in a = n.defaultProps, a) r[i] === void 0 && (r[i] = a[i]); return { $$typeof: od, type: n, key: s, ref: o, props: r, _owner: U1.current } } function yD(n, e) { return { $$typeof: od, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner } } function z1(n) { return typeof n == "object" && n !== null && n.$$typeof === od } function vD(n) { var e = { "=": "=0", ":": "=2" }; return "$" + n.replace(/[=:]/g, function (t) { return e[t] }) } var zw = /\/+/g; function K0(n, e) { return typeof n == "object" && n !== null && n.key != null ? vD("" + n.key) : e.toString(36) } function Wp(n, e, t, i, r) { var s = typeof n; (s === "undefined" || s === "boolean") && (n = null); var o = !1; if (n === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (n.$$typeof) { case od: case oD: o = !0 } }if (o) return o = n, r = r(o), n = i === "" ? "." + K0(o, 0) : i, Uw(r) ? (t = "", n != null && (t = n.replace(zw, "$&/") + "/"), Wp(r, e, t, "", function (f) { return f })) : r != null && (z1(r) && (r = yD(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(zw, "$&/") + "/") + n)), e.push(r)), 1; if (o = 0, i = i === "" ? "." : i + ":", Uw(n)) for (var a = 0; a < n.length; a++) { s = n[a]; var l = i + K0(s, a); o += Wp(s, e, t, l, r) } else if (l = gD(n), typeof l == "function") for (n = l.call(n), a = 0; !(s = n.next()).done;)s = s.value, l = i + K0(s, a++), o += Wp(s, e, t, l, r); else if (s === "object") throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return o } function Dh(n, e, t) { if (n == null) return n; var i = [], r = 0; return Wp(n, i, "", "", function (s) { return e.call(t, s, r++) }), i } function xD(n) { if (n._status === -1) { var e = n._result; e = e(), e.then(function (t) { (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t) }, function (t) { (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t) }), n._status === -1 && (n._status = 0, n._result = e) } if (n._status === 1) return n._result.default; throw n._result } var fi = { current: null }, jp = { transition: null }, AD = { ReactCurrentDispatcher: fi, ReactCurrentBatchConfig: jp, ReactCurrentOwner: U1 }; Mt.Children = { map: Dh, forEach: function (n, e, t) { Dh(n, function () { e.apply(this, arguments) }, t) }, count: function (n) { var e = 0; return Dh(n, function () { e++ }), e }, toArray: function (n) { return Dh(n, function (e) { return e }) || [] }, only: function (n) { if (!z1(n)) throw Error("React.Children.only expected to receive a single React element child."); return n } }; Mt.Component = zu; Mt.Fragment = aD; Mt.Profiler = uD; Mt.PureComponent = O1; Mt.StrictMode = lD; Mt.Suspense = hD; Mt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = AD; Mt.cloneElement = function (n, e, t) { if (n == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + "."); var i = ob({}, n.props), r = n.key, s = n.ref, o = n._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, o = U1.current), e.key !== void 0 && (r = "" + e.key), n.type && n.type.defaultProps) var a = n.type.defaultProps; for (l in e) ub.call(e, l) && !cb.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]) } var l = arguments.length - 2; if (l === 1) i.children = t; else if (1 < l) { a = Array(l); for (var f = 0; f < l; f++)a[f] = arguments[f + 2]; i.children = a } return { $$typeof: od, type: n.type, key: r, ref: s, props: i, _owner: o } }; Mt.createContext = function (n) { return n = { $$typeof: fD, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: cD, _context: n }, n.Consumer = n }; Mt.createElement = fb; Mt.createFactory = function (n) { var e = fb.bind(null, n); return e.type = n, e }; Mt.createRef = function () { return { current: null } }; Mt.forwardRef = function (n) { return { $$typeof: dD, render: n } }; Mt.isValidElement = z1; Mt.lazy = function (n) { return { $$typeof: mD, _payload: { _status: -1, _result: n }, _init: xD } }; Mt.memo = function (n, e) { return { $$typeof: pD, type: n, compare: e === void 0 ? null : e } }; Mt.startTransition = function (n) { var e = jp.transition; jp.transition = {}; try { n() } finally { jp.transition = e } }; Mt.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; Mt.useCallback = function (n, e) { return fi.current.useCallback(n, e) }; Mt.useContext = function (n) { return fi.current.useContext(n) }; Mt.useDebugValue = function () { }; Mt.useDeferredValue = function (n) { return fi.current.useDeferredValue(n) }; Mt.useEffect = function (n, e) { return fi.current.useEffect(n, e) }; Mt.useId = function () { return fi.current.useId() }; Mt.useImperativeHandle = function (n, e, t) { return fi.current.useImperativeHandle(n, e, t) }; Mt.useInsertionEffect = function (n, e) { return fi.current.useInsertionEffect(n, e) }; Mt.useLayoutEffect = function (n, e) { return fi.current.useLayoutEffect(n, e) }; Mt.useMemo = function (n, e) { return fi.current.useMemo(n, e) }; Mt.useReducer = function (n, e, t) { return fi.current.useReducer(n, e, t) }; Mt.useRef = function (n) { return fi.current.useRef(n) }; Mt.useState = function (n) { return fi.current.useState(n) }; Mt.useSyncExternalStore = function (n, e, t) { return fi.current.useSyncExternalStore(n, e, t) }; Mt.useTransition = function () { return fi.current.useTransition() }; Mt.version = "18.2.0"; (function (n) { n.exports = Mt })(sD); const tg = rb(z), Cv = nD({ __proto__: null, default: tg }, [z]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _D = z, MD = Symbol.for("react.element"), wD = Symbol.for("react.fragment"), SD = Object.prototype.hasOwnProperty, CD = _D.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ED = { key: !0, ref: !0, __self: !0, __source: !0 }; function db(n, e, t) { var i, r = {}, s = null, o = null; t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref); for (i in e) SD.call(e, i) && !ED.hasOwnProperty(i) && (r[i] = e[i]); if (n && n.defaultProps) for (i in e = n.defaultProps, e) r[i] === void 0 && (r[i] = e[i]); return { $$typeof: MD, type: n, key: s, ref: o, props: r, _owner: CD.current } } eg.Fragment = wD; eg.jsx = db; eg.jsxs = db; (function (n) { n.exports = eg })(rD); const G1 = _f.Fragment, ye = _f.jsx, st = _f.jsxs; var Ev = {}, hm = {}, TD = { get exports() { return hm }, set exports(n) { hm = n } }, Vi = {}, Tv = {}, bD = { get exports() { return Tv }, set exports(n) { Tv = n } }, hb = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(N, V) { var Y = N.length; N.push(V); e: for (; 0 < Y;) { var re = Y - 1 >>> 1, j = N[re]; if (0 < r(j, V)) N[re] = V, N[Y] = j, Y = re; else break e } } function t(N) { return N.length === 0 ? null : N[0] } function i(N) { if (N.length === 0) return null; var V = N[0], Y = N.pop(); if (Y !== V) { N[0] = Y; e: for (var re = 0, j = N.length, ie = j >>> 1; re < ie;) { var ve = 2 * (re + 1) - 1, Ae = N[ve], $ = ve + 1, Oe = N[$]; if (0 > r(Ae, Y)) $ < j && 0 > r(Oe, Ae) ? (N[re] = Oe, N[$] = Y, re = $) : (N[re] = Ae, N[ve] = Y, re = ve); else if ($ < j && 0 > r(Oe, Y)) N[re] = Oe, N[$] = Y, re = $; else break e } } return V } function r(N, V) { var Y = N.sortIndex - V.sortIndex; return Y !== 0 ? Y : N.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); n.unstable_now = function () { return o.now() - a } } var l = [], f = [], d = 1, h = null, p = 3, m = !1, v = !1, y = !1, x = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function w(N) { for (var V = t(f); V !== null;) { if (V.callback === null) i(f); else if (V.startTime <= N) i(f), V.sortIndex = V.expirationTime, e(l, V); else break; V = t(f) } } function S(N) { if (y = !1, w(N), !v) if (t(l) !== null) v = !0, ne(T); else { var V = t(f); V !== null && oe(S, V.startTime - N) } } function T(N, V) { v = !1, y && (y = !1, A(E), E = -1), m = !0; var Y = p; try { for (w(V), h = t(l); h !== null && (!(h.expirationTime > V) || N && !U());) { var re = h.callback; if (typeof re == "function") { h.callback = null, p = h.priorityLevel; var j = re(h.expirationTime <= V); V = n.unstable_now(), typeof j == "function" ? h.callback = j : h === t(l) && i(l), w(V) } else i(l); h = t(l) } if (h !== null) var ie = !0; else { var ve = t(f); ve !== null && oe(S, ve.startTime - V), ie = !1 } return ie } finally { h = null, p = Y, m = !1 } } var P = !1, R = null, E = -1, B = 5, L = -1; function U() { return !(n.unstable_now() - L < B) } function q() { if (R !== null) { var N = n.unstable_now(); L = N; var V = !0; try { V = R(!0, N) } finally { V ? W() : (P = !1, R = null) } } else P = !1 } var W; if (typeof _ == "function") W = function () { _(q) }; else if (typeof MessageChannel < "u") { var G = new MessageChannel, K = G.port2; G.port1.onmessage = q, W = function () { K.postMessage(null) } } else W = function () { x(q, 0) }; function ne(N) { R = N, P || (P = !0, W()) } function oe(N, V) { E = x(function () { N(n.unstable_now()) }, V) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (N) { N.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, ne(T)) }, n.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < N ? Math.floor(1e3 / N) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (N) { switch (p) { case 1: case 2: case 3: var V = 3; break; default: V = p }var Y = p; p = V; try { return N() } finally { p = Y } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (N, V) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var Y = p; p = N; try { return V() } finally { p = Y } }, n.unstable_scheduleCallback = function (N, V, Y) { var re = n.unstable_now(); switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? re + Y : re) : Y = re, N) { case 1: var j = -1; break; case 2: j = 250; break; case 5: j = 1073741823; break; case 4: j = 1e4; break; default: j = 5e3 }return j = Y + j, N = { id: d++, callback: V, priorityLevel: N, startTime: Y, expirationTime: j, sortIndex: -1 }, Y > re ? (N.sortIndex = Y, e(f, N), t(l) === null && N === t(f) && (y ? (A(E), E = -1) : y = !0, oe(S, Y - re))) : (N.sortIndex = j, e(l, N), v || m || (v = !0, ne(T))), N }, n.unstable_shouldYield = U, n.unstable_wrapCallback = function (N) { var V = p; return function () { var Y = p; p = V; try { return N.apply(this, arguments) } finally { p = Y } } } })(hb); (function (n) { n.exports = hb })(bD);/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pb = z, zi = Tv; function Se(n) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var mb = new Set, Mf = {}; function il(n, e) { _u(n, e), _u(n + "Capture", e) } function _u(n, e) { for (Mf[n] = e, n = 0; n < e.length; n++)mb.add(e[n]) } var ks = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), bv = Object.prototype.hasOwnProperty, PD = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Gw = {}, Hw = {}; function BD(n) { return bv.call(Hw, n) ? !0 : bv.call(Gw, n) ? !1 : PD.test(n) ? Hw[n] = !0 : (Gw[n] = !0, !1) } function RD(n, e, t, i) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-"); default: return !1 } } function LD(n, e, t, i) { if (e === null || typeof e > "u" || RD(n, e, t, i)) return !0; if (i) return !1; if (t !== null) switch (t.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function di(n, e, t, i, r, s, o) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o } var Vn = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { Vn[n] = new di(n, 0, !1, n, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var e = n[0]; Vn[e] = new di(e, 1, !1, n[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { Vn[n] = new di(n, 2, !1, n.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { Vn[n] = new di(n, 2, !1, n, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { Vn[n] = new di(n, 3, !1, n.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (n) { Vn[n] = new di(n, 3, !0, n, null, !1, !1) });["capture", "download"].forEach(function (n) { Vn[n] = new di(n, 4, !1, n, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (n) { Vn[n] = new di(n, 6, !1, n, null, !1, !1) });["rowSpan", "start"].forEach(function (n) { Vn[n] = new di(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var H1 = /[\-:]([a-z])/g; function V1(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var e = n.replace(H1, V1); Vn[e] = new di(e, 1, !1, n, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var e = n.replace(H1, V1); Vn[e] = new di(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var e = n.replace(H1, V1); Vn[e] = new di(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (n) { Vn[n] = new di(n, 1, !1, n.toLowerCase(), null, !1, !1) }); Vn.xlinkHref = new di("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (n) { Vn[n] = new di(n, 1, !1, n.toLowerCase(), null, !0, !0) }); function W1(n, e, t, i) { var r = Vn.hasOwnProperty(e) ? Vn[e] : null; (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (LD(e, t, r, i) && (t = null), i || r === null ? BD(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : r.mustUseProperty ? n[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === !0 ? "" : "" + t, i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t)))) } var js = pb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Ih = Symbol.for("react.element"), Xl = Symbol.for("react.portal"), Yl = Symbol.for("react.fragment"), j1 = Symbol.for("react.strict_mode"), Pv = Symbol.for("react.profiler"), gb = Symbol.for("react.provider"), yb = Symbol.for("react.context"), J1 = Symbol.for("react.forward_ref"), Bv = Symbol.for("react.suspense"), Rv = Symbol.for("react.suspense_list"), X1 = Symbol.for("react.memo"), po = Symbol.for("react.lazy"), vb = Symbol.for("react.offscreen"), Vw = Symbol.iterator; function xc(n) { return n === null || typeof n != "object" ? null : (n = Vw && n[Vw] || n["@@iterator"], typeof n == "function" ? n : null) } var sn = Object.assign, Q0; function Kc(n) {
	if (Q0 === void 0) try { throw Error() } catch (t) { var e = t.stack.trim().match(/\n( *(at )?)/); Q0 = e && e[1] || "" } return `
`+ Q0 + n
} var Z0 = !1; function q0(n, e) {
	if (!n || Z0) return ""; Z0 = !0; var t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (f) { var i = f } Reflect.construct(n, [], e) } else { try { e.call() } catch (f) { i = f } n.call(e.prototype) } else { try { throw Error() } catch (f) { i = f } n() } } catch (f) {
		if (f && i && typeof f.stack == "string") {
			for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
				if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
					var l = `
`+ r[o].replace(" at new ", " at "); return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)), l
				} while (1 <= o && 0 <= a); break
			}
		}
	} finally { Z0 = !1, Error.prepareStackTrace = t } return (n = n ? n.displayName || n.name : "") ? Kc(n) : ""
} function DD(n) { switch (n.tag) { case 5: return Kc(n.type); case 16: return Kc("Lazy"); case 13: return Kc("Suspense"); case 19: return Kc("SuspenseList"); case 0: case 2: case 15: return n = q0(n.type, !1), n; case 11: return n = q0(n.type.render, !1), n; case 1: return n = q0(n.type, !0), n; default: return "" } } function Lv(n) { if (n == null) return null; if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n; switch (n) { case Yl: return "Fragment"; case Xl: return "Portal"; case Pv: return "Profiler"; case j1: return "StrictMode"; case Bv: return "Suspense"; case Rv: return "SuspenseList" }if (typeof n == "object") switch (n.$$typeof) { case yb: return (n.displayName || "Context") + ".Consumer"; case gb: return (n._context.displayName || "Context") + ".Provider"; case J1: var e = n.render; return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case X1: return e = n.displayName || null, e !== null ? e : Lv(n.type) || "Memo"; case po: e = n._payload, n = n._init; try { return Lv(n(e)) } catch { } }return null } function ID(n) { var e = n.type; switch (n.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Lv(e); case 8: return e === j1 ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function Fo(n) { switch (typeof n) { case "boolean": case "number": case "string": case "undefined": return n; case "object": return n; default: return "" } } function xb(n) { var e = n.type; return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function FD(n) { var e = xb(n) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e), i = "" + n[e]; if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") { var r = t.get, s = t.set; return Object.defineProperty(n, e, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { i = "" + o, s.call(this, o) } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = "" + o }, stopTracking: function () { n._valueTracker = null, delete n[e] } } } } function Fh(n) { n._valueTracker || (n._valueTracker = FD(n)) } function Ab(n) { if (!n) return !1; var e = n._valueTracker; if (!e) return !0; var t = e.getValue(), i = ""; return n && (i = xb(n) ? n.checked ? "true" : "false" : n.value), n = i, n !== t ? (e.setValue(n), !0) : !1 } function pm(n) { if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null; try { return n.activeElement || n.body } catch { return n.body } } function Dv(n, e) { var t = e.checked; return sn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked }) } function Ww(n, e) { var t = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked; t = Fo(e.value != null ? e.value : t), n._wrapperState = { initialChecked: i, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function _b(n, e) { e = e.checked, e != null && W1(n, "checked", e, !1) } function Iv(n, e) { _b(n, e); var t = Fo(e.value), i = e.type; if (t != null) i === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t); else if (i === "submit" || i === "reset") { n.removeAttribute("value"); return } e.hasOwnProperty("value") ? Fv(n, e.type, t) : e.hasOwnProperty("defaultValue") && Fv(n, e.type, Fo(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked) } function jw(n, e, t) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var i = e.type; if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e } t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t) } function Fv(n, e, t) { (e !== "number" || pm(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t)) } var Qc = Array.isArray; function du(n, e, t, i) { if (n = n.options, e) { e = {}; for (var r = 0; r < t.length; r++)e["$" + t[r]] = !0; for (t = 0; t < n.length; t++)r = e.hasOwnProperty("$" + n[t].value), n[t].selected !== r && (n[t].selected = r), r && i && (n[t].defaultSelected = !0) } else { for (t = "" + Fo(t), e = null, r = 0; r < n.length; r++) { if (n[r].value === t) { n[r].selected = !0, i && (n[r].defaultSelected = !0); return } e !== null || n[r].disabled || (e = n[r]) } e !== null && (e.selected = !0) } } function Nv(n, e) { if (e.dangerouslySetInnerHTML != null) throw Error(Se(91)); return sn({}, e, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue }) } function Jw(n, e) { var t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(Se(92)); if (Qc(t)) { if (1 < t.length) throw Error(Se(93)); t = t[0] } e = t } e == null && (e = ""), t = e } n._wrapperState = { initialValue: Fo(t) } } function Mb(n, e) { var t = Fo(e.value), i = Fo(e.defaultValue); t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), i != null && (n.defaultValue = "" + i) } function Xw(n) { var e = n.textContent; e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e) } function wb(n) { switch (n) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Ov(n, e) { return n == null || n === "http://www.w3.org/1999/xhtml" ? wb(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n } var Nh, Sb = function (n) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, t, i, r) { MSApp.execUnsafeLocalFunction(function () { return n(e, t, i, r) }) } : n }(function (n, e) { if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) n.innerHTML = e; else { for (Nh = Nh || document.createElement("div"), Nh.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Nh.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (; e.firstChild;)n.appendChild(e.firstChild) } }); function wf(n, e) { if (e) { var t = n.firstChild; if (t && t === n.lastChild && t.nodeType === 3) { t.nodeValue = e; return } } n.textContent = e } var tf = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, ND = ["Webkit", "ms", "Moz", "O"]; Object.keys(tf).forEach(function (n) { ND.forEach(function (e) { e = e + n.charAt(0).toUpperCase() + n.substring(1), tf[e] = tf[n] }) }); function Cb(n, e, t) { return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || tf.hasOwnProperty(n) && tf[n] ? ("" + e).trim() : e + "px" } function Eb(n, e) { n = n.style; for (var t in e) if (e.hasOwnProperty(t)) { var i = t.indexOf("--") === 0, r = Cb(t, e[t], i); t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : n[t] = r } } var OD = sn({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function kv(n, e) { if (e) { if (OD[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Se(137, n)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(Se(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Se(61)) } if (e.style != null && typeof e.style != "object") throw Error(Se(62)) } } function Uv(n, e) { if (n.indexOf("-") === -1) return typeof e.is == "string"; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var zv = null; function Y1(n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } var Gv = null, hu = null, pu = null; function Yw(n) { if (n = ud(n)) { if (typeof Gv != "function") throw Error(Se(280)); var e = n.stateNode; e && (e = og(e), Gv(n.stateNode, n.type, e)) } } function Tb(n) { hu ? pu ? pu.push(n) : pu = [n] : hu = n } function bb() { if (hu) { var n = hu, e = pu; if (pu = hu = null, Yw(n), e) for (n = 0; n < e.length; n++)Yw(e[n]) } } function Pb(n, e) { return n(e) } function Bb() { } var $0 = !1; function Rb(n, e, t) { if ($0) return n(e, t); $0 = !0; try { return Pb(n, e, t) } finally { $0 = !1, (hu !== null || pu !== null) && (Bb(), bb()) } } function Sf(n, e) { var t = n.stateNode; if (t === null) return null; var i = og(t); if (i === null) return null; t = i[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (n = n.type, i = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !i; break e; default: n = !1 }if (n) return null; if (t && typeof t != "function") throw Error(Se(231, e, typeof t)); return t } var Hv = !1; if (ks) try { var Ac = {}; Object.defineProperty(Ac, "passive", { get: function () { Hv = !0 } }), window.addEventListener("test", Ac, Ac), window.removeEventListener("test", Ac, Ac) } catch { Hv = !1 } function kD(n, e, t, i, r, s, o, a, l) { var f = Array.prototype.slice.call(arguments, 3); try { e.apply(t, f) } catch (d) { this.onError(d) } } var nf = !1, mm = null, gm = !1, Vv = null, UD = { onError: function (n) { nf = !0, mm = n } }; function zD(n, e, t, i, r, s, o, a, l) { nf = !1, mm = null, kD.apply(UD, arguments) } function GD(n, e, t, i, r, s, o, a, l) { if (zD.apply(this, arguments), nf) { if (nf) { var f = mm; nf = !1, mm = null } else throw Error(Se(198)); gm || (gm = !0, Vv = f) } } function rl(n) { var e = n, t = n; if (n.alternate) for (; e.return;)e = e.return; else { n = e; do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n) } return e.tag === 3 ? t : null } function Lb(n) { if (n.tag === 13) { var e = n.memoizedState; if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated } return null } function Kw(n) { if (rl(n) !== n) throw Error(Se(188)) } function HD(n) { var e = n.alternate; if (!e) { if (e = rl(n), e === null) throw Error(Se(188)); return e !== n ? null : n } for (var t = n, i = e; ;) { var r = t.return; if (r === null) break; var s = r.alternate; if (s === null) { if (i = r.return, i !== null) { t = i; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === t) return Kw(r), n; if (s === i) return Kw(r), e; s = s.sibling } throw Error(Se(188)) } if (t.return !== i.return) t = r, i = s; else { for (var o = !1, a = r.child; a;) { if (a === t) { o = !0, t = r, i = s; break } if (a === i) { o = !0, i = r, t = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === t) { o = !0, t = s, i = r; break } if (a === i) { o = !0, i = s, t = r; break } a = a.sibling } if (!o) throw Error(Se(189)) } } if (t.alternate !== i) throw Error(Se(190)) } if (t.tag !== 3) throw Error(Se(188)); return t.stateNode.current === t ? n : e } function Db(n) { return n = HD(n), n !== null ? Ib(n) : null } function Ib(n) { if (n.tag === 5 || n.tag === 6) return n; for (n = n.child; n !== null;) { var e = Ib(n); if (e !== null) return e; n = n.sibling } return null } var Fb = zi.unstable_scheduleCallback, Qw = zi.unstable_cancelCallback, VD = zi.unstable_shouldYield, WD = zi.unstable_requestPaint, mn = zi.unstable_now, jD = zi.unstable_getCurrentPriorityLevel, K1 = zi.unstable_ImmediatePriority, Nb = zi.unstable_UserBlockingPriority, ym = zi.unstable_NormalPriority, JD = zi.unstable_LowPriority, Ob = zi.unstable_IdlePriority, ng = null, qr = null; function XD(n) { if (qr && typeof qr.onCommitFiberRoot == "function") try { qr.onCommitFiberRoot(ng, n, void 0, (n.current.flags & 128) === 128) } catch { } } var Rr = Math.clz32 ? Math.clz32 : QD, YD = Math.log, KD = Math.LN2; function QD(n) { return n >>>= 0, n === 0 ? 32 : 31 - (YD(n) / KD | 0) | 0 } var Oh = 64, kh = 4194304; function Zc(n) { switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return n & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return n } } function vm(n, e) { var t = n.pendingLanes; if (t === 0) return 0; var i = 0, r = n.suspendedLanes, s = n.pingedLanes, o = t & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? i = Zc(a) : (s &= o, s !== 0 && (i = Zc(s))) } else o = t & ~r, o !== 0 ? i = Zc(o) : s !== 0 && (i = Zc(s)); if (i === 0) return 0; if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e; if (i & 4 && (i |= t & 16), e = n.entangledLanes, e !== 0) for (n = n.entanglements, e &= i; 0 < e;)t = 31 - Rr(e), r = 1 << t, i |= n[t], e &= ~r; return i } function ZD(n, e) { switch (n) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function qD(n, e) { for (var t = n.suspendedLanes, i = n.pingedLanes, r = n.expirationTimes, s = n.pendingLanes; 0 < s;) { var o = 31 - Rr(s), a = 1 << o, l = r[o]; l === -1 ? (!(a & t) || a & i) && (r[o] = ZD(a, e)) : l <= e && (n.expiredLanes |= a), s &= ~a } } function Wv(n) { return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0 } function kb() { var n = Oh; return Oh <<= 1, !(Oh & 4194240) && (Oh = 64), n } function ey(n) { for (var e = [], t = 0; 31 > t; t++)e.push(n); return e } function ad(n, e, t) { n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - Rr(e), n[e] = t } function $D(n, e) { var t = n.pendingLanes & ~e; n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements; var i = n.eventTimes; for (n = n.expirationTimes; 0 < t;) { var r = 31 - Rr(t), s = 1 << r; e[r] = 0, i[r] = -1, n[r] = -1, t &= ~s } } function Q1(n, e) { var t = n.entangledLanes |= e; for (n = n.entanglements; t;) { var i = 31 - Rr(t), r = 1 << i; r & e | n[i] & e && (n[i] |= e), t &= ~r } } var Ot = 0; function Ub(n) { return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1 } var zb, Z1, Gb, Hb, Vb, jv = !1, Uh = [], Co = null, Eo = null, To = null, Cf = new Map, Ef = new Map, vo = [], eI = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Zw(n, e) { switch (n) { case "focusin": case "focusout": Co = null; break; case "dragenter": case "dragleave": Eo = null; break; case "mouseover": case "mouseout": To = null; break; case "pointerover": case "pointerout": Cf.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Ef.delete(e.pointerId) } } function _c(n, e, t, i, r, s) { return n === null || n.nativeEvent !== s ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = ud(e), e !== null && Z1(e)), n) : (n.eventSystemFlags |= i, e = n.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n) } function tI(n, e, t, i, r) { switch (e) { case "focusin": return Co = _c(Co, n, e, t, i, r), !0; case "dragenter": return Eo = _c(Eo, n, e, t, i, r), !0; case "mouseover": return To = _c(To, n, e, t, i, r), !0; case "pointerover": var s = r.pointerId; return Cf.set(s, _c(Cf.get(s) || null, n, e, t, i, r)), !0; case "gotpointercapture": return s = r.pointerId, Ef.set(s, _c(Ef.get(s) || null, n, e, t, i, r)), !0 }return !1 } function Wb(n) { var e = Pa(n.target); if (e !== null) { var t = rl(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = Lb(t), e !== null) { n.blockedOn = e, Vb(n.priority, function () { Gb(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } } n.blockedOn = null } function Jp(n) { if (n.blockedOn !== null) return !1; for (var e = n.targetContainers; 0 < e.length;) { var t = Jv(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent); if (t === null) { t = n.nativeEvent; var i = new t.constructor(t.type, t); zv = i, t.target.dispatchEvent(i), zv = null } else return e = ud(t), e !== null && Z1(e), n.blockedOn = t, !1; e.shift() } return !0 } function qw(n, e, t) { Jp(n) && t.delete(e) } function nI() { jv = !1, Co !== null && Jp(Co) && (Co = null), Eo !== null && Jp(Eo) && (Eo = null), To !== null && Jp(To) && (To = null), Cf.forEach(qw), Ef.forEach(qw) } function Mc(n, e) { n.blockedOn === e && (n.blockedOn = null, jv || (jv = !0, zi.unstable_scheduleCallback(zi.unstable_NormalPriority, nI))) } function Tf(n) { function e(r) { return Mc(r, n) } if (0 < Uh.length) { Mc(Uh[0], n); for (var t = 1; t < Uh.length; t++) { var i = Uh[t]; i.blockedOn === n && (i.blockedOn = null) } } for (Co !== null && Mc(Co, n), Eo !== null && Mc(Eo, n), To !== null && Mc(To, n), Cf.forEach(e), Ef.forEach(e), t = 0; t < vo.length; t++)i = vo[t], i.blockedOn === n && (i.blockedOn = null); for (; 0 < vo.length && (t = vo[0], t.blockedOn === null);)Wb(t), t.blockedOn === null && vo.shift() } var mu = js.ReactCurrentBatchConfig, xm = !0; function iI(n, e, t, i) { var r = Ot, s = mu.transition; mu.transition = null; try { Ot = 1, q1(n, e, t, i) } finally { Ot = r, mu.transition = s } } function rI(n, e, t, i) { var r = Ot, s = mu.transition; mu.transition = null; try { Ot = 4, q1(n, e, t, i) } finally { Ot = r, mu.transition = s } } function q1(n, e, t, i) { if (xm) { var r = Jv(n, e, t, i); if (r === null) cy(n, e, i, Am, t), Zw(n, i); else if (tI(r, n, e, t, i)) i.stopPropagation(); else if (Zw(n, i), e & 4 && -1 < eI.indexOf(n)) { for (; r !== null;) { var s = ud(r); if (s !== null && zb(s), s = Jv(n, e, t, i), s === null && cy(n, e, i, Am, t), s === r) break; r = s } r !== null && i.stopPropagation() } else cy(n, e, i, null, t) } } var Am = null; function Jv(n, e, t, i) { if (Am = null, n = Y1(i), n = Pa(n), n !== null) if (e = rl(n), e === null) n = null; else if (t = e.tag, t === 13) { if (n = Lb(e), n !== null) return n; n = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; n = null } else e !== n && (n = null); return Am = n, null } function jb(n) { switch (n) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (jD()) { case K1: return 1; case Nb: return 4; case ym: case JD: return 16; case Ob: return 536870912; default: return 16 }default: return 16 } } var Ao = null, $1 = null, Xp = null; function Jb() { if (Xp) return Xp; var n, e = $1, t = e.length, i, r = "value" in Ao ? Ao.value : Ao.textContent, s = r.length; for (n = 0; n < t && e[n] === r[n]; n++); var o = t - n; for (i = 1; i <= o && e[t - i] === r[s - i]; i++); return Xp = r.slice(n, 1 < i ? 1 - i : void 0) } function Yp(n) { var e = n.keyCode; return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0 } function zh() { return !0 } function $w() { return !1 } function Wi(n) { function e(t, i, r, s, o) { this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in n) n.hasOwnProperty(a) && (t = n[a], this[a] = t ? t(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? zh : $w, this.isPropagationStopped = $w, this } return sn(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = zh) }, stopPropagation: function () { var t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = zh) }, persist: function () { }, isPersistent: zh }), e } var Gu = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, eA = Wi(Gu), ld = sn({}, Gu, { view: 0, detail: 0 }), sI = Wi(ld), ty, ny, wc, ig = sn({}, ld, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: tA, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== wc && (wc && n.type === "mousemove" ? (ty = n.screenX - wc.screenX, ny = n.screenY - wc.screenY) : ny = ty = 0, wc = n), ty) }, movementY: function (n) { return "movementY" in n ? n.movementY : ny } }), eS = Wi(ig), oI = sn({}, ig, { dataTransfer: 0 }), aI = Wi(oI), lI = sn({}, ld, { relatedTarget: 0 }), iy = Wi(lI), uI = sn({}, Gu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), cI = Wi(uI), fI = sn({}, Gu, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } }), dI = Wi(fI), hI = sn({}, Gu, { data: 0 }), tS = Wi(hI), pI = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, mI = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, gI = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function yI(n) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(n) : (n = gI[n]) ? !!e[n] : !1 } function tA() { return yI } var vI = sn({}, ld, { key: function (n) { if (n.key) { var e = pI[n.key] || n.key; if (e !== "Unidentified") return e } return n.type === "keypress" ? (n = Yp(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? mI[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: tA, charCode: function (n) { return n.type === "keypress" ? Yp(n) : 0 }, keyCode: function (n) { return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 }, which: function (n) { return n.type === "keypress" ? Yp(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 } }), xI = Wi(vI), AI = sn({}, ig, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), nS = Wi(AI), _I = sn({}, ld, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: tA }), MI = Wi(_I), wI = sn({}, Gu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), SI = Wi(wI), CI = sn({}, ig, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), EI = Wi(CI), TI = [9, 13, 27, 32], nA = ks && "CompositionEvent" in window, rf = null; ks && "documentMode" in document && (rf = document.documentMode); var bI = ks && "TextEvent" in window && !rf, Xb = ks && (!nA || rf && 8 < rf && 11 >= rf), iS = String.fromCharCode(32), rS = !1; function Yb(n, e) { switch (n) { case "keyup": return TI.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Kb(n) { return n = n.detail, typeof n == "object" && "data" in n ? n.data : null } var Kl = !1; function PI(n, e) { switch (n) { case "compositionend": return Kb(e); case "keypress": return e.which !== 32 ? null : (rS = !0, iS); case "textInput": return n = e.data, n === iS && rS ? null : n; default: return null } } function BI(n, e) { if (Kl) return n === "compositionend" || !nA && Yb(n, e) ? (n = Jb(), Xp = $1 = Ao = null, Kl = !1, n) : null; switch (n) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return Xb && e.locale !== "ko" ? null : e.data; default: return null } } var RI = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function sS(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e === "input" ? !!RI[n.type] : e === "textarea" } function Qb(n, e, t, i) { Tb(i), e = _m(e, "onChange"), 0 < e.length && (t = new eA("onChange", "change", null, t, i), n.push({ event: t, listeners: e })) } var sf = null, bf = null; function LI(n) { a2(n, 0) } function rg(n) { var e = ql(n); if (Ab(e)) return n } function DI(n, e) { if (n === "change") return e } var Zb = !1; if (ks) { var ry; if (ks) { var sy = "oninput" in document; if (!sy) { var oS = document.createElement("div"); oS.setAttribute("oninput", "return;"), sy = typeof oS.oninput == "function" } ry = sy } else ry = !1; Zb = ry && (!document.documentMode || 9 < document.documentMode) } function aS() { sf && (sf.detachEvent("onpropertychange", qb), bf = sf = null) } function qb(n) { if (n.propertyName === "value" && rg(bf)) { var e = []; Qb(e, bf, n, Y1(n)), Rb(LI, e) } } function II(n, e, t) { n === "focusin" ? (aS(), sf = e, bf = t, sf.attachEvent("onpropertychange", qb)) : n === "focusout" && aS() } function FI(n) { if (n === "selectionchange" || n === "keyup" || n === "keydown") return rg(bf) } function NI(n, e) { if (n === "click") return rg(e) } function OI(n, e) { if (n === "input" || n === "change") return rg(e) } function kI(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var Fr = typeof Object.is == "function" ? Object.is : kI; function Pf(n, e) { if (Fr(n, e)) return !0; if (typeof n != "object" || n === null || typeof e != "object" || e === null) return !1; var t = Object.keys(n), i = Object.keys(e); if (t.length !== i.length) return !1; for (i = 0; i < t.length; i++) { var r = t[i]; if (!bv.call(e, r) || !Fr(n[r], e[r])) return !1 } return !0 } function lS(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function uS(n, e) { var t = lS(n); n = 0; for (var i; t;) { if (t.nodeType === 3) { if (i = n + t.textContent.length, n <= e && i >= e) return { node: t, offset: e - n }; n = i } e: { for (; t;) { if (t.nextSibling) { t = t.nextSibling; break e } t = t.parentNode } t = void 0 } t = lS(t) } } function $b(n, e) { return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? $b(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1 } function e2() { for (var n = window, e = pm(); e instanceof n.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href == "string" } catch { t = !1 } if (t) n = e.contentWindow; else break; e = pm(n.document) } return e } function iA(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true") } function UI(n) { var e = e2(), t = n.focusedElem, i = n.selectionRange; if (e !== t && t && t.ownerDocument && $b(t.ownerDocument.documentElement, t)) { if (i !== null && iA(t)) { if (e = i.start, n = i.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); var r = t.textContent.length, s = Math.min(i.start, r); i = i.end === void 0 ? s : Math.min(i.end, r), !n.extend && s > i && (r = i, i = s, s = r), r = uS(t, s); var o = uS(t, i); r && o && (n.rangeCount !== 1 || n.anchorNode !== r.node || n.anchorOffset !== r.offset || n.focusNode !== o.node || n.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n.removeAllRanges(), s > i ? (n.addRange(e), n.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } var zI = ks && "documentMode" in document && 11 >= document.documentMode, Ql = null, Xv = null, of = null, Yv = !1; function cS(n, e, t) { var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; Yv || Ql == null || Ql !== pm(i) || (i = Ql, "selectionStart" in i && iA(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), of && Pf(of, i) || (of = i, i = _m(Xv, "onSelect"), 0 < i.length && (e = new eA("onSelect", "select", null, e, t), n.push({ event: e, listeners: i }), e.target = Ql))) } function Gh(n, e) { var t = {}; return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t } var Zl = { animationend: Gh("Animation", "AnimationEnd"), animationiteration: Gh("Animation", "AnimationIteration"), animationstart: Gh("Animation", "AnimationStart"), transitionend: Gh("Transition", "TransitionEnd") }, oy = {}, t2 = {}; ks && (t2 = document.createElement("div").style, "AnimationEvent" in window || (delete Zl.animationend.animation, delete Zl.animationiteration.animation, delete Zl.animationstart.animation), "TransitionEvent" in window || delete Zl.transitionend.transition); function sg(n) { if (oy[n]) return oy[n]; if (!Zl[n]) return n; var e = Zl[n], t; for (t in e) if (e.hasOwnProperty(t) && t in t2) return oy[n] = e[t]; return n } var n2 = sg("animationend"), i2 = sg("animationiteration"), r2 = sg("animationstart"), s2 = sg("transitionend"), o2 = new Map, fS = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Wo(n, e) { o2.set(n, e), il(e, [n]) } for (var ay = 0; ay < fS.length; ay++) { var ly = fS[ay], GI = ly.toLowerCase(), HI = ly[0].toUpperCase() + ly.slice(1); Wo(GI, "on" + HI) } Wo(n2, "onAnimationEnd"); Wo(i2, "onAnimationIteration"); Wo(r2, "onAnimationStart"); Wo("dblclick", "onDoubleClick"); Wo("focusin", "onFocus"); Wo("focusout", "onBlur"); Wo(s2, "onTransitionEnd"); _u("onMouseEnter", ["mouseout", "mouseover"]); _u("onMouseLeave", ["mouseout", "mouseover"]); _u("onPointerEnter", ["pointerout", "pointerover"]); _u("onPointerLeave", ["pointerout", "pointerover"]); il("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); il("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); il("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); il("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); il("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); il("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var qc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), VI = new Set("cancel close invalid load scroll toggle".split(" ").concat(qc)); function dS(n, e, t) { var i = n.type || "unknown-event"; n.currentTarget = t, GD(i, e, void 0, n), n.currentTarget = null } function a2(n, e) { e = (e & 4) !== 0; for (var t = 0; t < n.length; t++) { var i = n[t], r = i.event; i = i.listeners; e: { var s = void 0; if (e) for (var o = i.length - 1; 0 <= o; o--) { var a = i[o], l = a.instance, f = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break e; dS(r, a, f), s = l } else for (o = 0; o < i.length; o++) { if (a = i[o], l = a.instance, f = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e; dS(r, a, f), s = l } } } if (gm) throw n = Vv, gm = !1, Vv = null, n } function Wt(n, e) { var t = e[$v]; t === void 0 && (t = e[$v] = new Set); var i = n + "__bubble"; t.has(i) || (l2(e, n, 2, !1), t.add(i)) } function uy(n, e, t) { var i = 0; e && (i |= 4), l2(t, n, i, e) } var Hh = "_reactListening" + Math.random().toString(36).slice(2); function Bf(n) { if (!n[Hh]) { n[Hh] = !0, mb.forEach(function (t) { t !== "selectionchange" && (VI.has(t) || uy(t, !1, n), uy(t, !0, n)) }); var e = n.nodeType === 9 ? n : n.ownerDocument; e === null || e[Hh] || (e[Hh] = !0, uy("selectionchange", !1, e)) } } function l2(n, e, t, i) { switch (jb(e)) { case 1: var r = iI; break; case 4: r = rI; break; default: r = q1 }t = r.bind(null, e, t, n), r = void 0, !Hv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), i ? r !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: r }) : n.addEventListener(e, t, !0) : r !== void 0 ? n.addEventListener(e, t, { passive: r }) : n.addEventListener(e, t, !1) } function cy(n, e, t, i, r) { var s = i; if (!(e & 1) && !(e & 2) && i !== null) e: for (; ;) { if (i === null) return; var o = i.tag; if (o === 3 || o === 4) { var a = i.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = i.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = Pa(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { i = s = o; continue e } a = a.parentNode } } i = i.return } Rb(function () { var f = s, d = Y1(t), h = []; e: { var p = o2.get(n); if (p !== void 0) { var m = eA, v = n; switch (n) { case "keypress": if (Yp(t) === 0) break e; case "keydown": case "keyup": m = xI; break; case "focusin": v = "focus", m = iy; break; case "focusout": v = "blur", m = iy; break; case "beforeblur": case "afterblur": m = iy; break; case "click": if (t.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = eS; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = aI; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = MI; break; case n2: case i2: case r2: m = cI; break; case s2: m = SI; break; case "scroll": m = sI; break; case "wheel": m = EI; break; case "copy": case "cut": case "paste": m = dI; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = nS }var y = (e & 4) !== 0, x = !y && n === "scroll", A = y ? p !== null ? p + "Capture" : null : p; y = []; for (var _ = f, w; _ !== null;) { w = _; var S = w.stateNode; if (w.tag === 5 && S !== null && (w = S, A !== null && (S = Sf(_, A), S != null && y.push(Rf(_, S, w)))), x) break; _ = _.return } 0 < y.length && (p = new m(p, v, null, t, d), h.push({ event: p, listeners: y })) } } if (!(e & 7)) { e: { if (p = n === "mouseover" || n === "pointerover", m = n === "mouseout" || n === "pointerout", p && t !== zv && (v = t.relatedTarget || t.fromElement) && (Pa(v) || v[Us])) break e; if ((m || p) && (p = d.window === d ? d : (p = d.ownerDocument) ? p.defaultView || p.parentWindow : window, m ? (v = t.relatedTarget || t.toElement, m = f, v = v ? Pa(v) : null, v !== null && (x = rl(v), v !== x || v.tag !== 5 && v.tag !== 6) && (v = null)) : (m = null, v = f), m !== v)) { if (y = eS, S = "onMouseLeave", A = "onMouseEnter", _ = "mouse", (n === "pointerout" || n === "pointerover") && (y = nS, S = "onPointerLeave", A = "onPointerEnter", _ = "pointer"), x = m == null ? p : ql(m), w = v == null ? p : ql(v), p = new y(S, _ + "leave", m, t, d), p.target = x, p.relatedTarget = w, S = null, Pa(d) === f && (y = new y(A, _ + "enter", v, t, d), y.target = w, y.relatedTarget = x, S = y), x = S, m && v) t: { for (y = m, A = v, _ = 0, w = y; w; w = Cl(w))_++; for (w = 0, S = A; S; S = Cl(S))w++; for (; 0 < _ - w;)y = Cl(y), _--; for (; 0 < w - _;)A = Cl(A), w--; for (; _--;) { if (y === A || A !== null && y === A.alternate) break t; y = Cl(y), A = Cl(A) } y = null } else y = null; m !== null && hS(h, p, m, y, !1), v !== null && x !== null && hS(h, x, v, y, !0) } } e: { if (p = f ? ql(f) : window, m = p.nodeName && p.nodeName.toLowerCase(), m === "select" || m === "input" && p.type === "file") var T = DI; else if (sS(p)) if (Zb) T = OI; else { T = FI; var P = II } else (m = p.nodeName) && m.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (T = NI); if (T && (T = T(n, f))) { Qb(h, T, t, d); break e } P && P(n, p, f), n === "focusout" && (P = p._wrapperState) && P.controlled && p.type === "number" && Fv(p, "number", p.value) } switch (P = f ? ql(f) : window, n) { case "focusin": (sS(P) || P.contentEditable === "true") && (Ql = P, Xv = f, of = null); break; case "focusout": of = Xv = Ql = null; break; case "mousedown": Yv = !0; break; case "contextmenu": case "mouseup": case "dragend": Yv = !1, cS(h, t, d); break; case "selectionchange": if (zI) break; case "keydown": case "keyup": cS(h, t, d) }var R; if (nA) e: { switch (n) { case "compositionstart": var E = "onCompositionStart"; break e; case "compositionend": E = "onCompositionEnd"; break e; case "compositionupdate": E = "onCompositionUpdate"; break e }E = void 0 } else Kl ? Yb(n, t) && (E = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (E = "onCompositionStart"); E && (Xb && t.locale !== "ko" && (Kl || E !== "onCompositionStart" ? E === "onCompositionEnd" && Kl && (R = Jb()) : (Ao = d, $1 = "value" in Ao ? Ao.value : Ao.textContent, Kl = !0)), P = _m(f, E), 0 < P.length && (E = new tS(E, n, null, t, d), h.push({ event: E, listeners: P }), R ? E.data = R : (R = Kb(t), R !== null && (E.data = R)))), (R = bI ? PI(n, t) : BI(n, t)) && (f = _m(f, "onBeforeInput"), 0 < f.length && (d = new tS("onBeforeInput", "beforeinput", null, t, d), h.push({ event: d, listeners: f }), d.data = R)) } a2(h, e) }) } function Rf(n, e, t) { return { instance: n, listener: e, currentTarget: t } } function _m(n, e) { for (var t = e + "Capture", i = []; n !== null;) { var r = n, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = Sf(n, t), s != null && i.unshift(Rf(n, s, r)), s = Sf(n, e), s != null && i.push(Rf(n, s, r))), n = n.return } return i } function Cl(n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5); return n || null } function hS(n, e, t, i, r) { for (var s = e._reactName, o = []; t !== null && t !== i;) { var a = t, l = a.alternate, f = a.stateNode; if (l !== null && l === i) break; a.tag === 5 && f !== null && (a = f, r ? (l = Sf(t, s), l != null && o.unshift(Rf(t, l, a))) : r || (l = Sf(t, s), l != null && o.push(Rf(t, l, a)))), t = t.return } o.length !== 0 && n.push({ event: e, listeners: o }) } var WI = /\r\n?/g, jI = /\u0000|\uFFFD/g; function pS(n) {
	return (typeof n == "string" ? n : "" + n).replace(WI, `
`).replace(jI, "")
} function Vh(n, e, t) { if (e = pS(e), pS(n) !== e && t) throw Error(Se(425)) } function Mm() { } var Kv = null, Qv = null; function Zv(n, e) { return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var qv = typeof setTimeout == "function" ? setTimeout : void 0, JI = typeof clearTimeout == "function" ? clearTimeout : void 0, mS = typeof Promise == "function" ? Promise : void 0, XI = typeof queueMicrotask == "function" ? queueMicrotask : typeof mS < "u" ? function (n) { return mS.resolve(null).then(n).catch(YI) } : qv; function YI(n) { setTimeout(function () { throw n }) } function fy(n, e) { var t = e, i = 0; do { var r = t.nextSibling; if (n.removeChild(t), r && r.nodeType === 8) if (t = r.data, t === "/$") { if (i === 0) { n.removeChild(r), Tf(e); return } i-- } else t !== "$" && t !== "$?" && t !== "$!" || i++; t = r } while (t); Tf(e) } function bo(n) { for (; n != null; n = n.nextSibling) { var e = n.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = n.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return n } function gS(n) { n = n.previousSibling; for (var e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "$" || t === "$!" || t === "$?") { if (e === 0) return n; e-- } else t === "/$" && e++ } n = n.previousSibling } return null } var Hu = Math.random().toString(36).slice(2), Zr = "__reactFiber$" + Hu, Lf = "__reactProps$" + Hu, Us = "__reactContainer$" + Hu, $v = "__reactEvents$" + Hu, KI = "__reactListeners$" + Hu, QI = "__reactHandles$" + Hu; function Pa(n) { var e = n[Zr]; if (e) return e; for (var t = n.parentNode; t;) { if (e = t[Us] || t[Zr]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n = gS(n); n !== null;) { if (t = n[Zr]) return t; n = gS(n) } return e } n = t, t = n.parentNode } return null } function ud(n) { return n = n[Zr] || n[Us], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n } function ql(n) { if (n.tag === 5 || n.tag === 6) return n.stateNode; throw Error(Se(33)) } function og(n) { return n[Lf] || null } var ex = [], $l = -1; function jo(n) { return { current: n } } function jt(n) { 0 > $l || (n.current = ex[$l], ex[$l] = null, $l--) } function Ht(n, e) { $l++, ex[$l] = n.current, n.current = e } var No = {}, $n = jo(No), wi = jo(!1), Ya = No; function Mu(n, e) { var t = n.type.contextTypes; if (!t) return No; var i = n.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in t) r[s] = e[s]; return i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = r), r } function Si(n) { return n = n.childContextTypes, n != null } function wm() { jt(wi), jt($n) } function yS(n, e, t) { if ($n.current !== No) throw Error(Se(168)); Ht($n, e), Ht(wi, t) } function u2(n, e, t) { var i = n.stateNode; if (e = e.childContextTypes, typeof i.getChildContext != "function") return t; i = i.getChildContext(); for (var r in i) if (!(r in e)) throw Error(Se(108, ID(n) || "Unknown", r)); return sn({}, t, i) } function Sm(n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || No, Ya = $n.current, Ht($n, n), Ht(wi, wi.current), !0 } function vS(n, e, t) { var i = n.stateNode; if (!i) throw Error(Se(169)); t ? (n = u2(n, e, Ya), i.__reactInternalMemoizedMergedChildContext = n, jt(wi), jt($n), Ht($n, n)) : jt(wi), Ht(wi, t) } var Cs = null, ag = !1, dy = !1; function c2(n) { Cs === null ? Cs = [n] : Cs.push(n) } function ZI(n) { ag = !0, c2(n) } function Jo() { if (!dy && Cs !== null) { dy = !0; var n = 0, e = Ot; try { var t = Cs; for (Ot = 1; n < t.length; n++) { var i = t[n]; do i = i(!0); while (i !== null) } Cs = null, ag = !1 } catch (r) { throw Cs !== null && (Cs = Cs.slice(n + 1)), Fb(K1, Jo), r } finally { Ot = e, dy = !1 } } return null } var eu = [], tu = 0, Cm = null, Em = 0, ar = [], lr = 0, Ka = null, bs = 1, Ps = ""; function xa(n, e) { eu[tu++] = Em, eu[tu++] = Cm, Cm = n, Em = e } function f2(n, e, t) { ar[lr++] = bs, ar[lr++] = Ps, ar[lr++] = Ka, Ka = n; var i = bs; n = Ps; var r = 32 - Rr(i) - 1; i &= ~(1 << r), t += 1; var s = 32 - Rr(e) + r; if (30 < s) { var o = r - r % 5; s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, bs = 1 << 32 - Rr(e) + r | t << r | i, Ps = s + n } else bs = 1 << s | t << r | i, Ps = n } function rA(n) { n.return !== null && (xa(n, 1), f2(n, 1, 0)) } function sA(n) { for (; n === Cm;)Cm = eu[--tu], eu[tu] = null, Em = eu[--tu], eu[tu] = null; for (; n === Ka;)Ka = ar[--lr], ar[lr] = null, Ps = ar[--lr], ar[lr] = null, bs = ar[--lr], ar[lr] = null } var ki = null, Ni = null, Kt = !1, br = null; function d2(n, e) { var t = cr(5, null, null, 0); t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t) } function xS(n, e) { switch (n.tag) { case 5: var t = n.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, ki = n, Ni = bo(e.firstChild), !0) : !1; case 6: return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, ki = n, Ni = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Ka !== null ? { id: bs, overflow: Ps } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = cr(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, ki = n, Ni = null, !0) : !1; default: return !1 } } function tx(n) { return (n.mode & 1) !== 0 && (n.flags & 128) === 0 } function nx(n) { if (Kt) { var e = Ni; if (e) { var t = e; if (!xS(n, e)) { if (tx(n)) throw Error(Se(418)); e = bo(t.nextSibling); var i = ki; e && xS(n, e) ? d2(i, t) : (n.flags = n.flags & -4097 | 2, Kt = !1, ki = n) } } else { if (tx(n)) throw Error(Se(418)); n.flags = n.flags & -4097 | 2, Kt = !1, ki = n } } } function AS(n) { for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;)n = n.return; ki = n } function Wh(n) { if (n !== ki) return !1; if (!Kt) return AS(n), Kt = !0, !1; var e; if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !Zv(n.type, n.memoizedProps)), e && (e = Ni)) { if (tx(n)) throw h2(), Error(Se(418)); for (; e;)d2(n, e), e = bo(e.nextSibling) } if (AS(n), n.tag === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(Se(317)); e: { for (n = n.nextSibling, e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "/$") { if (e === 0) { Ni = bo(n.nextSibling); break e } e-- } else t !== "$" && t !== "$!" && t !== "$?" || e++ } n = n.nextSibling } Ni = null } } else Ni = ki ? bo(n.stateNode.nextSibling) : null; return !0 } function h2() { for (var n = Ni; n;)n = bo(n.nextSibling) } function wu() { Ni = ki = null, Kt = !1 } function oA(n) { br === null ? br = [n] : br.push(n) } var qI = js.ReactCurrentBatchConfig; function Cr(n, e) { if (n && n.defaultProps) { e = sn({}, e), n = n.defaultProps; for (var t in n) e[t] === void 0 && (e[t] = n[t]); return e } return e } var Tm = jo(null), bm = null, nu = null, aA = null; function lA() { aA = nu = bm = null } function uA(n) { var e = Tm.current; jt(Tm), n._currentValue = e } function ix(n, e, t) { for (; n !== null;) { var i = n.alternate; if ((n.childLanes & e) !== e ? (n.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n === t) break; n = n.return } } function gu(n, e) { bm = n, aA = nu = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (_i = !0), n.firstContext = null) } function hr(n) { var e = n._currentValue; if (aA !== n) if (n = { context: n, memoizedValue: e, next: null }, nu === null) { if (bm === null) throw Error(Se(308)); nu = n, bm.dependencies = { lanes: 0, firstContext: n } } else nu = nu.next = n; return e } var Ba = null; function cA(n) { Ba === null ? Ba = [n] : Ba.push(n) } function p2(n, e, t, i) { var r = e.interleaved; return r === null ? (t.next = t, cA(e)) : (t.next = r.next, r.next = t), e.interleaved = t, zs(n, i) } function zs(n, e) { n.lanes |= e; var t = n.alternate; for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;)n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return; return t.tag === 3 ? t.stateNode : null } var mo = !1; function fA(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function m2(n, e) { n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function Is(n, e) { return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null } } function Po(n, e, t) { var i = n.updateQueue; if (i === null) return null; if (i = i.shared, Bt & 2) { var r = i.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, zs(n, t) } return r = i.interleaved, r === null ? (e.next = e, cA(i)) : (e.next = r.next, r.next = e), i.interleaved = e, zs(n, t) } function Kp(n, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { var i = e.lanes; i &= n.pendingLanes, t |= i, e.lanes = t, Q1(n, t) } } function _S(n, e) { var t = n.updateQueue, i = n.alternate; if (i !== null && (i = i.updateQueue, t === i)) { var r = null, s = null; if (t = t.firstBaseUpdate, t !== null) { do { var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; s === null ? r = s = o : s = s.next = o, t = t.next } while (t !== null); s === null ? r = s = e : s = s.next = e } else r = s = e; t = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, n.updateQueue = t; return } n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e } function Pm(n, e, t, i) { var r = n.updateQueue; mo = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, f = l.next; l.next = null, o === null ? s = f : o.next = f, o = l; var d = n.alternate; d !== null && (d = d.updateQueue, a = d.lastBaseUpdate, a !== o && (a === null ? d.firstBaseUpdate = f : a.next = f, d.lastBaseUpdate = l)) } if (s !== null) { var h = r.baseState; o = 0, d = f = l = null, a = s; do { var p = a.lane, m = a.eventTime; if ((i & p) === p) { d !== null && (d = d.next = { eventTime: m, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var v = n, y = a; switch (p = e, m = t, y.tag) { case 1: if (v = y.payload, typeof v == "function") { h = v.call(m, h, p); break e } h = v; break e; case 3: v.flags = v.flags & -65537 | 128; case 0: if (v = y.payload, p = typeof v == "function" ? v.call(m, h, p) : v, p == null) break e; h = sn({}, h, p); break e; case 2: mo = !0 } } a.callback !== null && a.lane !== 0 && (n.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a)) } else m = { eventTime: m, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, d === null ? (f = d = m, l = h) : d = d.next = m, o |= p; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null } } while (1); if (d === null && (l = h), r.baseState = l, r.firstBaseUpdate = f, r.lastBaseUpdate = d, e = r.shared.interleaved, e !== null) { r = e; do o |= r.lane, r = r.next; while (r !== e) } else s === null && (r.shared.lanes = 0); Za |= o, n.lanes = o, n.memoizedState = h } } function MS(n, e, t) { if (n = e.effects, e.effects = null, n !== null) for (e = 0; e < n.length; e++) { var i = n[e], r = i.callback; if (r !== null) { if (i.callback = null, i = t, typeof r != "function") throw Error(Se(191, r)); r.call(i) } } } var g2 = new pb.Component().refs; function rx(n, e, t, i) { e = n.memoizedState, t = t(i, e), t = t == null ? e : sn({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t) } var lg = { isMounted: function (n) { return (n = n._reactInternals) ? rl(n) === n : !1 }, enqueueSetState: function (n, e, t) { n = n._reactInternals; var i = ui(), r = Ro(n), s = Is(i, r); s.payload = e, t != null && (s.callback = t), e = Po(n, s, r), e !== null && (Lr(e, n, r, i), Kp(e, n, r)) }, enqueueReplaceState: function (n, e, t) { n = n._reactInternals; var i = ui(), r = Ro(n), s = Is(i, r); s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Po(n, s, r), e !== null && (Lr(e, n, r, i), Kp(e, n, r)) }, enqueueForceUpdate: function (n, e) { n = n._reactInternals; var t = ui(), i = Ro(n), r = Is(t, i); r.tag = 2, e != null && (r.callback = e), e = Po(n, r, i), e !== null && (Lr(e, n, i, t), Kp(e, n, i)) } }; function wS(n, e, t, i, r, s, o) { return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Pf(t, i) || !Pf(r, s) : !0 } function y2(n, e, t) { var i = !1, r = No, s = e.contextType; return typeof s == "object" && s !== null ? s = hr(s) : (r = Si(e) ? Ya : $n.current, i = e.contextTypes, s = (i = i != null) ? Mu(n, r) : No), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = lg, n.stateNode = e, e._reactInternals = n, i && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = r, n.__reactInternalMemoizedMaskedChildContext = s), e } function SS(n, e, t, i) { n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n && lg.enqueueReplaceState(e, e.state, null) } function sx(n, e, t, i) { var r = n.stateNode; r.props = t, r.state = n.memoizedState, r.refs = g2, fA(n); var s = e.contextType; typeof s == "object" && s !== null ? r.context = hr(s) : (s = Si(e) ? Ya : $n.current, r.context = Mu(n, s)), r.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (rx(n, e, s, t), r.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && lg.enqueueReplaceState(r, r.state, null), Pm(n, t, r, i), r.state = n.memoizedState), typeof r.componentDidMount == "function" && (n.flags |= 4194308) } function Sc(n, e, t) { if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(Se(309)); var i = t.stateNode } if (!i) throw Error(Se(147, n)); var r = i, s = "" + n; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (o) { var a = r.refs; a === g2 && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, e._stringRef = s, e) } if (typeof n != "string") throw Error(Se(284)); if (!t._owner) throw Error(Se(290, n)) } return n } function jh(n, e) { throw n = Object.prototype.toString.call(e), Error(Se(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n)) } function CS(n) { var e = n._init; return e(n._payload) } function v2(n) { function e(A, _) { if (n) { var w = A.deletions; w === null ? (A.deletions = [_], A.flags |= 16) : w.push(_) } } function t(A, _) { if (!n) return null; for (; _ !== null;)e(A, _), _ = _.sibling; return null } function i(A, _) { for (A = new Map; _ !== null;)_.key !== null ? A.set(_.key, _) : A.set(_.index, _), _ = _.sibling; return A } function r(A, _) { return A = Lo(A, _), A.index = 0, A.sibling = null, A } function s(A, _, w) { return A.index = w, n ? (w = A.alternate, w !== null ? (w = w.index, w < _ ? (A.flags |= 2, _) : w) : (A.flags |= 2, _)) : (A.flags |= 1048576, _) } function o(A) { return n && A.alternate === null && (A.flags |= 2), A } function a(A, _, w, S) { return _ === null || _.tag !== 6 ? (_ = xy(w, A.mode, S), _.return = A, _) : (_ = r(_, w), _.return = A, _) } function l(A, _, w, S) { var T = w.type; return T === Yl ? d(A, _, w.props.children, S, w.key) : _ !== null && (_.elementType === T || typeof T == "object" && T !== null && T.$$typeof === po && CS(T) === _.type) ? (S = r(_, w.props), S.ref = Sc(A, _, w), S.return = A, S) : (S = tm(w.type, w.key, w.props, null, A.mode, S), S.ref = Sc(A, _, w), S.return = A, S) } function f(A, _, w, S) { return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== w.containerInfo || _.stateNode.implementation !== w.implementation ? (_ = Ay(w, A.mode, S), _.return = A, _) : (_ = r(_, w.children || []), _.return = A, _) } function d(A, _, w, S, T) { return _ === null || _.tag !== 7 ? (_ = za(w, A.mode, S, T), _.return = A, _) : (_ = r(_, w), _.return = A, _) } function h(A, _, w) { if (typeof _ == "string" && _ !== "" || typeof _ == "number") return _ = xy("" + _, A.mode, w), _.return = A, _; if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case Ih: return w = tm(_.type, _.key, _.props, null, A.mode, w), w.ref = Sc(A, null, _), w.return = A, w; case Xl: return _ = Ay(_, A.mode, w), _.return = A, _; case po: var S = _._init; return h(A, S(_._payload), w) }if (Qc(_) || xc(_)) return _ = za(_, A.mode, w, null), _.return = A, _; jh(A, _) } return null } function p(A, _, w, S) { var T = _ !== null ? _.key : null; if (typeof w == "string" && w !== "" || typeof w == "number") return T !== null ? null : a(A, _, "" + w, S); if (typeof w == "object" && w !== null) { switch (w.$$typeof) { case Ih: return w.key === T ? l(A, _, w, S) : null; case Xl: return w.key === T ? f(A, _, w, S) : null; case po: return T = w._init, p(A, _, T(w._payload), S) }if (Qc(w) || xc(w)) return T !== null ? null : d(A, _, w, S, null); jh(A, w) } return null } function m(A, _, w, S, T) { if (typeof S == "string" && S !== "" || typeof S == "number") return A = A.get(w) || null, a(_, A, "" + S, T); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Ih: return A = A.get(S.key === null ? w : S.key) || null, l(_, A, S, T); case Xl: return A = A.get(S.key === null ? w : S.key) || null, f(_, A, S, T); case po: var P = S._init; return m(A, _, w, P(S._payload), T) }if (Qc(S) || xc(S)) return A = A.get(w) || null, d(_, A, S, T, null); jh(_, S) } return null } function v(A, _, w, S) { for (var T = null, P = null, R = _, E = _ = 0, B = null; R !== null && E < w.length; E++) { R.index > E ? (B = R, R = null) : B = R.sibling; var L = p(A, R, w[E], S); if (L === null) { R === null && (R = B); break } n && R && L.alternate === null && e(A, R), _ = s(L, _, E), P === null ? T = L : P.sibling = L, P = L, R = B } if (E === w.length) return t(A, R), Kt && xa(A, E), T; if (R === null) { for (; E < w.length; E++)R = h(A, w[E], S), R !== null && (_ = s(R, _, E), P === null ? T = R : P.sibling = R, P = R); return Kt && xa(A, E), T } for (R = i(A, R); E < w.length; E++)B = m(R, A, E, w[E], S), B !== null && (n && B.alternate !== null && R.delete(B.key === null ? E : B.key), _ = s(B, _, E), P === null ? T = B : P.sibling = B, P = B); return n && R.forEach(function (U) { return e(A, U) }), Kt && xa(A, E), T } function y(A, _, w, S) { var T = xc(w); if (typeof T != "function") throw Error(Se(150)); if (w = T.call(w), w == null) throw Error(Se(151)); for (var P = T = null, R = _, E = _ = 0, B = null, L = w.next(); R !== null && !L.done; E++, L = w.next()) { R.index > E ? (B = R, R = null) : B = R.sibling; var U = p(A, R, L.value, S); if (U === null) { R === null && (R = B); break } n && R && U.alternate === null && e(A, R), _ = s(U, _, E), P === null ? T = U : P.sibling = U, P = U, R = B } if (L.done) return t(A, R), Kt && xa(A, E), T; if (R === null) { for (; !L.done; E++, L = w.next())L = h(A, L.value, S), L !== null && (_ = s(L, _, E), P === null ? T = L : P.sibling = L, P = L); return Kt && xa(A, E), T } for (R = i(A, R); !L.done; E++, L = w.next())L = m(R, A, E, L.value, S), L !== null && (n && L.alternate !== null && R.delete(L.key === null ? E : L.key), _ = s(L, _, E), P === null ? T = L : P.sibling = L, P = L); return n && R.forEach(function (q) { return e(A, q) }), Kt && xa(A, E), T } function x(A, _, w, S) { if (typeof w == "object" && w !== null && w.type === Yl && w.key === null && (w = w.props.children), typeof w == "object" && w !== null) { switch (w.$$typeof) { case Ih: e: { for (var T = w.key, P = _; P !== null;) { if (P.key === T) { if (T = w.type, T === Yl) { if (P.tag === 7) { t(A, P.sibling), _ = r(P, w.props.children), _.return = A, A = _; break e } } else if (P.elementType === T || typeof T == "object" && T !== null && T.$$typeof === po && CS(T) === P.type) { t(A, P.sibling), _ = r(P, w.props), _.ref = Sc(A, P, w), _.return = A, A = _; break e } t(A, P); break } else e(A, P); P = P.sibling } w.type === Yl ? (_ = za(w.props.children, A.mode, S, w.key), _.return = A, A = _) : (S = tm(w.type, w.key, w.props, null, A.mode, S), S.ref = Sc(A, _, w), S.return = A, A = S) } return o(A); case Xl: e: { for (P = w.key; _ !== null;) { if (_.key === P) if (_.tag === 4 && _.stateNode.containerInfo === w.containerInfo && _.stateNode.implementation === w.implementation) { t(A, _.sibling), _ = r(_, w.children || []), _.return = A, A = _; break e } else { t(A, _); break } else e(A, _); _ = _.sibling } _ = Ay(w, A.mode, S), _.return = A, A = _ } return o(A); case po: return P = w._init, x(A, _, P(w._payload), S) }if (Qc(w)) return v(A, _, w, S); if (xc(w)) return y(A, _, w, S); jh(A, w) } return typeof w == "string" && w !== "" || typeof w == "number" ? (w = "" + w, _ !== null && _.tag === 6 ? (t(A, _.sibling), _ = r(_, w), _.return = A, A = _) : (t(A, _), _ = xy(w, A.mode, S), _.return = A, A = _), o(A)) : t(A, _) } return x } var Su = v2(!0), x2 = v2(!1), cd = {}, $r = jo(cd), Df = jo(cd), If = jo(cd); function Ra(n) { if (n === cd) throw Error(Se(174)); return n } function dA(n, e) { switch (Ht(If, e), Ht(Df, n), Ht($r, cd), n = e.nodeType, n) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Ov(null, ""); break; default: n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = Ov(e, n) }jt($r), Ht($r, e) } function Cu() { jt($r), jt(Df), jt(If) } function A2(n) { Ra(If.current); var e = Ra($r.current), t = Ov(e, n.type); e !== t && (Ht(Df, n), Ht($r, t)) } function hA(n) { Df.current === n && (jt($r), jt(Df)) } var $t = jo(0); function Bm(n) { for (var e = n; e !== null;) { if (e.tag === 13) { var t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var hy = []; function pA() { for (var n = 0; n < hy.length; n++)hy[n]._workInProgressVersionPrimary = null; hy.length = 0 } var Qp = js.ReactCurrentDispatcher, py = js.ReactCurrentBatchConfig, Qa = 0, rn = null, Cn = null, Nn = null, Rm = !1, af = !1, Ff = 0, $I = 0; function Yn() { throw Error(Se(321)) } function mA(n, e) { if (e === null) return !1; for (var t = 0; t < e.length && t < n.length; t++)if (!Fr(n[t], e[t])) return !1; return !0 } function gA(n, e, t, i, r, s) { if (Qa = s, rn = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Qp.current = n === null || n.memoizedState === null ? iF : rF, n = t(i, r), af) { s = 0; do { if (af = !1, Ff = 0, 25 <= s) throw Error(Se(301)); s += 1, Nn = Cn = null, e.updateQueue = null, Qp.current = sF, n = t(i, r) } while (af) } if (Qp.current = Lm, e = Cn !== null && Cn.next !== null, Qa = 0, Nn = Cn = rn = null, Rm = !1, e) throw Error(Se(300)); return n } function yA() { var n = Ff !== 0; return Ff = 0, n } function Kr() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Nn === null ? rn.memoizedState = Nn = n : Nn = Nn.next = n, Nn } function pr() { if (Cn === null) { var n = rn.alternate; n = n !== null ? n.memoizedState : null } else n = Cn.next; var e = Nn === null ? rn.memoizedState : Nn.next; if (e !== null) Nn = e, Cn = n; else { if (n === null) throw Error(Se(310)); Cn = n, n = { memoizedState: Cn.memoizedState, baseState: Cn.baseState, baseQueue: Cn.baseQueue, queue: Cn.queue, next: null }, Nn === null ? rn.memoizedState = Nn = n : Nn = Nn.next = n } return Nn } function Nf(n, e) { return typeof e == "function" ? e(n) : e } function my(n) { var e = pr(), t = e.queue; if (t === null) throw Error(Se(311)); t.lastRenderedReducer = n; var i = Cn, r = i.baseQueue, s = t.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } i.baseQueue = r = s, t.pending = null } if (r !== null) { s = r.next, i = i.baseState; var a = o = null, l = null, f = s; do { var d = f.lane; if ((Qa & d) === d) l !== null && (l = l.next = { lane: 0, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null }), i = f.hasEagerState ? f.eagerState : n(i, f.action); else { var h = { lane: d, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null }; l === null ? (a = l = h, o = i) : l = l.next = h, rn.lanes |= d, Za |= d } f = f.next } while (f !== null && f !== s); l === null ? o = i : l.next = a, Fr(i, e.memoizedState) || (_i = !0), e.memoizedState = i, e.baseState = o, e.baseQueue = l, t.lastRenderedState = i } if (n = t.interleaved, n !== null) { r = n; do s = r.lane, rn.lanes |= s, Za |= s, r = r.next; while (r !== n) } else r === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function gy(n) { var e = pr(), t = e.queue; if (t === null) throw Error(Se(311)); t.lastRenderedReducer = n; var i = t.dispatch, r = t.pending, s = e.memoizedState; if (r !== null) { t.pending = null; var o = r = r.next; do s = n(s, o.action), o = o.next; while (o !== r); Fr(s, e.memoizedState) || (_i = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s } return [s, i] } function _2() { } function M2(n, e) { var t = rn, i = pr(), r = e(), s = !Fr(i.memoizedState, r); if (s && (i.memoizedState = r, _i = !0), i = i.queue, vA(C2.bind(null, t, i, n), [n]), i.getSnapshot !== e || s || Nn !== null && Nn.memoizedState.tag & 1) { if (t.flags |= 2048, Of(9, S2.bind(null, t, i, r, e), void 0, null), On === null) throw Error(Se(349)); Qa & 30 || w2(t, e, r) } return r } function w2(n, e, t) { n.flags |= 16384, n = { getSnapshot: e, value: t }, e = rn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, rn.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n)) } function S2(n, e, t, i) { e.value = t, e.getSnapshot = i, E2(e) && T2(n) } function C2(n, e, t) { return t(function () { E2(e) && T2(n) }) } function E2(n) { var e = n.getSnapshot; n = n.value; try { var t = e(); return !Fr(n, t) } catch { return !0 } } function T2(n) { var e = zs(n, 1); e !== null && Lr(e, n, 1, -1) } function ES(n) { var e = Kr(); return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Nf, lastRenderedState: n }, e.queue = n, n = n.dispatch = nF.bind(null, rn, n), [e.memoizedState, n] } function Of(n, e, t, i) { return n = { tag: n, create: e, destroy: t, deps: i, next: null }, e = rn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, rn.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (i = t.next, t.next = n, n.next = i, e.lastEffect = n)), n } function b2() { return pr().memoizedState } function Zp(n, e, t, i) { var r = Kr(); rn.flags |= n, r.memoizedState = Of(1 | e, t, void 0, i === void 0 ? null : i) } function ug(n, e, t, i) { var r = pr(); i = i === void 0 ? null : i; var s = void 0; if (Cn !== null) { var o = Cn.memoizedState; if (s = o.destroy, i !== null && mA(i, o.deps)) { r.memoizedState = Of(e, t, s, i); return } } rn.flags |= n, r.memoizedState = Of(1 | e, t, s, i) } function TS(n, e) { return Zp(8390656, 8, n, e) } function vA(n, e) { return ug(2048, 8, n, e) } function P2(n, e) { return ug(4, 2, n, e) } function B2(n, e) { return ug(4, 4, n, e) } function R2(n, e) { if (typeof e == "function") return n = n(), e(n), function () { e(null) }; if (e != null) return n = n(), e.current = n, function () { e.current = null } } function L2(n, e, t) { return t = t != null ? t.concat([n]) : null, ug(4, 4, R2.bind(null, e, n), t) } function xA() { } function D2(n, e) { var t = pr(); e = e === void 0 ? null : e; var i = t.memoizedState; return i !== null && e !== null && mA(e, i[1]) ? i[0] : (t.memoizedState = [n, e], n) } function I2(n, e) { var t = pr(); e = e === void 0 ? null : e; var i = t.memoizedState; return i !== null && e !== null && mA(e, i[1]) ? i[0] : (n = n(), t.memoizedState = [n, e], n) } function F2(n, e, t) { return Qa & 21 ? (Fr(t, e) || (t = kb(), rn.lanes |= t, Za |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, _i = !0), n.memoizedState = t) } function eF(n, e) { var t = Ot; Ot = t !== 0 && 4 > t ? t : 4, n(!0); var i = py.transition; py.transition = {}; try { n(!1), e() } finally { Ot = t, py.transition = i } } function N2() { return pr().memoizedState } function tF(n, e, t) { var i = Ro(n); if (t = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }, O2(n)) k2(e, t); else if (t = p2(n, e, t, i), t !== null) { var r = ui(); Lr(t, n, i, r), U2(t, e, i) } } function nF(n, e, t) { var i = Ro(n), r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null }; if (O2(n)) k2(e, r); else { var s = n.alternate; if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var o = e.lastRenderedState, a = s(o, t); if (r.hasEagerState = !0, r.eagerState = a, Fr(a, o)) { var l = e.interleaved; l === null ? (r.next = r, cA(e)) : (r.next = l.next, l.next = r), e.interleaved = r; return } } catch { } finally { } t = p2(n, e, r, i), t !== null && (r = ui(), Lr(t, n, i, r), U2(t, e, i)) } } function O2(n) { var e = n.alternate; return n === rn || e !== null && e === rn } function k2(n, e) { af = Rm = !0; var t = n.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e } function U2(n, e, t) { if (t & 4194240) { var i = e.lanes; i &= n.pendingLanes, t |= i, e.lanes = t, Q1(n, t) } } var Lm = { readContext: hr, useCallback: Yn, useContext: Yn, useEffect: Yn, useImperativeHandle: Yn, useInsertionEffect: Yn, useLayoutEffect: Yn, useMemo: Yn, useReducer: Yn, useRef: Yn, useState: Yn, useDebugValue: Yn, useDeferredValue: Yn, useTransition: Yn, useMutableSource: Yn, useSyncExternalStore: Yn, useId: Yn, unstable_isNewReconciler: !1 }, iF = { readContext: hr, useCallback: function (n, e) { return Kr().memoizedState = [n, e === void 0 ? null : e], n }, useContext: hr, useEffect: TS, useImperativeHandle: function (n, e, t) { return t = t != null ? t.concat([n]) : null, Zp(4194308, 4, R2.bind(null, e, n), t) }, useLayoutEffect: function (n, e) { return Zp(4194308, 4, n, e) }, useInsertionEffect: function (n, e) { return Zp(4, 2, n, e) }, useMemo: function (n, e) { var t = Kr(); return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n }, useReducer: function (n, e, t) { var i = Kr(); return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, i.queue = n, n = n.dispatch = tF.bind(null, rn, n), [i.memoizedState, n] }, useRef: function (n) { var e = Kr(); return n = { current: n }, e.memoizedState = n }, useState: ES, useDebugValue: xA, useDeferredValue: function (n) { return Kr().memoizedState = n }, useTransition: function () { var n = ES(!1), e = n[0]; return n = eF.bind(null, n[1]), Kr().memoizedState = n, [e, n] }, useMutableSource: function () { }, useSyncExternalStore: function (n, e, t) { var i = rn, r = Kr(); if (Kt) { if (t === void 0) throw Error(Se(407)); t = t() } else { if (t = e(), On === null) throw Error(Se(349)); Qa & 30 || w2(i, e, t) } r.memoizedState = t; var s = { value: t, getSnapshot: e }; return r.queue = s, TS(C2.bind(null, i, s, n), [n]), i.flags |= 2048, Of(9, S2.bind(null, i, s, t, e), void 0, null), t }, useId: function () { var n = Kr(), e = On.identifierPrefix; if (Kt) { var t = Ps, i = bs; t = (i & ~(1 << 32 - Rr(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Ff++, 0 < t && (e += "H" + t.toString(32)), e += ":" } else t = $I++, e = ":" + e + "r" + t.toString(32) + ":"; return n.memoizedState = e }, unstable_isNewReconciler: !1 }, rF = { readContext: hr, useCallback: D2, useContext: hr, useEffect: vA, useImperativeHandle: L2, useInsertionEffect: P2, useLayoutEffect: B2, useMemo: I2, useReducer: my, useRef: b2, useState: function () { return my(Nf) }, useDebugValue: xA, useDeferredValue: function (n) { var e = pr(); return F2(e, Cn.memoizedState, n) }, useTransition: function () { var n = my(Nf)[0], e = pr().memoizedState; return [n, e] }, useMutableSource: _2, useSyncExternalStore: M2, useId: N2, unstable_isNewReconciler: !1 }, sF = { readContext: hr, useCallback: D2, useContext: hr, useEffect: vA, useImperativeHandle: L2, useInsertionEffect: P2, useLayoutEffect: B2, useMemo: I2, useReducer: gy, useRef: b2, useState: function () { return gy(Nf) }, useDebugValue: xA, useDeferredValue: function (n) { var e = pr(); return Cn === null ? e.memoizedState = n : F2(e, Cn.memoizedState, n) }, useTransition: function () { var n = gy(Nf)[0], e = pr().memoizedState; return [n, e] }, useMutableSource: _2, useSyncExternalStore: M2, useId: N2, unstable_isNewReconciler: !1 }; function Eu(n, e) {
	try { var t = "", i = e; do t += DD(i), i = i.return; while (i); var r = t } catch (s) {
		r = `
Error generating stack: `+ s.message + `
`+ s.stack
	} return { value: n, source: e, stack: r, digest: null }
} function yy(n, e, t) { return { value: n, source: null, stack: t ?? null, digest: e ?? null } } function ox(n, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } var oF = typeof WeakMap == "function" ? WeakMap : Map; function z2(n, e, t) { t = Is(-1, t), t.tag = 3, t.payload = { element: null }; var i = e.value; return t.callback = function () { Im || (Im = !0, gx = i), ox(n, e) }, t } function G2(n, e, t) { t = Is(-1, t), t.tag = 3; var i = n.type.getDerivedStateFromError; if (typeof i == "function") { var r = e.value; t.payload = function () { return i(r) }, t.callback = function () { ox(n, e) } } var s = n.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function () { ox(n, e), typeof i != "function" && (Bo === null ? Bo = new Set([this]) : Bo.add(this)); var o = e.stack; this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" }) }), t } function bS(n, e, t) { var i = n.pingCache; if (i === null) { i = n.pingCache = new oF; var r = new Set; i.set(e, r) } else r = i.get(e), r === void 0 && (r = new Set, i.set(e, r)); r.has(t) || (r.add(t), n = AF.bind(null, n, e, t), e.then(n, n)) } function PS(n) { do { var e; if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n; n = n.return } while (n !== null); return null } function BS(n, e, t, i, r) { return n.mode & 1 ? (n.flags |= 65536, n.lanes = r, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Is(-1, 1), e.tag = 2, Po(t, e, 1))), t.lanes |= 1), n) } var aF = js.ReactCurrentOwner, _i = !1; function ai(n, e, t, i) { e.child = n === null ? x2(e, null, t, i) : Su(e, n.child, t, i) } function RS(n, e, t, i, r) { t = t.render; var s = e.ref; return gu(e, r), i = gA(n, e, t, i, s, r), t = yA(), n !== null && !_i ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Gs(n, e, r)) : (Kt && t && rA(e), e.flags |= 1, ai(n, e, i, r), e.child) } function LS(n, e, t, i, r) { if (n === null) { var s = t.type; return typeof s == "function" && !TA(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, H2(n, e, s, i, r)) : (n = tm(t.type, null, i, e, e.mode, r), n.ref = e.ref, n.return = e, e.child = n) } if (s = n.child, !(n.lanes & r)) { var o = s.memoizedProps; if (t = t.compare, t = t !== null ? t : Pf, t(o, i) && n.ref === e.ref) return Gs(n, e, r) } return e.flags |= 1, n = Lo(s, i), n.ref = e.ref, n.return = e, e.child = n } function H2(n, e, t, i, r) { if (n !== null) { var s = n.memoizedProps; if (Pf(s, i) && n.ref === e.ref) if (_i = !1, e.pendingProps = i = s, (n.lanes & r) !== 0) n.flags & 131072 && (_i = !0); else return e.lanes = n.lanes, Gs(n, e, r) } return ax(n, e, t, i, r) } function V2(n, e, t) { var i = e.pendingProps, r = i.children, s = n !== null ? n.memoizedState : null; if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ht(ru, Ii), Ii |= t; else { if (!(t & 1073741824)) return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, Ht(ru, Ii), Ii |= n, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : t, Ht(ru, Ii), Ii |= i } else s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, Ht(ru, Ii), Ii |= i; return ai(n, e, r, t), e.child } function W2(n, e) { var t = e.ref; (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function ax(n, e, t, i, r) { var s = Si(t) ? Ya : $n.current; return s = Mu(e, s), gu(e, r), t = gA(n, e, t, i, s, r), i = yA(), n !== null && !_i ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~r, Gs(n, e, r)) : (Kt && i && rA(e), e.flags |= 1, ai(n, e, t, r), e.child) } function DS(n, e, t, i, r) { if (Si(t)) { var s = !0; Sm(e) } else s = !1; if (gu(e, r), e.stateNode === null) qp(n, e), y2(e, t, i), sx(e, t, i, r), i = !0; else if (n === null) { var o = e.stateNode, a = e.memoizedProps; o.props = a; var l = o.context, f = t.contextType; typeof f == "object" && f !== null ? f = hr(f) : (f = Si(t) ? Ya : $n.current, f = Mu(e, f)); var d = t.getDerivedStateFromProps, h = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function"; h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== f) && SS(e, o, i, f), mo = !1; var p = e.memoizedState; o.state = p, Pm(e, i, o, r), l = e.memoizedState, a !== i || p !== l || wi.current || mo ? (typeof d == "function" && (rx(e, t, d, i), l = e.memoizedState), (a = mo || wS(e, t, a, i, p, l, f)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = f, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = !1) } else { o = e.stateNode, m2(n, e), a = e.memoizedProps, f = e.type === e.elementType ? a : Cr(e.type, a), o.props = f, h = e.pendingProps, p = o.context, l = t.contextType, typeof l == "object" && l !== null ? l = hr(l) : (l = Si(t) ? Ya : $n.current, l = Mu(e, l)); var m = t.getDerivedStateFromProps; (d = typeof m == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && SS(e, o, i, l), mo = !1, p = e.memoizedState, o.state = p, Pm(e, i, o, r); var v = e.memoizedState; a !== h || p !== v || wi.current || mo ? (typeof m == "function" && (rx(e, t, m, i), v = e.memoizedState), (f = mo || wS(e, t, f, i, p, v, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = v), o.props = i, o.state = v, o.context = l, i = f) : (typeof o.componentDidUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n.memoizedProps && p === n.memoizedState || (e.flags |= 1024), i = !1) } return lx(n, e, t, i, s, r) } function lx(n, e, t, i, r, s) { W2(n, e); var o = (e.flags & 128) !== 0; if (!i && !o) return r && vS(e, t, !1), Gs(n, e, s); i = e.stateNode, aF.current = e; var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render(); return e.flags |= 1, n !== null && o ? (e.child = Su(e, n.child, null, s), e.child = Su(e, null, a, s)) : ai(n, e, a, s), e.memoizedState = i.state, r && vS(e, t, !0), e.child } function j2(n) { var e = n.stateNode; e.pendingContext ? yS(n, e.pendingContext, e.pendingContext !== e.context) : e.context && yS(n, e.context, !1), dA(n, e.containerInfo) } function IS(n, e, t, i, r) { return wu(), oA(r), e.flags |= 256, ai(n, e, t, i), e.child } var ux = { dehydrated: null, treeContext: null, retryLane: 0 }; function cx(n) { return { baseLanes: n, cachePool: null, transitions: null } } function J2(n, e, t) { var i = e.pendingProps, r = $t.current, s = !1, o = (e.flags & 128) !== 0, a; if ((a = o) || (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (r |= 1), Ht($t, r & 1), n === null) return nx(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = dg(o, i, 0, null), n = za(n, i, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = cx(t), e.memoizedState = ux, n) : AA(e, o)); if (r = n.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return lF(n, e, o, i, a, r, t); if (s) { s = i.fallback, o = e.mode, r = n.child, a = r.sibling; var l = { mode: "hidden", children: i.children }; return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = Lo(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = Lo(a, s) : (s = za(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n.child.memoizedState, o = o === null ? cx(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n.childLanes & ~t, e.memoizedState = ux, i } return s = n.child, n = s.sibling, i = Lo(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = i, e.memoizedState = null, i } function AA(n, e) { return e = dg({ mode: "visible", children: e }, n.mode, 0, null), e.return = n, n.child = e } function Jh(n, e, t, i) { return i !== null && oA(i), Su(e, n.child, null, t), n = AA(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n } function lF(n, e, t, i, r, s, o) { if (t) return e.flags & 256 ? (e.flags &= -257, i = yy(Error(Se(422))), Jh(n, e, o, i)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = dg({ mode: "visible", children: i.children }, r, 0, null), s = za(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && Su(e, n.child, null, o), e.child.memoizedState = cx(o), e.memoizedState = ux, s); if (!(e.mode & 1)) return Jh(n, e, o, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst; return i = a, s = Error(Se(419)), i = yy(s, i, void 0), Jh(n, e, o, i) } if (a = (o & n.childLanes) !== 0, _i || a) { if (i = On, i !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, zs(n, r), Lr(i, n, r, -1)) } return EA(), i = yy(Error(Se(421))), Jh(n, e, o, i) } return r.data === "$?" ? (e.flags |= 128, e.child = n.child, e = _F.bind(null, n), r._reactRetry = e, null) : (n = s.treeContext, Ni = bo(r.nextSibling), ki = e, Kt = !0, br = null, n !== null && (ar[lr++] = bs, ar[lr++] = Ps, ar[lr++] = Ka, bs = n.id, Ps = n.overflow, Ka = e), e = AA(e, i.children), e.flags |= 4096, e) } function FS(n, e, t) { n.lanes |= e; var i = n.alternate; i !== null && (i.lanes |= e), ix(n.return, e, t) } function vy(n, e, t, i, r) { var s = n.memoizedState; s === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r) } function X2(n, e, t) { var i = e.pendingProps, r = i.revealOrder, s = i.tail; if (ai(n, e, i.children, t), i = $t.current, i & 2) i = i & 1 | 2, e.flags |= 128; else { if (n !== null && n.flags & 128) e: for (n = e.child; n !== null;) { if (n.tag === 13) n.memoizedState !== null && FS(n, t, e); else if (n.tag === 19) FS(n, t, e); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (; n.sibling === null;) { if (n.return === null || n.return === e) break e; n = n.return } n.sibling.return = n.return, n = n.sibling } i &= 1 } if (Ht($t, i), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (t = e.child, r = null; t !== null;)n = t.alternate, n !== null && Bm(n) === null && (r = t), t = t.sibling; t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), vy(e, !1, r, t, s); break; case "backwards": for (t = null, r = e.child, e.child = null; r !== null;) { if (n = r.alternate, n !== null && Bm(n) === null) { e.child = r; break } n = r.sibling, r.sibling = t, t = r, r = n } vy(e, !0, t, null, s); break; case "together": vy(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function qp(n, e) { !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2) } function Gs(n, e, t) { if (n !== null && (e.dependencies = n.dependencies), Za |= e.lanes, !(t & e.childLanes)) return null; if (n !== null && e.child !== n.child) throw Error(Se(153)); if (e.child !== null) { for (n = e.child, t = Lo(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;)n = n.sibling, t = t.sibling = Lo(n, n.pendingProps), t.return = e; t.sibling = null } return e.child } function uF(n, e, t) { switch (e.tag) { case 3: j2(e), wu(); break; case 5: A2(e); break; case 1: Si(e.type) && Sm(e); break; case 4: dA(e, e.stateNode.containerInfo); break; case 10: var i = e.type._context, r = e.memoizedProps.value; Ht(Tm, i._currentValue), i._currentValue = r; break; case 13: if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (Ht($t, $t.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? J2(n, e, t) : (Ht($t, $t.current & 1), n = Gs(n, e, t), n !== null ? n.sibling : null); Ht($t, $t.current & 1); break; case 19: if (i = (t & e.childLanes) !== 0, n.flags & 128) { if (i) return X2(n, e, t); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Ht($t, $t.current), i) break; return null; case 22: case 23: return e.lanes = 0, V2(n, e, t) }return Gs(n, e, t) } var Y2, fx, K2, Q2; Y2 = function (n, e) { for (var t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return } t.sibling.return = t.return, t = t.sibling } }; fx = function () { }; K2 = function (n, e, t, i) { var r = n.memoizedProps; if (r !== i) { n = e.stateNode, Ra($r.current); var s = null; switch (t) { case "input": r = Dv(n, r), i = Dv(n, i), s = []; break; case "select": r = sn({}, r, { value: void 0 }), i = sn({}, i, { value: void 0 }), s = []; break; case "textarea": r = Nv(n, r), i = Nv(n, i), s = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (n.onclick = Mm) }kv(t, i); var o; t = null; for (f in r) if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null) if (f === "style") { var a = r[f]; for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "") } else f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (Mf.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null)); for (f in i) { var l = i[f]; if (a = r != null ? r[f] : void 0, i.hasOwnProperty(f) && l !== a && (l != null || a != null)) if (f === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o]) } else t || (s || (s = []), s.push(f, t)), t = l; else f === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(f, l)) : f === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(f, "" + l) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (Mf.hasOwnProperty(f) ? (l != null && f === "onScroll" && Wt("scroll", n), s || a === l || (s = [])) : (s = s || []).push(f, l)) } t && (s = s || []).push("style", t); var f = s; (e.updateQueue = f) && (e.flags |= 4) } }; Q2 = function (n, e, t, i) { t !== i && (e.flags |= 4) }; function Cc(n, e) { if (!Kt) switch (n.tailMode) { case "hidden": e = n.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? n.tail = null : t.sibling = null; break; case "collapsed": t = n.tail; for (var i = null; t !== null;)t.alternate !== null && (i = t), t = t.sibling; i === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : i.sibling = null } } function Kn(n) { var e = n.alternate !== null && n.alternate.child === n.child, t = 0, i = 0; if (e) for (var r = n.child; r !== null;)t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n, r = r.sibling; else for (r = n.child; r !== null;)t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n, r = r.sibling; return n.subtreeFlags |= i, n.childLanes = t, e } function cF(n, e, t) { var i = e.pendingProps; switch (sA(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Kn(e), null; case 1: return Si(e.type) && wm(), Kn(e), null; case 3: return i = e.stateNode, Cu(), jt(wi), jt($n), pA(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n === null || n.child === null) && (Wh(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, br !== null && (xx(br), br = null))), fx(n, e), Kn(e), null; case 5: hA(e); var r = Ra(If.current); if (t = e.type, n !== null && e.stateNode != null) K2(n, e, t, i, r), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!i) { if (e.stateNode === null) throw Error(Se(166)); return Kn(e), null } if (n = Ra($r.current), Wh(e)) { i = e.stateNode, t = e.type; var s = e.memoizedProps; switch (i[Zr] = e, i[Lf] = s, n = (e.mode & 1) !== 0, t) { case "dialog": Wt("cancel", i), Wt("close", i); break; case "iframe": case "object": case "embed": Wt("load", i); break; case "video": case "audio": for (r = 0; r < qc.length; r++)Wt(qc[r], i); break; case "source": Wt("error", i); break; case "img": case "image": case "link": Wt("error", i), Wt("load", i); break; case "details": Wt("toggle", i); break; case "input": Ww(i, s), Wt("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!s.multiple }, Wt("invalid", i); break; case "textarea": Jw(i, s), Wt("invalid", i) }kv(t, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && Vh(i.textContent, a, n), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Vh(i.textContent, a, n), r = ["children", "" + a]) : Mf.hasOwnProperty(o) && a != null && o === "onScroll" && Wt("scroll", i) } switch (t) { case "input": Fh(i), jw(i, s, !0); break; case "textarea": Fh(i), Xw(i); break; case "select": case "option": break; default: typeof s.onClick == "function" && (i.onclick = Mm) }i = r, e.updateQueue = i, i !== null && (e.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = wb(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = o.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof i.is == "string" ? n = o.createElement(t, { is: i.is }) : (n = o.createElement(t), t === "select" && (o = n, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : n = o.createElementNS(n, t), n[Zr] = e, n[Lf] = i, Y2(n, e, !1, !1), e.stateNode = n; e: { switch (o = Uv(t, i), t) { case "dialog": Wt("cancel", n), Wt("close", n), r = i; break; case "iframe": case "object": case "embed": Wt("load", n), r = i; break; case "video": case "audio": for (r = 0; r < qc.length; r++)Wt(qc[r], n); r = i; break; case "source": Wt("error", n), r = i; break; case "img": case "image": case "link": Wt("error", n), Wt("load", n), r = i; break; case "details": Wt("toggle", n), r = i; break; case "input": Ww(n, i), r = Dv(n, i), Wt("invalid", n); break; case "option": r = i; break; case "select": n._wrapperState = { wasMultiple: !!i.multiple }, r = sn({}, i, { value: void 0 }), Wt("invalid", n); break; case "textarea": Jw(n, i), r = Nv(n, i), Wt("invalid", n); break; default: r = i }kv(t, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Eb(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Sb(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && wf(n, l) : typeof l == "number" && wf(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Mf.hasOwnProperty(s) ? l != null && s === "onScroll" && Wt("scroll", n) : l != null && W1(n, s, l, o)) } switch (t) { case "input": Fh(n), jw(n, i, !1); break; case "textarea": Fh(n), Xw(n); break; case "option": i.value != null && n.setAttribute("value", "" + Fo(i.value)); break; case "select": n.multiple = !!i.multiple, s = i.value, s != null ? du(n, !!i.multiple, s, !1) : i.defaultValue != null && du(n, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (n.onclick = Mm) }switch (t) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return Kn(e), null; case 6: if (n && e.stateNode != null) Q2(n, e, n.memoizedProps, i); else { if (typeof i != "string" && e.stateNode === null) throw Error(Se(166)); if (t = Ra(If.current), Ra($r.current), Wh(e)) { if (i = e.stateNode, t = e.memoizedProps, i[Zr] = e, (s = i.nodeValue !== t) && (n = ki, n !== null)) switch (n.tag) { case 3: Vh(i.nodeValue, t, (n.mode & 1) !== 0); break; case 5: n.memoizedProps.suppressHydrationWarning !== !0 && Vh(i.nodeValue, t, (n.mode & 1) !== 0) }s && (e.flags |= 4) } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[Zr] = e, e.stateNode = i } return Kn(e), null; case 13: if (jt($t), i = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (Kt && Ni !== null && e.mode & 1 && !(e.flags & 128)) h2(), wu(), e.flags |= 98560, s = !1; else if (s = Wh(e), i !== null && i.dehydrated !== null) { if (n === null) { if (!s) throw Error(Se(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Se(317)); s[Zr] = e } else wu(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; Kn(e), s = !1 } else br !== null && (xx(br), br = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n !== null && n.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n === null || $t.current & 1 ? En === 0 && (En = 3) : EA())), e.updateQueue !== null && (e.flags |= 4), Kn(e), null); case 4: return Cu(), fx(n, e), n === null && Bf(e.stateNode.containerInfo), Kn(e), null; case 10: return uA(e.type._context), Kn(e), null; case 17: return Si(e.type) && wm(), Kn(e), null; case 19: if (jt($t), s = e.memoizedState, s === null) return Kn(e), null; if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) Cc(s, !1); else { if (En !== 0 || n !== null && n.flags & 128) for (n = e.child; n !== null;) { if (o = Bm(n), o !== null) { for (e.flags |= 128, Cc(s, !1), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null;)s = t, n = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n = o.dependencies, s.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling; return Ht($t, $t.current & 1 | 2), e.child } n = n.sibling } s.tail !== null && mn() > Tu && (e.flags |= 128, i = !0, Cc(s, !1), e.lanes = 4194304) } else { if (!i) if (n = Bm(o), n !== null) { if (e.flags |= 128, i = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Cc(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Kt) return Kn(e), null } else 2 * mn() - s.renderingStartTime > Tu && t !== 1073741824 && (e.flags |= 128, i = !0, Cc(s, !1), e.lanes = 4194304); s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = mn(), e.sibling = null, t = $t.current, Ht($t, i ? t & 1 | 2 : t & 1), e) : (Kn(e), null); case 22: case 23: return CA(), i = e.memoizedState !== null, n !== null && n.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? Ii & 1073741824 && (Kn(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Kn(e), null; case 24: return null; case 25: return null }throw Error(Se(156, e.tag)) } function fF(n, e) { switch (sA(e), e.tag) { case 1: return Si(e.type) && wm(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 3: return Cu(), jt(wi), jt($n), pA(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null; case 5: return hA(e), null; case 13: if (jt($t), n = e.memoizedState, n !== null && n.dehydrated !== null) { if (e.alternate === null) throw Error(Se(340)); wu() } return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 19: return jt($t), null; case 4: return Cu(), null; case 10: return uA(e.type._context), null; case 22: case 23: return CA(), null; case 24: return null; default: return null } } var Xh = !1, qn = !1, dF = typeof WeakSet == "function" ? WeakSet : Set, Ge = null; function iu(n, e) { var t = n.ref; if (t !== null) if (typeof t == "function") try { t(null) } catch (i) { cn(n, e, i) } else t.current = null } function dx(n, e, t) { try { t() } catch (i) { cn(n, e, i) } } var NS = !1; function hF(n, e) { if (Kv = xm, n = e2(), iA(n)) { if ("selectionStart" in n) var t = { start: n.selectionStart, end: n.selectionEnd }; else e: { t = (t = n.ownerDocument) && t.defaultView || window; var i = t.getSelection && t.getSelection(); if (i && i.rangeCount !== 0) { t = i.anchorNode; var r = i.anchorOffset, s = i.focusNode; i = i.focusOffset; try { t.nodeType, s.nodeType } catch { t = null; break e } var o = 0, a = -1, l = -1, f = 0, d = 0, h = n, p = null; t: for (; ;) { for (var m; h !== t || r !== 0 && h.nodeType !== 3 || (a = o + r), h !== s || i !== 0 && h.nodeType !== 3 || (l = o + i), h.nodeType === 3 && (o += h.nodeValue.length), (m = h.firstChild) !== null;)p = h, h = m; for (; ;) { if (h === n) break t; if (p === t && ++f === r && (a = o), p === s && ++d === i && (l = o), (m = h.nextSibling) !== null) break; h = p, p = h.parentNode } h = m } t = a === -1 || l === -1 ? null : { start: a, end: l } } else t = null } t = t || { start: 0, end: 0 } } else t = null; for (Qv = { focusedElem: n, selectionRange: t }, xm = !1, Ge = e; Ge !== null;)if (e = Ge, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null) n.return = e, Ge = n; else for (; Ge !== null;) { e = Ge; try { var v = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (v !== null) { var y = v.memoizedProps, x = v.memoizedState, A = e.stateNode, _ = A.getSnapshotBeforeUpdate(e.elementType === e.type ? y : Cr(e.type, y), x); A.__reactInternalSnapshotBeforeUpdate = _ } break; case 3: var w = e.stateNode.containerInfo; w.nodeType === 1 ? w.textContent = "" : w.nodeType === 9 && w.documentElement && w.removeChild(w.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(Se(163)) } } catch (S) { cn(e, e.return, S) } if (n = e.sibling, n !== null) { n.return = e.return, Ge = n; break } Ge = e.return } return v = NS, NS = !1, v } function lf(n, e, t) { var i = e.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & n) === n) { var s = r.destroy; r.destroy = void 0, s !== void 0 && dx(e, t, s) } r = r.next } while (r !== i) } } function cg(n, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var t = e = e.next; do { if ((t.tag & n) === n) { var i = t.create; t.destroy = i() } t = t.next } while (t !== e) } } function hx(n) { var e = n.ref; if (e !== null) { var t = n.stateNode; switch (n.tag) { case 5: n = t; break; default: n = t }typeof e == "function" ? e(n) : e.current = n } } function Z2(n) { var e = n.alternate; e !== null && (n.alternate = null, Z2(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[Zr], delete e[Lf], delete e[$v], delete e[KI], delete e[QI])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } function q2(n) { return n.tag === 5 || n.tag === 3 || n.tag === 4 } function OS(n) { e: for (; ;) { for (; n.sibling === null;) { if (n.return === null || q2(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.flags & 2 || n.child === null || n.tag === 4) continue e; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function px(n, e, t) { var i = n.tag; if (i === 5 || i === 6) n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Mm)); else if (i !== 4 && (n = n.child, n !== null)) for (px(n, e, t), n = n.sibling; n !== null;)px(n, e, t), n = n.sibling } function mx(n, e, t) { var i = n.tag; if (i === 5 || i === 6) n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n); else if (i !== 4 && (n = n.child, n !== null)) for (mx(n, e, t), n = n.sibling; n !== null;)mx(n, e, t), n = n.sibling } var Un = null, Er = !1; function io(n, e, t) { for (t = t.child; t !== null;)$2(n, e, t), t = t.sibling } function $2(n, e, t) { if (qr && typeof qr.onCommitFiberUnmount == "function") try { qr.onCommitFiberUnmount(ng, t) } catch { } switch (t.tag) { case 5: qn || iu(t, e); case 6: var i = Un, r = Er; Un = null, io(n, e, t), Un = i, Er = r, Un !== null && (Er ? (n = Un, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : Un.removeChild(t.stateNode)); break; case 18: Un !== null && (Er ? (n = Un, t = t.stateNode, n.nodeType === 8 ? fy(n.parentNode, t) : n.nodeType === 1 && fy(n, t), Tf(n)) : fy(Un, t.stateNode)); break; case 4: i = Un, r = Er, Un = t.stateNode.containerInfo, Er = !0, io(n, e, t), Un = i, Er = r; break; case 0: case 11: case 14: case 15: if (!qn && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && dx(t, e, o), r = r.next } while (r !== i) } io(n, e, t); break; case 1: if (!qn && (iu(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount() } catch (a) { cn(t, e, a) } io(n, e, t); break; case 21: io(n, e, t); break; case 22: t.mode & 1 ? (qn = (i = qn) || t.memoizedState !== null, io(n, e, t), qn = i) : io(n, e, t); break; default: io(n, e, t) } } function kS(n) { var e = n.updateQueue; if (e !== null) { n.updateQueue = null; var t = n.stateNode; t === null && (t = n.stateNode = new dF), e.forEach(function (i) { var r = MF.bind(null, n, i); t.has(i) || (t.add(i), i.then(r, r)) }) } } function _r(n, e) { var t = e.deletions; if (t !== null) for (var i = 0; i < t.length; i++) { var r = t[i]; try { var s = n, o = e, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Un = a.stateNode, Er = !1; break e; case 3: Un = a.stateNode.containerInfo, Er = !0; break e; case 4: Un = a.stateNode.containerInfo, Er = !0; break e }a = a.return } if (Un === null) throw Error(Se(160)); $2(s, o, r), Un = null, Er = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (f) { cn(r, e, f) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)eP(e, n), e = e.sibling } function eP(n, e) { var t = n.alternate, i = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: if (_r(e, n), Yr(n), i & 4) { try { lf(3, n, n.return), cg(3, n) } catch (y) { cn(n, n.return, y) } try { lf(5, n, n.return) } catch (y) { cn(n, n.return, y) } } break; case 1: _r(e, n), Yr(n), i & 512 && t !== null && iu(t, t.return); break; case 5: if (_r(e, n), Yr(n), i & 512 && t !== null && iu(t, t.return), n.flags & 32) { var r = n.stateNode; try { wf(r, "") } catch (y) { cn(n, n.return, y) } } if (i & 4 && (r = n.stateNode, r != null)) { var s = n.memoizedProps, o = t !== null ? t.memoizedProps : s, a = n.type, l = n.updateQueue; if (n.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && _b(r, s), Uv(a, o); var f = Uv(a, s); for (o = 0; o < l.length; o += 2) { var d = l[o], h = l[o + 1]; d === "style" ? Eb(r, h) : d === "dangerouslySetInnerHTML" ? Sb(r, h) : d === "children" ? wf(r, h) : W1(r, d, h, f) } switch (a) { case "input": Iv(r, s); break; case "textarea": Mb(r, s); break; case "select": var p = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var m = s.value; m != null ? du(r, !!s.multiple, m, !1) : p !== !!s.multiple && (s.defaultValue != null ? du(r, !!s.multiple, s.defaultValue, !0) : du(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[Lf] = s } catch (y) { cn(n, n.return, y) } } break; case 6: if (_r(e, n), Yr(n), i & 4) { if (n.stateNode === null) throw Error(Se(162)); r = n.stateNode, s = n.memoizedProps; try { r.nodeValue = s } catch (y) { cn(n, n.return, y) } } break; case 3: if (_r(e, n), Yr(n), i & 4 && t !== null && t.memoizedState.isDehydrated) try { Tf(e.containerInfo) } catch (y) { cn(n, n.return, y) } break; case 4: _r(e, n), Yr(n); break; case 13: _r(e, n), Yr(n), r = n.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (wA = mn())), i & 4 && kS(n); break; case 22: if (d = t !== null && t.memoizedState !== null, n.mode & 1 ? (qn = (f = qn) || d, _r(e, n), qn = f) : _r(e, n), Yr(n), i & 8192) { if (f = n.memoizedState !== null, (n.stateNode.isHidden = f) && !d && n.mode & 1) for (Ge = n, d = n.child; d !== null;) { for (h = Ge = d; Ge !== null;) { switch (p = Ge, m = p.child, p.tag) { case 0: case 11: case 14: case 15: lf(4, p, p.return); break; case 1: iu(p, p.return); var v = p.stateNode; if (typeof v.componentWillUnmount == "function") { i = p, t = p.return; try { e = i, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount() } catch (y) { cn(i, t, y) } } break; case 5: iu(p, p.return); break; case 22: if (p.memoizedState !== null) { zS(h); continue } }m !== null ? (m.return = p, Ge = m) : zS(h) } d = d.sibling } e: for (d = null, h = n; ;) { if (h.tag === 5) { if (d === null) { d = h; try { r = h.stateNode, f ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Cb("display", o)) } catch (y) { cn(n, n.return, y) } } } else if (h.tag === 6) { if (d === null) try { h.stateNode.nodeValue = f ? "" : h.memoizedProps } catch (y) { cn(n, n.return, y) } } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) { h.child.return = h, h = h.child; continue } if (h === n) break e; for (; h.sibling === null;) { if (h.return === null || h.return === n) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: _r(e, n), Yr(n), i & 4 && kS(n); break; case 21: break; default: _r(e, n), Yr(n) } } function Yr(n) { var e = n.flags; if (e & 2) { try { e: { for (var t = n.return; t !== null;) { if (q2(t)) { var i = t; break e } t = t.return } throw Error(Se(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (wf(r, ""), i.flags &= -33); var s = OS(n); mx(n, s, r); break; case 3: case 4: var o = i.stateNode.containerInfo, a = OS(n); px(n, a, o); break; default: throw Error(Se(161)) } } catch (l) { cn(n, n.return, l) } n.flags &= -3 } e & 4096 && (n.flags &= -4097) } function pF(n, e, t) { Ge = n, tP(n) } function tP(n, e, t) { for (var i = (n.mode & 1) !== 0; Ge !== null;) { var r = Ge, s = r.child; if (r.tag === 22 && i) { var o = r.memoizedState !== null || Xh; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || qn; a = Xh; var f = qn; if (Xh = o, (qn = l) && !f) for (Ge = r; Ge !== null;)o = Ge, l = o.child, o.tag === 22 && o.memoizedState !== null ? GS(r) : l !== null ? (l.return = o, Ge = l) : GS(r); for (; s !== null;)Ge = s, tP(s), s = s.sibling; Ge = r, Xh = a, qn = f } US(n) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, Ge = s) : US(n) } } function US(n) { for (; Ge !== null;) { var e = Ge; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: qn || cg(5, e); break; case 1: var i = e.stateNode; if (e.flags & 4 && !qn) if (t === null) i.componentDidMount(); else { var r = e.elementType === e.type ? t.memoizedProps : Cr(e.type, t.memoizedProps); i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && MS(e, s, i); break; case 3: var o = e.updateQueue; if (o !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5: t = e.child.stateNode; break; case 1: t = e.child.stateNode }MS(e, o, t) } break; case 5: var a = e.stateNode; if (t === null && e.flags & 4) { t = a; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && t.focus(); break; case "img": l.src && (t.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var f = e.alternate; if (f !== null) { var d = f.memoizedState; if (d !== null) { var h = d.dehydrated; h !== null && Tf(h) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(Se(163)) }qn || e.flags & 512 && hx(e) } catch (p) { cn(e, e.return, p) } } if (e === n) { Ge = null; break } if (t = e.sibling, t !== null) { t.return = e.return, Ge = t; break } Ge = e.return } } function zS(n) { for (; Ge !== null;) { var e = Ge; if (e === n) { Ge = null; break } var t = e.sibling; if (t !== null) { t.return = e.return, Ge = t; break } Ge = e.return } } function GS(n) { for (; Ge !== null;) { var e = Ge; try { switch (e.tag) { case 0: case 11: case 15: var t = e.return; try { cg(4, e) } catch (l) { cn(e, t, l) } break; case 1: var i = e.stateNode; if (typeof i.componentDidMount == "function") { var r = e.return; try { i.componentDidMount() } catch (l) { cn(e, r, l) } } var s = e.return; try { hx(e) } catch (l) { cn(e, s, l) } break; case 5: var o = e.return; try { hx(e) } catch (l) { cn(e, o, l) } } } catch (l) { cn(e, e.return, l) } if (e === n) { Ge = null; break } var a = e.sibling; if (a !== null) { a.return = e.return, Ge = a; break } Ge = e.return } } var mF = Math.ceil, Dm = js.ReactCurrentDispatcher, _A = js.ReactCurrentOwner, fr = js.ReactCurrentBatchConfig, Bt = 0, On = null, _n = null, Gn = 0, Ii = 0, ru = jo(0), En = 0, kf = null, Za = 0, fg = 0, MA = 0, uf = null, xi = null, wA = 0, Tu = 1 / 0, Ss = null, Im = !1, gx = null, Bo = null, Yh = !1, _o = null, Fm = 0, cf = 0, yx = null, $p = -1, em = 0; function ui() { return Bt & 6 ? mn() : $p !== -1 ? $p : $p = mn() } function Ro(n) { return n.mode & 1 ? Bt & 2 && Gn !== 0 ? Gn & -Gn : qI.transition !== null ? (em === 0 && (em = kb()), em) : (n = Ot, n !== 0 || (n = window.event, n = n === void 0 ? 16 : jb(n.type)), n) : 1 } function Lr(n, e, t, i) { if (50 < cf) throw cf = 0, yx = null, Error(Se(185)); ad(n, t, i), (!(Bt & 2) || n !== On) && (n === On && (!(Bt & 2) && (fg |= t), En === 4 && xo(n, Gn)), Ci(n, i), t === 1 && Bt === 0 && !(e.mode & 1) && (Tu = mn() + 500, ag && Jo())) } function Ci(n, e) { var t = n.callbackNode; qD(n, e); var i = vm(n, n === On ? Gn : 0); if (i === 0) t !== null && Qw(t), n.callbackNode = null, n.callbackPriority = 0; else if (e = i & -i, n.callbackPriority !== e) { if (t != null && Qw(t), e === 1) n.tag === 0 ? ZI(HS.bind(null, n)) : c2(HS.bind(null, n)), XI(function () { !(Bt & 6) && Jo() }), t = null; else { switch (Ub(i)) { case 1: t = K1; break; case 4: t = Nb; break; case 16: t = ym; break; case 536870912: t = Ob; break; default: t = ym }t = uP(t, nP.bind(null, n)) } n.callbackPriority = e, n.callbackNode = t } } function nP(n, e) { if ($p = -1, em = 0, Bt & 6) throw Error(Se(327)); var t = n.callbackNode; if (yu() && n.callbackNode !== t) return null; var i = vm(n, n === On ? Gn : 0); if (i === 0) return null; if (i & 30 || i & n.expiredLanes || e) e = Nm(n, i); else { e = i; var r = Bt; Bt |= 2; var s = rP(); (On !== n || Gn !== e) && (Ss = null, Tu = mn() + 500, Ua(n, e)); do try { vF(); break } catch (a) { iP(n, a) } while (1); lA(), Dm.current = s, Bt = r, _n !== null ? e = 0 : (On = null, Gn = 0, e = En) } if (e !== 0) { if (e === 2 && (r = Wv(n), r !== 0 && (i = r, e = vx(n, r))), e === 1) throw t = kf, Ua(n, 0), xo(n, i), Ci(n, mn()), t; if (e === 6) xo(n, i); else { if (r = n.current.alternate, !(i & 30) && !gF(r) && (e = Nm(n, i), e === 2 && (s = Wv(n), s !== 0 && (i = s, e = vx(n, s))), e === 1)) throw t = kf, Ua(n, 0), xo(n, i), Ci(n, mn()), t; switch (n.finishedWork = r, n.finishedLanes = i, e) { case 0: case 1: throw Error(Se(345)); case 2: Aa(n, xi, Ss); break; case 3: if (xo(n, i), (i & 130023424) === i && (e = wA + 500 - mn(), 10 < e)) { if (vm(n, 0) !== 0) break; if (r = n.suspendedLanes, (r & i) !== i) { ui(), n.pingedLanes |= n.suspendedLanes & r; break } n.timeoutHandle = qv(Aa.bind(null, n, xi, Ss), e); break } Aa(n, xi, Ss); break; case 4: if (xo(n, i), (i & 4194240) === i) break; for (e = n.eventTimes, r = -1; 0 < i;) { var o = 31 - Rr(i); s = 1 << o, o = e[o], o > r && (r = o), i &= ~s } if (i = r, i = mn() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * mF(i / 1960)) - i, 10 < i) { n.timeoutHandle = qv(Aa.bind(null, n, xi, Ss), i); break } Aa(n, xi, Ss); break; case 5: Aa(n, xi, Ss); break; default: throw Error(Se(329)) } } } return Ci(n, mn()), n.callbackNode === t ? nP.bind(null, n) : null } function vx(n, e) { var t = uf; return n.current.memoizedState.isDehydrated && (Ua(n, e).flags |= 256), n = Nm(n, e), n !== 2 && (e = xi, xi = t, e !== null && xx(e)), n } function xx(n) { xi === null ? xi = n : xi.push.apply(xi, n) } function gF(n) { for (var e = n; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (var i = 0; i < t.length; i++) { var r = t[i], s = r.getSnapshot; r = r.value; try { if (!Fr(s(), r)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t; else { if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function xo(n, e) { for (e &= ~MA, e &= ~fg, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e;) { var t = 31 - Rr(e), i = 1 << t; n[t] = -1, e &= ~i } } function HS(n) { if (Bt & 6) throw Error(Se(327)); yu(); var e = vm(n, 0); if (!(e & 1)) return Ci(n, mn()), null; var t = Nm(n, e); if (n.tag !== 0 && t === 2) { var i = Wv(n); i !== 0 && (e = i, t = vx(n, i)) } if (t === 1) throw t = kf, Ua(n, 0), xo(n, e), Ci(n, mn()), t; if (t === 6) throw Error(Se(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = e, Aa(n, xi, Ss), Ci(n, mn()), null } function SA(n, e) { var t = Bt; Bt |= 1; try { return n(e) } finally { Bt = t, Bt === 0 && (Tu = mn() + 500, ag && Jo()) } } function qa(n) { _o !== null && _o.tag === 0 && !(Bt & 6) && yu(); var e = Bt; Bt |= 1; var t = fr.transition, i = Ot; try { if (fr.transition = null, Ot = 1, n) return n() } finally { Ot = i, fr.transition = t, Bt = e, !(Bt & 6) && Jo() } } function CA() { Ii = ru.current, jt(ru) } function Ua(n, e) { n.finishedWork = null, n.finishedLanes = 0; var t = n.timeoutHandle; if (t !== -1 && (n.timeoutHandle = -1, JI(t)), _n !== null) for (t = _n.return; t !== null;) { var i = t; switch (sA(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && wm(); break; case 3: Cu(), jt(wi), jt($n), pA(); break; case 5: hA(i); break; case 4: Cu(); break; case 13: jt($t); break; case 19: jt($t); break; case 10: uA(i.type._context); break; case 22: case 23: CA() }t = t.return } if (On = n, _n = n = Lo(n.current, null), Gn = Ii = e, En = 0, kf = null, MA = fg = Za = 0, xi = uf = null, Ba !== null) { for (e = 0; e < Ba.length; e++)if (t = Ba[e], i = t.interleaved, i !== null) { t.interleaved = null; var r = i.next, s = t.pending; if (s !== null) { var o = s.next; s.next = r, i.next = o } t.pending = i } Ba = null } return n } function iP(n, e) { do { var t = _n; try { if (lA(), Qp.current = Lm, Rm) { for (var i = rn.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } Rm = !1 } if (Qa = 0, Nn = Cn = rn = null, af = !1, Ff = 0, _A.current = null, t === null || t.return === null) { En = 1, kf = e, _n = null; break } e: { var s = n, o = t.return, a = t, l = e; if (e = Gn, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var f = l, d = a, h = d.tag; if (!(d.mode & 1) && (h === 0 || h === 11 || h === 15)) { var p = d.alternate; p ? (d.updateQueue = p.updateQueue, d.memoizedState = p.memoizedState, d.lanes = p.lanes) : (d.updateQueue = null, d.memoizedState = null) } var m = PS(o); if (m !== null) { m.flags &= -257, BS(m, o, a, s, e), m.mode & 1 && bS(s, f, e), e = m, l = f; var v = e.updateQueue; if (v === null) { var y = new Set; y.add(l), e.updateQueue = y } else v.add(l); break e } else { if (!(e & 1)) { bS(s, f, e), EA(); break e } l = Error(Se(426)) } } else if (Kt && a.mode & 1) { var x = PS(o); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), BS(x, o, a, s, e), oA(Eu(l, a)); break e } } s = l = Eu(l, a), En !== 4 && (En = 2), uf === null ? uf = [s] : uf.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var A = z2(s, l, e); _S(s, A); break e; case 1: a = l; var _ = s.type, w = s.stateNode; if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (Bo === null || !Bo.has(w)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = G2(s, a, e); _S(s, S); break e } }s = s.return } while (s !== null) } oP(t) } catch (T) { e = T, _n === t && t !== null && (_n = t = t.return); continue } break } while (1) } function rP() { var n = Dm.current; return Dm.current = Lm, n === null ? Lm : n } function EA() { (En === 0 || En === 3 || En === 2) && (En = 4), On === null || !(Za & 268435455) && !(fg & 268435455) || xo(On, Gn) } function Nm(n, e) { var t = Bt; Bt |= 2; var i = rP(); (On !== n || Gn !== e) && (Ss = null, Ua(n, e)); do try { yF(); break } catch (r) { iP(n, r) } while (1); if (lA(), Bt = t, Dm.current = i, _n !== null) throw Error(Se(261)); return On = null, Gn = 0, En } function yF() { for (; _n !== null;)sP(_n) } function vF() { for (; _n !== null && !VD();)sP(_n) } function sP(n) { var e = lP(n.alternate, n, Ii); n.memoizedProps = n.pendingProps, e === null ? oP(n) : _n = e, _A.current = null } function oP(n) { var e = n; do { var t = e.alternate; if (n = e.return, e.flags & 32768) { if (t = fF(t, e), t !== null) { t.flags &= 32767, _n = t; return } if (n !== null) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { En = 6, _n = null; return } } else if (t = cF(t, e, Ii), t !== null) { _n = t; return } if (e = e.sibling, e !== null) { _n = e; return } _n = e = n } while (e !== null); En === 0 && (En = 5) } function Aa(n, e, t) { var i = Ot, r = fr.transition; try { fr.transition = null, Ot = 1, xF(n, e, t, i) } finally { fr.transition = r, Ot = i } return null } function xF(n, e, t, i) { do yu(); while (_o !== null); if (Bt & 6) throw Error(Se(327)); t = n.finishedWork; var r = n.finishedLanes; if (t === null) return null; if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(Se(177)); n.callbackNode = null, n.callbackPriority = 0; var s = t.lanes | t.childLanes; if ($D(n, s), n === On && (_n = On = null, Gn = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || Yh || (Yh = !0, uP(ym, function () { return yu(), null })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) { s = fr.transition, fr.transition = null; var o = Ot; Ot = 1; var a = Bt; Bt |= 4, _A.current = null, hF(n, t), eP(t, n), UI(Qv), xm = !!Kv, Qv = Kv = null, n.current = t, pF(t), WD(), Bt = a, Ot = o, fr.transition = s } else n.current = t; if (Yh && (Yh = !1, _o = n, Fm = r), s = n.pendingLanes, s === 0 && (Bo = null), XD(t.stateNode), Ci(n, mn()), e !== null) for (i = n.onRecoverableError, t = 0; t < e.length; t++)r = e[t], i(r.value, { componentStack: r.stack, digest: r.digest }); if (Im) throw Im = !1, n = gx, gx = null, n; return Fm & 1 && n.tag !== 0 && yu(), s = n.pendingLanes, s & 1 ? n === yx ? cf++ : (cf = 0, yx = n) : cf = 0, Jo(), null } function yu() { if (_o !== null) { var n = Ub(Fm), e = fr.transition, t = Ot; try { if (fr.transition = null, Ot = 16 > n ? 16 : n, _o === null) var i = !1; else { if (n = _o, _o = null, Fm = 0, Bt & 6) throw Error(Se(331)); var r = Bt; for (Bt |= 4, Ge = n.current; Ge !== null;) { var s = Ge, o = s.child; if (Ge.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var f = a[l]; for (Ge = f; Ge !== null;) { var d = Ge; switch (d.tag) { case 0: case 11: case 15: lf(8, d, s) }var h = d.child; if (h !== null) h.return = d, Ge = h; else for (; Ge !== null;) { d = Ge; var p = d.sibling, m = d.return; if (Z2(d), d === f) { Ge = null; break } if (p !== null) { p.return = m, Ge = p; break } Ge = m } } } var v = s.alternate; if (v !== null) { var y = v.child; if (y !== null) { v.child = null; do { var x = y.sibling; y.sibling = null, y = x } while (y !== null) } } Ge = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, Ge = o; else e: for (; Ge !== null;) { if (s = Ge, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: lf(9, s, s.return) }var A = s.sibling; if (A !== null) { A.return = s.return, Ge = A; break e } Ge = s.return } } var _ = n.current; for (Ge = _; Ge !== null;) { o = Ge; var w = o.child; if (o.subtreeFlags & 2064 && w !== null) w.return = o, Ge = w; else e: for (o = _; Ge !== null;) { if (a = Ge, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: cg(9, a) } } catch (T) { cn(a, a.return, T) } if (a === o) { Ge = null; break e } var S = a.sibling; if (S !== null) { S.return = a.return, Ge = S; break e } Ge = a.return } } if (Bt = r, Jo(), qr && typeof qr.onPostCommitFiberRoot == "function") try { qr.onPostCommitFiberRoot(ng, n) } catch { } i = !0 } return i } finally { Ot = t, fr.transition = e } } return !1 } function VS(n, e, t) { e = Eu(t, e), e = z2(n, e, 1), n = Po(n, e, 1), e = ui(), n !== null && (ad(n, 1, e), Ci(n, e)) } function cn(n, e, t) { if (n.tag === 3) VS(n, n, t); else for (; e !== null;) { if (e.tag === 3) { VS(e, n, t); break } else if (e.tag === 1) { var i = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Bo === null || !Bo.has(i))) { n = Eu(t, n), n = G2(e, n, 1), e = Po(e, n, 1), n = ui(), e !== null && (ad(e, 1, n), Ci(e, n)); break } } e = e.return } } function AF(n, e, t) { var i = n.pingCache; i !== null && i.delete(e), e = ui(), n.pingedLanes |= n.suspendedLanes & t, On === n && (Gn & t) === t && (En === 4 || En === 3 && (Gn & 130023424) === Gn && 500 > mn() - wA ? Ua(n, 0) : MA |= t), Ci(n, e) } function aP(n, e) { e === 0 && (n.mode & 1 ? (e = kh, kh <<= 1, !(kh & 130023424) && (kh = 4194304)) : e = 1); var t = ui(); n = zs(n, e), n !== null && (ad(n, e, t), Ci(n, t)) } function _F(n) { var e = n.memoizedState, t = 0; e !== null && (t = e.retryLane), aP(n, t) } function MF(n, e) { var t = 0; switch (n.tag) { case 13: var i = n.stateNode, r = n.memoizedState; r !== null && (t = r.retryLane); break; case 19: i = n.stateNode; break; default: throw Error(Se(314)) }i !== null && i.delete(e), aP(n, t) } var lP; lP = function (n, e, t) { if (n !== null) if (n.memoizedProps !== e.pendingProps || wi.current) _i = !0; else { if (!(n.lanes & t) && !(e.flags & 128)) return _i = !1, uF(n, e, t); _i = !!(n.flags & 131072) } else _i = !1, Kt && e.flags & 1048576 && f2(e, Em, e.index); switch (e.lanes = 0, e.tag) { case 2: var i = e.type; qp(n, e), n = e.pendingProps; var r = Mu(e, $n.current); gu(e, t), r = gA(null, e, i, n, r, t); var s = yA(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Si(i) ? (s = !0, Sm(e)) : s = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, fA(e), r.updater = lg, e.stateNode = r, r._reactInternals = e, sx(e, i, n, t), e = lx(null, e, i, !0, s, t)) : (e.tag = 0, Kt && s && rA(e), ai(null, e, r, t), e = e.child), e; case 16: i = e.elementType; e: { switch (qp(n, e), n = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = SF(i), n = Cr(i, n), r) { case 0: e = ax(null, e, i, n, t); break e; case 1: e = DS(null, e, i, n, t); break e; case 11: e = RS(null, e, i, n, t); break e; case 14: e = LS(null, e, i, Cr(i.type, n), t); break e }throw Error(Se(306, i, "")) } return e; case 0: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Cr(i, r), ax(n, e, i, r, t); case 1: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Cr(i, r), DS(n, e, i, r, t); case 3: e: { if (j2(e), n === null) throw Error(Se(387)); i = e.pendingProps, s = e.memoizedState, r = s.element, m2(n, e), Pm(e, i, null, t); var o = e.memoizedState; if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { r = Eu(Error(Se(423)), e), e = IS(n, e, i, t, r); break e } else if (i !== r) { r = Eu(Error(Se(424)), e), e = IS(n, e, i, t, r); break e } else for (Ni = bo(e.stateNode.containerInfo.firstChild), ki = e, Kt = !0, br = null, t = x2(e, null, i, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (wu(), i === r) { e = Gs(n, e, t); break e } ai(n, e, i, t) } e = e.child } return e; case 5: return A2(e), n === null && nx(e), i = e.type, r = e.pendingProps, s = n !== null ? n.memoizedProps : null, o = r.children, Zv(i, r) ? o = null : s !== null && Zv(i, s) && (e.flags |= 32), W2(n, e), ai(n, e, o, t), e.child; case 6: return n === null && nx(e), null; case 13: return J2(n, e, t); case 4: return dA(e, e.stateNode.containerInfo), i = e.pendingProps, n === null ? e.child = Su(e, null, i, t) : ai(n, e, i, t), e.child; case 11: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Cr(i, r), RS(n, e, i, r, t); case 7: return ai(n, e, e.pendingProps, t), e.child; case 8: return ai(n, e, e.pendingProps.children, t), e.child; case 12: return ai(n, e, e.pendingProps.children, t), e.child; case 10: e: { if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, Ht(Tm, i._currentValue), i._currentValue = o, s !== null) if (Fr(s.value, o)) { if (s.children === r.children && !wi.current) { e = Gs(n, e, t); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === i) { if (s.tag === 1) { l = Is(-1, t & -t), l.tag = 2; var f = s.updateQueue; if (f !== null) { f = f.shared; var d = f.pending; d === null ? l.next = l : (l.next = d.next, d.next = l), f.pending = l } } s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), ix(s.return, t, e), a.lanes |= t; break } l = l.next } } else if (s.tag === 10) o = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(Se(341)); o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), ix(o, t, e), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === e) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } ai(n, e, r.children, t), e = e.child } return e; case 9: return r = e.type, i = e.pendingProps.children, gu(e, t), r = hr(r), i = i(r), e.flags |= 1, ai(n, e, i, t), e.child; case 14: return i = e.type, r = Cr(i, e.pendingProps), r = Cr(i.type, r), LS(n, e, i, r, t); case 15: return H2(n, e, e.type, e.pendingProps, t); case 17: return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Cr(i, r), qp(n, e), e.tag = 1, Si(i) ? (n = !0, Sm(e)) : n = !1, gu(e, t), y2(e, i, r), sx(e, i, r, t), lx(null, e, i, !0, n, t); case 19: return X2(n, e, t); case 22: return V2(n, e, t) }throw Error(Se(156, e.tag)) }; function uP(n, e) { return Fb(n, e) } function wF(n, e, t, i) { this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function cr(n, e, t, i) { return new wF(n, e, t, i) } function TA(n) { return n = n.prototype, !(!n || !n.isReactComponent) } function SF(n) { if (typeof n == "function") return TA(n) ? 1 : 0; if (n != null) { if (n = n.$$typeof, n === J1) return 11; if (n === X1) return 14 } return 2 } function Lo(n, e) { var t = n.alternate; return t === null ? (t = cr(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t } function tm(n, e, t, i, r, s) { var o = 2; if (i = n, typeof n == "function") TA(n) && (o = 1); else if (typeof n == "string") o = 5; else e: switch (n) { case Yl: return za(t.children, r, s, e); case j1: o = 8, r |= 8; break; case Pv: return n = cr(12, t, e, r | 2), n.elementType = Pv, n.lanes = s, n; case Bv: return n = cr(13, t, e, r), n.elementType = Bv, n.lanes = s, n; case Rv: return n = cr(19, t, e, r), n.elementType = Rv, n.lanes = s, n; case vb: return dg(t, r, s, e); default: if (typeof n == "object" && n !== null) switch (n.$$typeof) { case gb: o = 10; break e; case yb: o = 9; break e; case J1: o = 11; break e; case X1: o = 14; break e; case po: o = 16, i = null; break e }throw Error(Se(130, n == null ? n : typeof n, "")) }return e = cr(o, t, e, r), e.elementType = n, e.type = i, e.lanes = s, e } function za(n, e, t, i) { return n = cr(7, n, i, e), n.lanes = t, n } function dg(n, e, t, i) { return n = cr(22, n, i, e), n.elementType = vb, n.lanes = t, n.stateNode = { isHidden: !1 }, n } function xy(n, e, t) { return n = cr(6, n, null, e), n.lanes = t, n } function Ay(n, e, t) { return e = cr(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e } function CF(n, e, t, i, r) { this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ey(0), this.expirationTimes = ey(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ey(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function bA(n, e, t, i, r, s, o, a, l) { return n = new CF(n, e, t, a, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = cr(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, fA(s), n } function EF(n, e, t) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Xl, key: i == null ? null : "" + i, children: n, containerInfo: e, implementation: t } } function cP(n) { if (!n) return No; n = n._reactInternals; e: { if (rl(n) !== n || n.tag !== 1) throw Error(Se(170)); var e = n; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (Si(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(Se(171)) } if (n.tag === 1) { var t = n.type; if (Si(t)) return u2(n, t, e) } return e } function fP(n, e, t, i, r, s, o, a, l) { return n = bA(t, i, !0, n, r, s, o, a, l), n.context = cP(null), t = n.current, i = ui(), r = Ro(t), s = Is(i, r), s.callback = e ?? null, Po(t, s, r), n.current.lanes = r, ad(n, r, i), Ci(n, i), n } function hg(n, e, t, i) { var r = e.current, s = ui(), o = Ro(r); return t = cP(t), e.context === null ? e.context = t : e.pendingContext = t, e = Is(s, o), e.payload = { element: n }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n = Po(r, e, o), n !== null && (Lr(n, r, o, s), Kp(n, r, o)), o } function Om(n) { if (n = n.current, !n.child) return null; switch (n.child.tag) { case 5: return n.child.stateNode; default: return n.child.stateNode } } function WS(n, e) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { var t = n.retryLane; n.retryLane = t !== 0 && t < e ? t : e } } function PA(n, e) { WS(n, e), (n = n.alternate) && WS(n, e) } function TF() { return null } var dP = typeof reportError == "function" ? reportError : function (n) { console.error(n) }; function BA(n) { this._internalRoot = n } pg.prototype.render = BA.prototype.render = function (n) { var e = this._internalRoot; if (e === null) throw Error(Se(409)); hg(n, e, null, null) }; pg.prototype.unmount = BA.prototype.unmount = function () { var n = this._internalRoot; if (n !== null) { this._internalRoot = null; var e = n.containerInfo; qa(function () { hg(null, n, null, null) }), e[Us] = null } }; function pg(n) { this._internalRoot = n } pg.prototype.unstable_scheduleHydration = function (n) { if (n) { var e = Hb(); n = { blockedOn: null, target: n, priority: e }; for (var t = 0; t < vo.length && e !== 0 && e < vo[t].priority; t++); vo.splice(t, 0, n), t === 0 && Wb(n) } }; function RA(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function mg(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable ")) } function jS() { } function bF(n, e, t, i, r) { if (r) { if (typeof i == "function") { var s = i; i = function () { var f = Om(o); s.call(f) } } var o = fP(e, i, n, 0, null, !1, !1, "", jS); return n._reactRootContainer = o, n[Us] = o.current, Bf(n.nodeType === 8 ? n.parentNode : n), qa(), o } for (; r = n.lastChild;)n.removeChild(r); if (typeof i == "function") { var a = i; i = function () { var f = Om(l); a.call(f) } } var l = bA(n, 0, !1, null, null, !1, !1, "", jS); return n._reactRootContainer = l, n[Us] = l.current, Bf(n.nodeType === 8 ? n.parentNode : n), qa(function () { hg(e, l, t, i) }), l } function gg(n, e, t, i, r) { var s = t._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = Om(o); a.call(l) } } hg(e, o, n, r) } else o = bF(t, e, n, r, i); return Om(o) } zb = function (n) { switch (n.tag) { case 3: var e = n.stateNode; if (e.current.memoizedState.isDehydrated) { var t = Zc(e.pendingLanes); t !== 0 && (Q1(e, t | 1), Ci(e, mn()), !(Bt & 6) && (Tu = mn() + 500, Jo())) } break; case 13: qa(function () { var i = zs(n, 1); if (i !== null) { var r = ui(); Lr(i, n, 1, r) } }), PA(n, 1) } }; Z1 = function (n) { if (n.tag === 13) { var e = zs(n, 134217728); if (e !== null) { var t = ui(); Lr(e, n, 134217728, t) } PA(n, 134217728) } }; Gb = function (n) { if (n.tag === 13) { var e = Ro(n), t = zs(n, e); if (t !== null) { var i = ui(); Lr(t, n, e, i) } PA(n, e) } }; Hb = function () { return Ot }; Vb = function (n, e) { var t = Ot; try { return Ot = n, e() } finally { Ot = t } }; Gv = function (n, e, t) { switch (e) { case "input": if (Iv(n, t), e = t.name, t.type === "radio" && e != null) { for (t = n; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) { var i = t[e]; if (i !== n && i.form === n.form) { var r = og(i); if (!r) throw Error(Se(90)); Ab(i), Iv(i, r) } } } break; case "textarea": Mb(n, t); break; case "select": e = t.value, e != null && du(n, !!t.multiple, e, !1) } }; Pb = SA; Bb = qa; var PF = { usingClientEntryPoint: !1, Events: [ud, ql, og, Tb, bb, SA] }, Ec = { findFiberByHostInstance: Pa, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, BF = { bundleType: Ec.bundleType, version: Ec.version, rendererPackageName: Ec.rendererPackageName, rendererConfig: Ec.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: js.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return n = Db(n), n === null ? null : n.stateNode }, findFiberByHostInstance: Ec.findFiberByHostInstance || TF, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Kh = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Kh.isDisabled && Kh.supportsFiber) try { ng = Kh.inject(BF), qr = Kh } catch { } } Vi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = PF; Vi.createPortal = function (n, e) { var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!RA(e)) throw Error(Se(200)); return EF(n, e, null, t) }; Vi.createRoot = function (n, e) { if (!RA(n)) throw Error(Se(299)); var t = !1, i = "", r = dP; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = bA(n, 1, !1, null, null, t, !1, i, r), n[Us] = e.current, Bf(n.nodeType === 8 ? n.parentNode : n), new BA(e) }; Vi.findDOMNode = function (n) { if (n == null) return null; if (n.nodeType === 1) return n; var e = n._reactInternals; if (e === void 0) throw typeof n.render == "function" ? Error(Se(188)) : (n = Object.keys(n).join(","), Error(Se(268, n))); return n = Db(e), n = n === null ? null : n.stateNode, n }; Vi.flushSync = function (n) { return qa(n) }; Vi.hydrate = function (n, e, t) { if (!mg(e)) throw Error(Se(200)); return gg(null, n, e, !0, t) }; Vi.hydrateRoot = function (n, e, t) { if (!RA(n)) throw Error(Se(405)); var i = t != null && t.hydratedSources || null, r = !1, s = "", o = dP; if (t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = fP(e, null, n, 1, t ?? null, r, !1, s, o), n[Us] = e.current, Bf(n), i) for (n = 0; n < i.length; n++)t = i[n], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r); return new pg(e) }; Vi.render = function (n, e, t) { if (!mg(e)) throw Error(Se(200)); return gg(null, n, e, !1, t) }; Vi.unmountComponentAtNode = function (n) { if (!mg(n)) throw Error(Se(40)); return n._reactRootContainer ? (qa(function () { gg(null, null, n, !1, function () { n._reactRootContainer = null, n[Us] = null }) }), !0) : !1 }; Vi.unstable_batchedUpdates = SA; Vi.unstable_renderSubtreeIntoContainer = function (n, e, t, i) { if (!mg(t)) throw Error(Se(200)); if (n == null || n._reactInternals === void 0) throw Error(Se(38)); return gg(n, e, t, !1, i) }; Vi.version = "18.2.0-next-9e3b772b8-20220608"; (function (n) { function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } e(), n.exports = Vi })(TD); var hP, JS = hm; hP = Ev.createRoot = JS.createRoot, Ev.hydrateRoot = JS.hydrateRoot;/**
 * @remix-run/router v1.3.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function km() { return km = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, km.apply(this, arguments) } var La; (function (n) { n.Pop = "POP", n.Push = "PUSH", n.Replace = "REPLACE" })(La || (La = {})); const XS = "popstate"; function RF(n) { n === void 0 && (n = {}); function e(i, r) { let { pathname: s, search: o, hash: a } = i.location; return Ax("", { pathname: s, search: o, hash: a }, r.state && r.state.usr || null, r.state && r.state.key || "default") } function t(i, r) { return typeof r == "string" ? r : mP(r) } return DF(e, t, null, n) } function pP(n, e) { if (n === !1 || n === null || typeof n > "u") throw new Error(e) } function LF() { return Math.random().toString(36).substr(2, 8) } function YS(n, e) { return { usr: n.state, key: n.key, idx: e } } function Ax(n, e, t, i) { return t === void 0 && (t = null), km({ pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" }, typeof e == "string" ? gP(e) : e, { state: t, key: e && e.key || i || LF() }) } function mP(n) { let { pathname: e = "/", search: t = "", hash: i = "" } = n; return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i), e } function gP(n) { let e = {}; if (n) { let t = n.indexOf("#"); t >= 0 && (e.hash = n.substr(t), n = n.substr(0, t)); let i = n.indexOf("?"); i >= 0 && (e.search = n.substr(i), n = n.substr(0, i)), n && (e.pathname = n) } return e } function DF(n, e, t, i) { i === void 0 && (i = {}); let { window: r = document.defaultView, v5Compat: s = !1 } = i, o = r.history, a = La.Pop, l = null, f = d(); f == null && (f = 0, o.replaceState(km({}, o.state, { idx: f }), "")); function d() { return (o.state || { idx: null }).idx } function h() { a = La.Pop; let x = d(), A = x == null ? null : x - f; f = x, l && l({ action: a, location: y.location, delta: A }) } function p(x, A) { a = La.Push; let _ = Ax(y.location, x, A); t && t(_, x), f = d() + 1; let w = YS(_, f), S = y.createHref(_); try { o.pushState(w, "", S) } catch { r.location.assign(S) } s && l && l({ action: a, location: y.location, delta: 1 }) } function m(x, A) { a = La.Replace; let _ = Ax(y.location, x, A); t && t(_, x), f = d(); let w = YS(_, f), S = y.createHref(_); o.replaceState(w, "", S), s && l && l({ action: a, location: y.location, delta: 0 }) } function v(x) { let A = r.location.origin !== "null" ? r.location.origin : r.location.href, _ = typeof x == "string" ? x : mP(x); return pP(A, "No window.location.(origin|href) available to create URL for href: " + _), new URL(_, A) } let y = { get action() { return a }, get location() { return n(r, o) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return r.addEventListener(XS, h), l = x, () => { r.removeEventListener(XS, h), l = null } }, createHref(x) { return e(r, x) }, createURL: v, encodeLocation(x) { let A = v(x); return { pathname: A.pathname, search: A.search, hash: A.hash } }, push: p, replace: m, go(x) { return o.go(x) } }; return y } var KS; (function (n) { n.data = "data", n.deferred = "deferred", n.redirect = "redirect", n.error = "error" })(KS || (KS = {})); function IF(n, e) { if (e === "/") return n; if (!n.toLowerCase().startsWith(e.toLowerCase())) return null; let t = e.endsWith("/") ? e.length - 1 : e.length, i = n.charAt(t); return i && i !== "/" ? null : n.slice(t) || "/" } const FF = ["post", "put", "patch", "delete"];[...FF];/**
 * React Router v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function NF(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } const OF = typeof Object.is == "function" ? Object.is : NF, { useState: kF, useEffect: UF, useLayoutEffect: zF, useDebugValue: GF } = Cv; function HF(n, e, t) { const i = e(), [{ inst: r }, s] = kF({ inst: { value: i, getSnapshot: e } }); return zF(() => { r.value = i, r.getSnapshot = e, _y(r) && s({ inst: r }) }, [n, i, e]), UF(() => (_y(r) && s({ inst: r }), n(() => { _y(r) && s({ inst: r }) })), [n]), GF(i), i } function _y(n) { const e = n.getSnapshot, t = n.value; try { const i = e(); return !OF(t, i) } catch { return !0 } } function VF(n, e, t) { return e() } const WF = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", jF = !WF, JF = jF ? VF : HF; "useSyncExternalStore" in Cv && (n => n.useSyncExternalStore)(Cv); const XF = z.createContext(null), yP = z.createContext(null); function YF() { return z.useContext(yP) != null } var QS; (function (n) { n.UseBlocker = "useBlocker", n.UseRevalidator = "useRevalidator" })(QS || (QS = {})); var ZS; (function (n) { n.UseLoaderData = "useLoaderData", n.UseActionData = "useActionData", n.UseRouteError = "useRouteError", n.UseNavigation = "useNavigation", n.UseRouteLoaderData = "useRouteLoaderData", n.UseMatches = "useMatches", n.UseRevalidator = "useRevalidator" })(ZS || (ZS = {})); function KF(n) { let { basename: e = "/", children: t = null, location: i, navigationType: r = La.Pop, navigator: s, static: o = !1 } = n; YF() && pP(!1); let a = e.replace(/^\/*/, "/"), l = z.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]); typeof i == "string" && (i = gP(i)); let { pathname: f = "/", search: d = "", hash: h = "", state: p = null, key: m = "default" } = i, v = z.useMemo(() => { let y = IF(f, a); return y == null ? null : { pathname: y, search: d, hash: h, state: p, key: m } }, [a, f, d, h, p, m]); return v == null ? null : z.createElement(XF.Provider, { value: l }, z.createElement(yP.Provider, { children: t, value: { location: v, navigationType: r } })) } var qS; (function (n) { n[n.pending = 0] = "pending", n[n.success = 1] = "success", n[n.error = 2] = "error" })(qS || (qS = {})); new Promise(() => { });/**
 * React Router DOM v6.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function QF(n) { let { basename: e, children: t, window: i } = n, r = z.useRef(); r.current == null && (r.current = RF({ window: i, v5Compat: !0 })); let s = r.current, [o, a] = z.useState({ action: s.action, location: s.location }); return z.useLayoutEffect(() => s.listen(a), [s]), z.createElement(KF, { basename: e, children: t, location: o.location, navigationType: o.action, navigator: s }) } var $S; (function (n) { n.UseScrollRestoration = "useScrollRestoration", n.UseSubmitImpl = "useSubmitImpl", n.UseFetcher = "useFetcher" })($S || ($S = {})); var eC; (function (n) { n.UseFetchers = "useFetchers", n.UseScrollRestoration = "useScrollRestoration" })(eC || (eC = {}));/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const yg = "149", _a = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Ma = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, vP = 0, _x = 1, xP = 2, ZF = 3, AP = 0, vg = 1, ff = 2, Da = 3, is = 0, Ei = 1, Br = 2, qF = 2, Fs = 0, Ga = 1, Mx = 2, wx = 3, Sx = 4, _P = 5, Ta = 100, MP = 101, wP = 102, Cx = 103, Ex = 104, SP = 200, CP = 201, EP = 202, TP = 203, LA = 204, DA = 205, bP = 206, PP = 207, BP = 208, RP = 209, LP = 210, DP = 0, IP = 1, FP = 2, Um = 3, NP = 4, OP = 5, kP = 6, UP = 7, fd = 0, zP = 1, GP = 2, Dr = 0, HP = 1, VP = 2, WP = 3, IA = 4, jP = 5, xg = 300, Oo = 301, ko = 302, Uf = 303, zf = 304, Vu = 306, Uo = 1e3, zn = 1001, bu = 1002, fn = 1003, Gf = 1004, $F = 1004, vu = 1005, eN = 1005, en = 1006, Ag = 1007, tN = 1007, rs = 1008, nN = 1008, Hs = 1009, JP = 1010, XP = 1011, FA = 1012, YP = 1013, Mo = 1014, Bs = 1015, Pu = 1016, KP = 1017, QP = 1018, Ha = 1020, ZP = 1021, Ai = 1023, qP = 1024, $P = 1025, Do = 1026, $a = 1027, eB = 1028, tB = 1029, nB = 1030, iB = 1031, rB = 1033, nm = 33776, im = 33777, rm = 33778, sm = 33779, Tx = 35840, bx = 35841, Px = 35842, Bx = 35843, sB = 36196, Rx = 37492, Lx = 37496, Dx = 37808, Ix = 37809, Fx = 37810, Nx = 37811, Ox = 37812, kx = 37813, Ux = 37814, zx = 37815, Gx = 37816, Hx = 37817, Vx = 37818, Wx = 37819, jx = 37820, Jx = 37821, om = 36492, oB = 36283, Xx = 36284, Yx = 36285, Kx = 36286, aB = 2200, lB = 2201, uB = 2202, Bu = 2300, el = 2301, am = 2302, Ia = 2400, Fa = 2401, Hf = 2402, _g = 2500, NA = 2501, iN = 0, cB = 1, OA = 2, Vs = 3e3, Ct = 3001, fB = 3200, dB = 3201, Js = 0, hB = 1, rN = "", Tr = "srgb", Ru = "srgb-linear", sN = 0, lm = 7680, oN = 7681, aN = 7682, lN = 7683, uN = 34055, cN = 34056, fN = 5386, dN = 512, hN = 513, pN = 514, mN = 515, gN = 516, yN = 517, vN = 518, pB = 519, Vf = 35044, Va = 35048, xN = 35040, AN = 35045, _N = 35049, MN = 35041, wN = 35046, SN = 35050, CN = 35042, EN = "100", Qx = "300 es", zm = 1035; class os { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const i = this._listeners; i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const i = this._listeners; return i[e] !== void 0 && i[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const r = this._listeners[e]; if (r !== void 0) { const s = r.indexOf(t); s !== -1 && r.splice(s, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const i = this._listeners[e.type]; if (i !== void 0) { e.target = this; const r = i.slice(0); for (let s = 0, o = r.length; s < o; s++)r[s].call(this, e); e.target = null } } } const Qn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let tC = 1234567; const Wa = Math.PI / 180, Wf = 180 / Math.PI; function Ui() { const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0; return (Qn[n & 255] + Qn[n >> 8 & 255] + Qn[n >> 16 & 255] + Qn[n >> 24 & 255] + "-" + Qn[e & 255] + Qn[e >> 8 & 255] + "-" + Qn[e >> 16 & 15 | 64] + Qn[e >> 24 & 255] + "-" + Qn[t & 63 | 128] + Qn[t >> 8 & 255] + "-" + Qn[t >> 16 & 255] + Qn[t >> 24 & 255] + Qn[i & 255] + Qn[i >> 8 & 255] + Qn[i >> 16 & 255] + Qn[i >> 24 & 255]).toLowerCase() } function gn(n, e, t) { return Math.max(e, Math.min(t, n)) } function kA(n, e) { return (n % e + e) % e } function TN(n, e, t, i, r) { return i + (n - e) * (r - i) / (t - e) } function bN(n, e, t) { return n !== e ? (t - n) / (e - n) : 0 } function df(n, e, t) { return (1 - t) * n + t * e } function PN(n, e, t, i) { return df(n, e, 1 - Math.exp(-t * i)) } function BN(n, e = 1) { return e - Math.abs(kA(n, e * 2) - e) } function RN(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n)) } function LN(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10)) } function DN(n, e) { return n + Math.floor(Math.random() * (e - n + 1)) } function IN(n, e) { return n + Math.random() * (e - n) } function FN(n) { return n * (.5 - Math.random()) } function NN(n) { n !== void 0 && (tC = n); let e = tC += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function ON(n) { return n * Wa } function kN(n) { return n * Wf } function Zx(n) { return (n & n - 1) === 0 && n !== 0 } function mB(n) { return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2)) } function Gm(n) { return Math.pow(2, Math.floor(Math.log(n) / Math.LN2)) } function UN(n, e, t, i, r) { const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), f = s((e + i) / 2), d = o((e + i) / 2), h = s((e - i) / 2), p = o((e - i) / 2), m = s((i - e) / 2), v = o((i - e) / 2); switch (r) { case "XYX": n.set(a * d, l * h, l * p, a * f); break; case "YZY": n.set(l * p, a * d, l * h, a * f); break; case "ZXZ": n.set(l * h, l * p, a * d, a * f); break; case "XZX": n.set(a * d, l * v, l * m, a * f); break; case "YXY": n.set(l * m, a * d, l * v, a * f); break; case "ZYZ": n.set(l * v, l * m, a * d, a * f); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } function Rs(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint16Array: return n / 65535; case Uint8Array: return n / 255; case Int16Array: return Math.max(n / 32767, -1); case Int8Array: return Math.max(n / 127, -1); default: throw new Error("Invalid component type.") } } function zt(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint16Array: return Math.round(n * 65535); case Uint8Array: return Math.round(n * 255); case Int16Array: return Math.round(n * 32767); case Int8Array: return Math.round(n * 127); default: throw new Error("Invalid component type.") } } var UA = Object.freeze({ __proto__: null, DEG2RAD: Wa, RAD2DEG: Wf, ceilPowerOfTwo: mB, clamp: gn, damp: PN, degToRad: ON, denormalize: Rs, euclideanModulo: kA, floorPowerOfTwo: Gm, generateUUID: Ui, inverseLerp: bN, isPowerOfTwo: Zx, lerp: df, mapLinear: TN, normalize: zt, pingpong: BN, radToDeg: kN, randFloat: IN, randFloatSpread: FN, randInt: DN, seededRandom: NN, setQuaternionFromProperEuler: UN, smootherstep: LN, smoothstep: RN }); class pe { constructor(e = 0, t = 0) { pe.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, i = this.y, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y; return t * t + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y; return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class li { constructor() { li.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set(e, t, i, r, s, o, a, l, f) { const d = this.elements; return d[0] = e, d[1] = r, d[2] = a, d[3] = t, d[4] = s, d[5] = l, d[6] = i, d[7] = o, d[8] = f, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], l = i[6], f = i[1], d = i[4], h = i[7], p = i[2], m = i[5], v = i[8], y = r[0], x = r[3], A = r[6], _ = r[1], w = r[4], S = r[7], T = r[2], P = r[5], R = r[8]; return s[0] = o * y + a * _ + l * T, s[3] = o * x + a * w + l * P, s[6] = o * A + a * S + l * R, s[1] = f * y + d * _ + h * T, s[4] = f * x + d * w + h * P, s[7] = f * A + d * S + h * R, s[2] = p * y + m * _ + v * T, s[5] = p * x + m * w + v * P, s[8] = p * A + m * S + v * R, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], d = e[8]; return t * o * d - t * a * f - i * s * d + i * a * l + r * s * f - r * o * l } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], d = e[8], h = d * o - a * f, p = a * l - d * s, m = f * s - o * l, v = t * h + i * p + r * m; if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const y = 1 / v; return e[0] = h * y, e[1] = (r * f - d * i) * y, e[2] = (a * i - r * o) * y, e[3] = p * y, e[4] = (d * t - r * l) * y, e[5] = (r * s - a * t) * y, e[6] = m * y, e[7] = (i * l - f * t) * y, e[8] = (o * t - i * s) * y, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, r, s, o, a) { const l = Math.cos(s), f = Math.sin(s); return this.set(i * l, i * f, -i * (l * o + f * a) + o + e, -r * f, r * l, -r * (-f * o + l * a) + a + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(My.makeScale(e, t)), this } rotate(e) { return this.premultiply(My.makeRotation(-e)), this } translate(e, t) { return this.premultiply(My.makeTranslation(e, t)), this } makeTranslation(e, t) { return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, i = e.elements; for (let r = 0; r < 9; r++)if (t[r] !== i[r]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const My = new li; function gB(n) { for (let e = n.length - 1; e >= 0; --e)if (n[e] >= 65535) return !0; return !1 } const zN = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function su(n, e) { return new zN[n](e) } function jf(n) { return document.createElementNS("http://www.w3.org/1999/xhtml", n) } function ja(n) { return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4) } function um(n) { return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055 } const wy = { [Tr]: { [Ru]: ja }, [Ru]: { [Tr]: um } }, Zn = { legacyMode: !0, get workingColorSpace() { return Ru }, set workingColorSpace(n) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (n, e, t) { if (this.legacyMode || e === t || !e || !t) return n; if (wy[e] && wy[e][t] !== void 0) { const i = wy[e][t]; return n.r = i(n.r), n.g = i(n.g), n.b = i(n.b), n } throw new Error("Unsupported color space conversion.") }, fromWorkingColorSpace: function (n, e) { return this.convert(n, this.workingColorSpace, e) }, toWorkingColorSpace: function (n, e) { return this.convert(n, e, this.workingColorSpace) } }, yB = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Sn = { r: 0, g: 0, b: 0 }, Mr = { h: 0, s: 0, l: 0 }, Qh = { h: 0, s: 0, l: 0 }; function Sy(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n } function Zh(n, e) { return e.r = n.r, e.g = n.g, e.b = n.b, e } class Le { constructor(e, t, i) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i) } set(e) { return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = Tr) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Zn.toWorkingColorSpace(this, t), this } setRGB(e, t, i, r = Zn.workingColorSpace) { return this.r = e, this.g = t, this.b = i, Zn.toWorkingColorSpace(this, r), this } setHSL(e, t, i, r = Zn.workingColorSpace) { if (e = kA(e, 1), t = gn(t, 0, 1), i = gn(i, 0, 1), t === 0) this.r = this.g = this.b = i; else { const s = i <= .5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s; this.r = Sy(o, s, e + 1 / 3), this.g = Sy(o, s, e), this.b = Sy(o, s, e - 1 / 3) } return Zn.toWorkingColorSpace(this, r), this } setStyle(e, t = Tr) { function i(s) { s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let s; const o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, Zn.toWorkingColorSpace(this, t), i(s[4]), this; if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, Zn.toWorkingColorSpace(this, t), i(s[4]), this; break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const l = parseFloat(s[1]) / 360, f = parseFloat(s[2]) / 100, d = parseFloat(s[3]) / 100; return i(s[4]), this.setHSL(l, f, d, t) } break } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) { const s = r[1], o = s.length; if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, Zn.toWorkingColorSpace(this, t), this; if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, Zn.toWorkingColorSpace(this, t), this } return e && e.length > 0 ? this.setColorName(e, t) : this } setColorName(e, t = Tr) { const i = yB[e.toLowerCase()]; return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = ja(e.r), this.g = ja(e.g), this.b = ja(e.b), this } copyLinearToSRGB(e) { return this.r = um(e.r), this.g = um(e.g), this.b = um(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = Tr) { return Zn.fromWorkingColorSpace(Zh(this, Sn), e), gn(Sn.r * 255, 0, 255) << 16 ^ gn(Sn.g * 255, 0, 255) << 8 ^ gn(Sn.b * 255, 0, 255) << 0 } getHexString(e = Tr) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = Zn.workingColorSpace) { Zn.fromWorkingColorSpace(Zh(this, Sn), t); const i = Sn.r, r = Sn.g, s = Sn.b, o = Math.max(i, r, s), a = Math.min(i, r, s); let l, f; const d = (a + o) / 2; if (a === o) l = 0, f = 0; else { const h = o - a; switch (f = d <= .5 ? h / (o + a) : h / (2 - o - a), o) { case i: l = (r - s) / h + (r < s ? 6 : 0); break; case r: l = (s - i) / h + 2; break; case s: l = (i - r) / h + 4; break }l /= 6 } return e.h = l, e.s = f, e.l = d, e } getRGB(e, t = Zn.workingColorSpace) { return Zn.fromWorkingColorSpace(Zh(this, Sn), t), e.r = Sn.r, e.g = Sn.g, e.b = Sn.b, e } getStyle(e = Tr) { return Zn.fromWorkingColorSpace(Zh(this, Sn), e), e !== Tr ? `color(${e} ${Sn.r} ${Sn.g} ${Sn.b})` : `rgb(${Sn.r * 255 | 0},${Sn.g * 255 | 0},${Sn.b * 255 | 0})` } offsetHSL(e, t, i) { return this.getHSL(Mr), Mr.h += e, Mr.s += t, Mr.l += i, this.setHSL(Mr.h, Mr.s, Mr.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(Mr), e.getHSL(Qh); const i = df(Mr.h, Qh.h, t), r = df(Mr.s, Qh.s, t), s = df(Mr.l, Qh.l, t); return this.setHSL(i, r, s), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } Le.NAMES = yB; let El; class zA { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { El === void 0 && (El = jf("canvas")), El.width = e.width, El.height = e.height; const i = El.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = El } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = jf("canvas"); t.width = e.width, t.height = e.height; const i = t.getContext("2d"); i.drawImage(e, 0, 0, e.width, e.height); const r = i.getImageData(0, 0, e.width, e.height), s = r.data; for (let o = 0; o < s.length; o++)s[o] = ja(s[o] / 255) * 255; return i.putImageData(r, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let i = 0; i < t.length; i++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(ja(t[i] / 255) * 255) : t[i] = ja(t[i]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } class Na { constructor(e = null) { this.isSource = !0, this.uuid = Ui(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const i = { uuid: this.uuid, url: "" }, r = this.data; if (r !== null) { let s; if (Array.isArray(r)) { s = []; for (let o = 0, a = r.length; o < a; o++)r[o].isDataTexture ? s.push(Cy(r[o].image)) : s.push(Cy(r[o])) } else s = Cy(r); i.url = s } return t || (e.images[this.uuid] = i), i } } function Cy(n) { return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? zA.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let GN = 0; class Qt extends os { constructor(e = Qt.DEFAULT_IMAGE, t = Qt.DEFAULT_MAPPING, i = zn, r = zn, s = en, o = rs, a = Ai, l = Hs, f = Qt.DEFAULT_ANISOTROPY, d = Vs) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: GN++ }), this.uuid = Ui(), this.name = "", this.source = new Na(e), this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = f, this.format = a, this.internalFormat = null, this.type = l, this.offset = new pe(0, 0), this.repeat = new pe(1, 1), this.center = new pe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new li, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== xg) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Uo: e.x = e.x - Math.floor(e.x); break; case zn: e.x = e.x < 0 ? 0 : 1; break; case bu: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Uo: e.y = e.y - Math.floor(e.y); break; case zn: e.y = e.y < 0 ? 0 : 1; break; case bu: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } } Qt.DEFAULT_IMAGE = null; Qt.DEFAULT_MAPPING = xg; Qt.DEFAULT_ANISOTROPY = 1; class Nt { constructor(e = 0, t = 0, i = 0, r = 1) { Nt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, r) { return this.x = e, this.y = t, this.z = i, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements; return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, r, s; const l = e.elements, f = l[0], d = l[4], h = l[8], p = l[1], m = l[5], v = l[9], y = l[2], x = l[6], A = l[10]; if (Math.abs(d - p) < .01 && Math.abs(h - y) < .01 && Math.abs(v - x) < .01) { if (Math.abs(d + p) < .1 && Math.abs(h + y) < .1 && Math.abs(v + x) < .1 && Math.abs(f + m + A - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const w = (f + 1) / 2, S = (m + 1) / 2, T = (A + 1) / 2, P = (d + p) / 4, R = (h + y) / 4, E = (v + x) / 4; return w > S && w > T ? w < .01 ? (i = 0, r = .707106781, s = .707106781) : (i = Math.sqrt(w), r = P / i, s = R / i) : S > T ? S < .01 ? (i = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(S), i = P / r, s = E / r) : T < .01 ? (i = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(T), i = R / s, r = E / s), this.set(i, r, s, t), this } let _ = Math.sqrt((x - v) * (x - v) + (h - y) * (h - y) + (p - d) * (p - d)); return Math.abs(_) < .001 && (_ = 1), this.x = (x - v) / _, this.y = (h - y) / _, this.z = (p - d) / _, this.w = Math.acos((f + m + A - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class Nr extends os { constructor(e = 1, t = 1, i = {}) { super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Nt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Nt(0, 0, e, t); const r = { width: e, height: t, depth: 1 }; this.texture = new Qt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : !1, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : en, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0 } setSize(e, t, i = 1) { (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Na(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Mg extends Qt { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = fn, this.minFilter = fn, this.wrapR = zn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class HN extends Nr { constructor(e = 1, t = 1, i = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new Mg(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class GA extends Qt { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = fn, this.minFilter = fn, this.wrapR = zn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class VN extends Nr { constructor(e = 1, t = 1, i = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new GA(null, e, t, i), this.texture.isRenderTargetTexture = !0 } } class WN extends Nr { constructor(e = 1, t = 1, i = 1, r = {}) { super(e, t, r), this.isWebGLMultipleRenderTargets = !0; const s = this.texture; this.texture = []; for (let o = 0; o < i; o++)this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0 } setSize(e, t, i = 1) { if (this.width !== e || this.height !== t || this.depth !== i) { this.width = e, this.height = t, this.depth = i; for (let r = 0, s = this.texture.length; r < s; r++)this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, i = e.texture.length; t < i; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class Hn { constructor(e = 0, t = 0, i = 0, r = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = r } static slerpFlat(e, t, i, r, s, o, a) { let l = i[r + 0], f = i[r + 1], d = i[r + 2], h = i[r + 3]; const p = s[o + 0], m = s[o + 1], v = s[o + 2], y = s[o + 3]; if (a === 0) { e[t + 0] = l, e[t + 1] = f, e[t + 2] = d, e[t + 3] = h; return } if (a === 1) { e[t + 0] = p, e[t + 1] = m, e[t + 2] = v, e[t + 3] = y; return } if (h !== y || l !== p || f !== m || d !== v) { let x = 1 - a; const A = l * p + f * m + d * v + h * y, _ = A >= 0 ? 1 : -1, w = 1 - A * A; if (w > Number.EPSILON) { const T = Math.sqrt(w), P = Math.atan2(T, A * _); x = Math.sin(x * P) / T, a = Math.sin(a * P) / T } const S = a * _; if (l = l * x + p * S, f = f * x + m * S, d = d * x + v * S, h = h * x + y * S, x === 1 - a) { const T = 1 / Math.sqrt(l * l + f * f + d * d + h * h); l *= T, f *= T, d *= T, h *= T } } e[t] = l, e[t + 1] = f, e[t + 2] = d, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, i, r, s, o) { const a = i[r], l = i[r + 1], f = i[r + 2], d = i[r + 3], h = s[o], p = s[o + 1], m = s[o + 2], v = s[o + 3]; return e[t] = a * v + d * h + l * m - f * p, e[t + 1] = l * v + d * p + f * h - a * m, e[t + 2] = f * v + d * m + a * p - l * h, e[t + 3] = d * v - a * h - l * p - f * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, f = a(i / 2), d = a(r / 2), h = a(s / 2), p = l(i / 2), m = l(r / 2), v = l(s / 2); switch (o) { case "XYZ": this._x = p * d * h + f * m * v, this._y = f * m * h - p * d * v, this._z = f * d * v + p * m * h, this._w = f * d * h - p * m * v; break; case "YXZ": this._x = p * d * h + f * m * v, this._y = f * m * h - p * d * v, this._z = f * d * v - p * m * h, this._w = f * d * h + p * m * v; break; case "ZXY": this._x = p * d * h - f * m * v, this._y = f * m * h + p * d * v, this._z = f * d * v + p * m * h, this._w = f * d * h - p * m * v; break; case "ZYX": this._x = p * d * h - f * m * v, this._y = f * m * h + p * d * v, this._z = f * d * v - p * m * h, this._w = f * d * h + p * m * v; break; case "YZX": this._x = p * d * h + f * m * v, this._y = f * m * h + p * d * v, this._z = f * d * v - p * m * h, this._w = f * d * h - p * m * v; break; case "XZY": this._x = p * d * h - f * m * v, this._y = f * m * h - p * d * v, this._z = f * d * v + p * m * h, this._w = f * d * h + p * m * v; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const i = t / 2, r = Math.sin(i); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], f = t[2], d = t[6], h = t[10], p = i + a + h; if (p > 0) { const m = .5 / Math.sqrt(p + 1); this._w = .25 / m, this._x = (d - l) * m, this._y = (s - f) * m, this._z = (o - r) * m } else if (i > a && i > h) { const m = 2 * Math.sqrt(1 + i - a - h); this._w = (d - l) / m, this._x = .25 * m, this._y = (r + o) / m, this._z = (s + f) / m } else if (a > h) { const m = 2 * Math.sqrt(1 + a - i - h); this._w = (s - f) / m, this._x = (r + o) / m, this._y = .25 * m, this._z = (l + d) / m } else { const m = 2 * Math.sqrt(1 + h - i - a); this._w = (o - r) / m, this._x = (s + f) / m, this._y = (l + d) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(gn(this.dot(e), -1, 1))) } rotateTowards(e, t) { const i = this.angleTo(e); if (i === 0) return this; const r = Math.min(1, t / i); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, f = t._z, d = t._w; return this._x = i * d + o * a + r * f - s * l, this._y = r * d + o * l + s * a - i * f, this._z = s * d + o * f + i * l - r * a, this._w = o * d - i * a - r * l - s * f, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const i = this._x, r = this._y, s = this._z, o = this._w; let a = o * e._w + i * e._x + r * e._y + s * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this; const l = 1 - a * a; if (l <= Number.EPSILON) { const m = 1 - t; return this._w = m * o + t * this._w, this._x = m * i + t * this._x, this._y = m * r + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this } const f = Math.sqrt(l), d = Math.atan2(f, a), h = Math.sin((1 - t) * d) / f, p = Math.sin(t * d) / f; return this._w = o * h + this._w * p, this._x = i * h + this._x * p, this._y = r * h + this._y * p, this._z = s * h + this._z * p, this._onChangeCallback(), this } slerpQuaternions(e, t, i) { return this.copy(e).slerp(t, i) } random() { const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class I { constructor(e = 0, t = 0, i = 0) { I.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i } set(e, t, i) { return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(nC.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(nC.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, i = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]); return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this } applyQuaternion(e) { const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, f = l * t + o * r - a * i, d = l * i + a * t - s * r, h = l * r + s * i - o * t, p = -s * t - o * i - a * r; return this.x = f * l + p * -s + d * -a - h * -o, this.y = d * l + p * -o + h * -s - f * -a, this.z = h * l + p * -a + f * -o - d * -s, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, i = this.y, r = this.z, s = e.elements; return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z; return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const i = e.dot(this) / t; return this.copy(e).multiplyScalar(i) } projectOnPlane(e) { return Ey.copy(this).projectOnVector(e), this.sub(Ey) } reflect(e) { return this.sub(Ey.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const i = this.dot(e) / t; return Math.acos(gn(i, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z; return t * t + i * i + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { const r = Math.sin(t) * e; return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2); return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const Ey = new I, nC = new Hn; class Xo { constructor(e = new I(1 / 0, 1 / 0, 1 / 0), t = new I(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, f = e.length; l < f; l += 3) { const d = e[l], h = e[l + 1], p = e[l + 2]; d < t && (t = d), h < i && (i = h), p < r && (r = p), d > s && (s = d), h > o && (o = h), p > a && (a = p) } return this.min.set(t, i, r), this.max.set(s, o, a), this } setFromBufferAttribute(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, f = e.count; l < f; l++) { const d = e.getX(l), h = e.getY(l), p = e.getZ(l); d < t && (t = d), h < i && (i = h), p < r && (r = p), d > s && (s = d), h > o && (o = h), p > a && (a = p) } return this.min.set(t, i, r), this.max.set(s, o, a), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = ua.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const i = e.geometry; if (i !== void 0) if (t && i.attributes != null && i.attributes.position !== void 0) { const s = i.attributes.position; for (let o = 0, a = s.count; o < a; o++)ua.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld), this.expandByPoint(ua) } else i.boundingBox === null && i.computeBoundingBox(), Ty.copy(i.boundingBox), Ty.applyMatrix4(e.matrixWorld), this.union(Ty); const r = e.children; for (let s = 0, o = r.length; s < o; s++)this.expandByObject(r[s], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, ua), ua.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Tc), qh.subVectors(this.max, Tc), Tl.subVectors(e.a, Tc), bl.subVectors(e.b, Tc), Pl.subVectors(e.c, Tc), ro.subVectors(bl, Tl), so.subVectors(Pl, bl), ca.subVectors(Tl, Pl); let t = [0, -ro.z, ro.y, 0, -so.z, so.y, 0, -ca.z, ca.y, ro.z, 0, -ro.x, so.z, 0, -so.x, ca.z, 0, -ca.x, -ro.y, ro.x, 0, -so.y, so.x, 0, -ca.y, ca.x, 0]; return !by(t, Tl, bl, Pl, qh) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !by(t, Tl, bl, Pl, qh)) ? !1 : ($h.crossVectors(ro, so), t = [$h.x, $h.y, $h.z], by(t, Tl, bl, Pl, qh)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return ua.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = this.getSize(ua).length() * .5, e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (ys[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), ys[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), ys[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), ys[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), ys[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), ys[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), ys[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), ys[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(ys), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const ys = [new I, new I, new I, new I, new I, new I, new I, new I], ua = new I, Ty = new Xo, Tl = new I, bl = new I, Pl = new I, ro = new I, so = new I, ca = new I, Tc = new I, qh = new I, $h = new I, fa = new I; function by(n, e, t, i, r) { for (let s = 0, o = n.length - 3; s <= o; s += 3) { fa.fromArray(n, s); const a = r.x * Math.abs(fa.x) + r.y * Math.abs(fa.y) + r.z * Math.abs(fa.z), l = e.dot(fa), f = t.dot(fa), d = i.dot(fa); if (Math.max(-Math.max(l, f, d), Math.min(l, f, d)) > a) return !1 } return !0 } const jN = new Xo, bc = new I, Py = new I; class Yo { constructor(e = new I, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const i = this.center; t !== void 0 ? i.copy(t) : jN.setFromPoints(e).getCenter(i); let r = 0; for (let s = 0, o = e.length; s < o; s++)r = Math.max(r, i.distanceToSquared(e[s])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const i = this.center.distanceToSquared(e); return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; bc.subVectors(e, this.center); const t = bc.lengthSq(); if (t > this.radius * this.radius) { const i = Math.sqrt(t), r = (i - this.radius) * .5; this.center.addScaledVector(bc, r / i), this.radius += r } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Py.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(bc.copy(e.center).add(Py)), this.expandByPoint(bc.copy(e.center).sub(Py))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const vs = new I, By = new I, ep = new I, oo = new I, Ry = new I, tp = new I, Ly = new I; class dd { constructor(e = new I, t = new I(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, vs)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = vs.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (vs.copy(this.direction).multiplyScalar(t).add(this.origin), vs.distanceToSquared(e)) } distanceSqToSegment(e, t, i, r) { By.copy(e).add(t).multiplyScalar(.5), ep.copy(t).sub(e).normalize(), oo.copy(this.origin).sub(By); const s = e.distanceTo(t) * .5, o = -this.direction.dot(ep), a = oo.dot(this.direction), l = -oo.dot(ep), f = oo.lengthSq(), d = Math.abs(1 - o * o); let h, p, m, v; if (d > 0) if (h = o * l - a, p = o * a - l, v = s * d, h >= 0) if (p >= -v) if (p <= v) { const y = 1 / d; h *= y, p *= y, m = h * (h + o * p + 2 * a) + p * (o * h + p + 2 * l) + f } else p = s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + f; else p = -s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + f; else p <= -v ? (h = Math.max(0, -(-o * s + a)), p = h > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -h * h + p * (p + 2 * l) + f) : p <= v ? (h = 0, p = Math.min(Math.max(-s, -l), s), m = p * (p + 2 * l) + f) : (h = Math.max(0, -(o * s + a)), p = h > 0 ? s : Math.min(Math.max(-s, -l), s), m = -h * h + p * (p + 2 * l) + f); else p = o > 0 ? -s : s, h = Math.max(0, -(o * p + a)), m = -h * h + p * (p + 2 * l) + f; return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(ep).multiplyScalar(p).add(By), m } intersectSphere(e, t) { vs.subVectors(e.center, this.origin); const i = vs.dot(this.direction), r = vs.dot(vs) - i * i, s = e.radius * e.radius; if (r > s) return null; const o = Math.sqrt(s - r), a = i - o, l = i + o; return a < 0 && l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null } intersectPlane(e, t) { const i = this.distanceToPlane(e); return i === null ? null : this.at(i, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let i, r, s, o, a, l; const f = 1 / this.direction.x, d = 1 / this.direction.y, h = 1 / this.direction.z, p = this.origin; return f >= 0 ? (i = (e.min.x - p.x) * f, r = (e.max.x - p.x) * f) : (i = (e.max.x - p.x) * f, r = (e.min.x - p.x) * f), d >= 0 ? (s = (e.min.y - p.y) * d, o = (e.max.y - p.y) * d) : (s = (e.max.y - p.y) * d, o = (e.min.y - p.y) * d), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), h >= 0 ? (a = (e.min.z - p.z) * h, l = (e.max.z - p.z) * h) : (a = (e.max.z - p.z) * h, l = (e.min.z - p.z) * h), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t) } intersectsBox(e) { return this.intersectBox(e, vs) !== null } intersectTriangle(e, t, i, r, s) { Ry.subVectors(t, e), tp.subVectors(i, e), Ly.crossVectors(Ry, tp); let o = this.direction.dot(Ly), a; if (o > 0) { if (r) return null; a = 1 } else if (o < 0) a = -1, o = -o; else return null; oo.subVectors(this.origin, e); const l = a * this.direction.dot(tp.crossVectors(oo, tp)); if (l < 0) return null; const f = a * this.direction.dot(Ry.cross(oo)); if (f < 0 || l + f > o) return null; const d = -a * oo.dot(Ly); return d < 0 ? null : this.at(d / o, s) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class it { constructor() { it.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set(e, t, i, r, s, o, a, l, f, d, h, p, m, v, y, x) { const A = this.elements; return A[0] = e, A[4] = t, A[8] = i, A[12] = r, A[1] = s, A[5] = o, A[9] = a, A[13] = l, A[2] = f, A[6] = d, A[10] = h, A[14] = p, A[3] = m, A[7] = v, A[11] = y, A[15] = x, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new it().fromArray(this.elements) } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { const t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, i = e.elements, r = 1 / Bl.setFromMatrixColumn(e, 0).length(), s = 1 / Bl.setFromMatrixColumn(e, 1).length(), o = 1 / Bl.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(r), f = Math.sin(r), d = Math.cos(s), h = Math.sin(s); if (e.order === "XYZ") { const p = o * d, m = o * h, v = a * d, y = a * h; t[0] = l * d, t[4] = -l * h, t[8] = f, t[1] = m + v * f, t[5] = p - y * f, t[9] = -a * l, t[2] = y - p * f, t[6] = v + m * f, t[10] = o * l } else if (e.order === "YXZ") { const p = l * d, m = l * h, v = f * d, y = f * h; t[0] = p + y * a, t[4] = v * a - m, t[8] = o * f, t[1] = o * h, t[5] = o * d, t[9] = -a, t[2] = m * a - v, t[6] = y + p * a, t[10] = o * l } else if (e.order === "ZXY") { const p = l * d, m = l * h, v = f * d, y = f * h; t[0] = p - y * a, t[4] = -o * h, t[8] = v + m * a, t[1] = m + v * a, t[5] = o * d, t[9] = y - p * a, t[2] = -o * f, t[6] = a, t[10] = o * l } else if (e.order === "ZYX") { const p = o * d, m = o * h, v = a * d, y = a * h; t[0] = l * d, t[4] = v * f - m, t[8] = p * f + y, t[1] = l * h, t[5] = y * f + p, t[9] = m * f - v, t[2] = -f, t[6] = a * l, t[10] = o * l } else if (e.order === "YZX") { const p = o * l, m = o * f, v = a * l, y = a * f; t[0] = l * d, t[4] = y - p * h, t[8] = v * h + m, t[1] = h, t[5] = o * d, t[9] = -a * d, t[2] = -f * d, t[6] = m * h + v, t[10] = p - y * h } else if (e.order === "XZY") { const p = o * l, m = o * f, v = a * l, y = a * f; t[0] = l * d, t[4] = -h, t[8] = f * d, t[1] = p * h + y, t[5] = o * d, t[9] = m * h - v, t[2] = v * h - m, t[6] = a * d, t[10] = y * h + p } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(JN, e, XN) } lookAt(e, t, i) { const r = this.elements; return Li.subVectors(e, t), Li.lengthSq() === 0 && (Li.z = 1), Li.normalize(), ao.crossVectors(i, Li), ao.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Li.x += 1e-4 : Li.z += 1e-4, Li.normalize(), ao.crossVectors(i, Li)), ao.normalize(), np.crossVectors(Li, ao), r[0] = ao.x, r[4] = np.x, r[8] = Li.x, r[1] = ao.y, r[5] = np.y, r[9] = Li.y, r[2] = ao.z, r[6] = np.z, r[10] = Li.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], l = i[8], f = i[12], d = i[1], h = i[5], p = i[9], m = i[13], v = i[2], y = i[6], x = i[10], A = i[14], _ = i[3], w = i[7], S = i[11], T = i[15], P = r[0], R = r[4], E = r[8], B = r[12], L = r[1], U = r[5], q = r[9], W = r[13], G = r[2], K = r[6], ne = r[10], oe = r[14], N = r[3], V = r[7], Y = r[11], re = r[15]; return s[0] = o * P + a * L + l * G + f * N, s[4] = o * R + a * U + l * K + f * V, s[8] = o * E + a * q + l * ne + f * Y, s[12] = o * B + a * W + l * oe + f * re, s[1] = d * P + h * L + p * G + m * N, s[5] = d * R + h * U + p * K + m * V, s[9] = d * E + h * q + p * ne + m * Y, s[13] = d * B + h * W + p * oe + m * re, s[2] = v * P + y * L + x * G + A * N, s[6] = v * R + y * U + x * K + A * V, s[10] = v * E + y * q + x * ne + A * Y, s[14] = v * B + y * W + x * oe + A * re, s[3] = _ * P + w * L + S * G + T * N, s[7] = _ * R + w * U + S * K + T * V, s[11] = _ * E + w * q + S * ne + T * Y, s[15] = _ * B + w * W + S * oe + T * re, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], f = e[13], d = e[2], h = e[6], p = e[10], m = e[14], v = e[3], y = e[7], x = e[11], A = e[15]; return v * (+s * l * h - r * f * h - s * a * p + i * f * p + r * a * m - i * l * m) + y * (+t * l * m - t * f * p + s * o * p - r * o * m + r * f * d - s * l * d) + x * (+t * f * h - t * a * m - s * o * h + i * o * m + s * a * d - i * f * d) + A * (-r * a * d - t * l * h + t * a * p + r * o * h - i * o * p + i * l * d) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, i) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], d = e[8], h = e[9], p = e[10], m = e[11], v = e[12], y = e[13], x = e[14], A = e[15], _ = h * x * f - y * p * f + y * l * m - a * x * m - h * l * A + a * p * A, w = v * p * f - d * x * f - v * l * m + o * x * m + d * l * A - o * p * A, S = d * y * f - v * h * f + v * a * m - o * y * m - d * a * A + o * h * A, T = v * h * l - d * y * l - v * a * p + o * y * p + d * a * x - o * h * x, P = t * _ + i * w + r * S + s * T; if (P === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const R = 1 / P; return e[0] = _ * R, e[1] = (y * p * s - h * x * s - y * r * m + i * x * m + h * r * A - i * p * A) * R, e[2] = (a * x * s - y * l * s + y * r * f - i * x * f - a * r * A + i * l * A) * R, e[3] = (h * l * s - a * p * s - h * r * f + i * p * f + a * r * m - i * l * m) * R, e[4] = w * R, e[5] = (d * x * s - v * p * s + v * r * m - t * x * m - d * r * A + t * p * A) * R, e[6] = (v * l * s - o * x * s - v * r * f + t * x * f + o * r * A - t * l * A) * R, e[7] = (o * p * s - d * l * s + d * r * f - t * p * f - o * r * m + t * l * m) * R, e[8] = S * R, e[9] = (v * h * s - d * y * s - v * i * m + t * y * m + d * i * A - t * h * A) * R, e[10] = (o * y * s - v * a * s + v * i * f - t * y * f - o * i * A + t * a * A) * R, e[11] = (d * a * s - o * h * s - d * i * f + t * h * f + o * i * m - t * a * m) * R, e[12] = T * R, e[13] = (d * y * r - v * h * r + v * i * p - t * y * p - d * i * x + t * h * x) * R, e[14] = (v * a * r - o * y * r - v * i * l + t * y * l + o * i * x - t * a * x) * R, e[15] = (o * h * r - d * a * r + d * i * l - t * h * l - o * i * p + t * a * p) * R, this } scale(e) { const t = this.elements, i = e.x, r = e.y, s = e.z; return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, r)) } makeTranslation(e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, l = e.z, f = s * o, d = s * a; return this.set(f * o + i, f * a - r * l, f * l + r * a, 0, f * a + r * l, d * a + i, d * l - r * o, 0, f * l - r * a, d * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i, r, s, o) { return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, f = s + s, d = o + o, h = a + a, p = s * f, m = s * d, v = s * h, y = o * d, x = o * h, A = a * h, _ = l * f, w = l * d, S = l * h, T = i.x, P = i.y, R = i.z; return r[0] = (1 - (y + A)) * T, r[1] = (m + S) * T, r[2] = (v - w) * T, r[3] = 0, r[4] = (m - S) * P, r[5] = (1 - (p + A)) * P, r[6] = (x + _) * P, r[7] = 0, r[8] = (v + w) * R, r[9] = (x - _) * R, r[10] = (1 - (p + y)) * R, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, i) { const r = this.elements; let s = Bl.set(r[0], r[1], r[2]).length(); const o = Bl.set(r[4], r[5], r[6]).length(), a = Bl.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], wr.copy(this); const f = 1 / s, d = 1 / o, h = 1 / a; return wr.elements[0] *= f, wr.elements[1] *= f, wr.elements[2] *= f, wr.elements[4] *= d, wr.elements[5] *= d, wr.elements[6] *= d, wr.elements[8] *= h, wr.elements[9] *= h, wr.elements[10] *= h, t.setFromRotationMatrix(wr), i.x = s, i.y = o, i.z = a, this } makePerspective(e, t, i, r, s, o) { const a = this.elements, l = 2 * s / (t - e), f = 2 * s / (i - r), d = (t + e) / (t - e), h = (i + r) / (i - r), p = -(o + s) / (o - s), m = -2 * o * s / (o - s); return a[0] = l, a[4] = 0, a[8] = d, a[12] = 0, a[1] = 0, a[5] = f, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = p, a[14] = m, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic(e, t, i, r, s, o) { const a = this.elements, l = 1 / (t - e), f = 1 / (i - r), d = 1 / (o - s), h = (t + e) * l, p = (i + r) * f, m = (o + s) * d; return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * f, a[9] = 0, a[13] = -p, a[2] = 0, a[6] = 0, a[10] = -2 * d, a[14] = -m, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals(e) { const t = this.elements, i = e.elements; for (let r = 0; r < 16; r++)if (t[r] !== i[r]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } const Bl = new I, wr = new it, JN = new I(0, 0, 0), XN = new I(1, 1, 1), ao = new I, np = new I, Li = new I, iC = new it, rC = new Hn; class sl { constructor(e = 0, t = 0, i = 0, r = sl.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, r = this._order) { return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, i = !0) { const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], f = r[5], d = r[9], h = r[2], p = r[6], m = r[10]; switch (t) { case "XYZ": this._y = Math.asin(gn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-d, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, f), this._z = 0); break; case "YXZ": this._x = Math.asin(-gn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, f)) : (this._y = Math.atan2(-h, s), this._z = 0); break; case "ZXY": this._x = Math.asin(gn(p, -1, 1)), Math.abs(p) < .9999999 ? (this._y = Math.atan2(-h, m), this._z = Math.atan2(-o, f)) : (this._y = 0, this._z = Math.atan2(l, s)); break; case "ZYX": this._y = Math.asin(-gn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, f)); break; case "YZX": this._z = Math.asin(gn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-d, f), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, m)); break; case "XZY": this._z = Math.asin(-gn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(p, f), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-d, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, i === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return iC.makeRotationFromQuaternion(e), this.setFromRotationMatrix(iC, t, i) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return rC.setFromEuler(this), this.setFromQuaternion(rC, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } sl.DEFAULT_ORDER = "XYZ"; class Ja { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let YN = 0; const sC = new I, Rl = new Hn, xs = new it, ip = new I, Pc = new I, KN = new I, QN = new Hn, oC = new I(1, 0, 0), aC = new I(0, 1, 0), lC = new I(0, 0, 1), ZN = { type: "added" }, uC = { type: "removed" }; class bt extends os { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: YN++ }), this.uuid = Ui(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = bt.DEFAULT_UP.clone(); const e = new I, t = new sl, i = new Hn, r = new I(1, 1, 1); function s() { i.setFromEuler(t, !1) } function o() { t.setFromQuaternion(i, void 0, !1) } t._onChange(s), i._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new it }, normalMatrix: { value: new li } }), this.matrix = new it, this.matrixWorld = new it, this.matrixAutoUpdate = bt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Ja, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Rl.setFromAxisAngle(e, t), this.quaternion.multiply(Rl), this } rotateOnWorldAxis(e, t) { return Rl.setFromAxisAngle(e, t), this.quaternion.premultiply(Rl), this } rotateX(e) { return this.rotateOnAxis(oC, e) } rotateY(e) { return this.rotateOnAxis(aC, e) } rotateZ(e) { return this.rotateOnAxis(lC, e) } translateOnAxis(e, t) { return sC.copy(e).applyQuaternion(this.quaternion), this.position.add(sC.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(oC, e) } translateY(e) { return this.translateOnAxis(aC, e) } translateZ(e) { return this.translateOnAxis(lC, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(xs.copy(this.matrixWorld).invert()) } lookAt(e, t, i) { e.isVector3 ? ip.copy(e) : ip.set(e, t, i); const r = this.parent; this.updateWorldMatrix(!0, !1), Pc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? xs.lookAt(Pc, ip, this.up) : xs.lookAt(ip, Pc, this.up), this.quaternion.setFromRotationMatrix(xs), r && (xs.extractRotation(r.matrixWorld), Rl.setFromRotationMatrix(xs), this.quaternion.premultiply(Rl.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(ZN)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let i = 0; i < arguments.length; i++)this.remove(arguments[i]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(uC)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(uC) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), xs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), xs.multiply(e.parent.matrixWorld)), e.applyMatrix4(xs), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let i = 0, r = this.children.length; i < r; i++) { const o = this.children[i].getObjectByProperty(e, t); if (o !== void 0) return o } } getObjectsByProperty(e, t) { let i = []; this[e] === t && i.push(this); for (let r = 0, s = this.children.length; r < s; r++) { const o = this.children[r].getObjectsByProperty(e, t); o.length > 0 && (i = i.concat(o)) } return i } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pc, e, KN), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pc, QN, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const i = this.parent; if (e === !0 && i !== null && i.matrixWorldAutoUpdate === !0 && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const r = this.children; for (let s = 0, o = r.length; s < o; s++) { const a = r[s]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())); function s(a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = s(e.geometries, this.geometry); const a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { const l = a.shapes; if (Array.isArray(l)) for (let f = 0, d = l.length; f < d; f++) { const h = l[f]; s(e.shapes, h) } else s(e.shapes, l) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const a = []; for (let l = 0, f = this.material.length; l < f; l++)a.push(s(e.materials, this.material[l])); r.material = a } else r.material = s(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let a = 0; a < this.animations.length; a++) { const l = this.animations[a]; r.animations.push(s(e.animations, l)) } } if (t) { const a = o(e.geometries), l = o(e.materials), f = o(e.textures), d = o(e.images), h = o(e.shapes), p = o(e.skeletons), m = o(e.animations), v = o(e.nodes); a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), f.length > 0 && (i.textures = f), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), p.length > 0 && (i.skeletons = p), m.length > 0 && (i.animations = m), v.length > 0 && (i.nodes = v) } return i.object = r, i; function o(a) { const l = []; for (const f in a) { const d = a[f]; delete d.metadata, l.push(d) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let i = 0; i < e.children.length; i++) { const r = e.children[i]; this.add(r.clone()) } return this } } bt.DEFAULT_UP = new I(0, 1, 0); bt.DEFAULT_MATRIX_AUTO_UPDATE = !0; bt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const Sr = new I, As = new I, Dy = new I, _s = new I, Ll = new I, Dl = new I, cC = new I, Iy = new I, Fy = new I, Ny = new I; class ur { constructor(e = new I, t = new I, i = new I) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, r) { r.subVectors(i, t), Sr.subVectors(e, t), r.cross(Sr); const s = r.lengthSq(); return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0) } static getBarycoord(e, t, i, r, s) { Sr.subVectors(r, t), As.subVectors(i, t), Dy.subVectors(e, t); const o = Sr.dot(Sr), a = Sr.dot(As), l = Sr.dot(Dy), f = As.dot(As), d = As.dot(Dy), h = o * f - a * a; if (h === 0) return s.set(-2, -1, -1); const p = 1 / h, m = (f * l - a * d) * p, v = (o * d - a * l) * p; return s.set(1 - m - v, v, m) } static containsPoint(e, t, i, r) { return this.getBarycoord(e, t, i, r, _s), _s.x >= 0 && _s.y >= 0 && _s.x + _s.y <= 1 } static getUV(e, t, i, r, s, o, a, l) { return this.getBarycoord(e, t, i, r, _s), l.set(0, 0), l.addScaledVector(s, _s.x), l.addScaledVector(o, _s.y), l.addScaledVector(a, _s.z), l } static isFrontFacing(e, t, i, r) { return Sr.subVectors(i, t), As.subVectors(e, t), Sr.cross(As).dot(r) < 0 } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, r) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this } setFromAttributeAndIndices(e, t, i, r) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Sr.subVectors(this.c, this.b), As.subVectors(this.a, this.b), Sr.cross(As).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return ur.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return ur.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, i, r, s) { return ur.getUV(e, this.a, this.b, this.c, t, i, r, s) } containsPoint(e) { return ur.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return ur.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const i = this.a, r = this.b, s = this.c; let o, a; Ll.subVectors(r, i), Dl.subVectors(s, i), Iy.subVectors(e, i); const l = Ll.dot(Iy), f = Dl.dot(Iy); if (l <= 0 && f <= 0) return t.copy(i); Fy.subVectors(e, r); const d = Ll.dot(Fy), h = Dl.dot(Fy); if (d >= 0 && h <= d) return t.copy(r); const p = l * h - d * f; if (p <= 0 && l >= 0 && d <= 0) return o = l / (l - d), t.copy(i).addScaledVector(Ll, o); Ny.subVectors(e, s); const m = Ll.dot(Ny), v = Dl.dot(Ny); if (v >= 0 && m <= v) return t.copy(s); const y = m * f - l * v; if (y <= 0 && f >= 0 && v <= 0) return a = f / (f - v), t.copy(i).addScaledVector(Dl, a); const x = d * v - m * h; if (x <= 0 && h - d >= 0 && m - v >= 0) return cC.subVectors(s, r), a = (h - d) / (h - d + (m - v)), t.copy(r).addScaledVector(cC, a); const A = 1 / (x + y + p); return o = y * A, a = p * A, t.copy(i).addScaledVector(Ll, o).addScaledVector(Dl, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let qN = 0; class Mn extends os { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: qN++ }), this.uuid = Ui(), this.name = "", this.type = "Material", this.blending = Ga, this.side = is, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = LA, this.blendDst = DA, this.blendEquation = Ta, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Um, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = pB, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = lm, this.stencilZFail = lm, this.stencilZPass = lm, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const i = e[t]; if (i === void 0) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } const r = this[t]; if (r === void 0) { console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material."); continue } r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Ga && (i.blending = this.blending), this.side !== is && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = this.flatShading), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData); function r(s) { const o = []; for (const a in s) { const l = s[a]; delete l.metadata, o.push(l) } return o } if (t) { const s = r(e.textures), o = r(e.images); s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o) } return i } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let i = null; if (t !== null) { const r = t.length; i = new Array(r); for (let s = 0; s !== r; ++s)i[s] = t[s].clone() } return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } class Oi extends Mn { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = fd, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const xn = new I, rp = new pe; class It { constructor(e, t, i = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Vf, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.itemSize, i *= t.itemSize; for (let r = 0, s = this.itemSize; r < s; r++)this.array[e + r] = t.array[i + r]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++)rp.fromBufferAttribute(this, t), rp.applyMatrix3(e), this.setXY(t, rp.x, rp.y); else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++)xn.fromBufferAttribute(this, t), xn.applyMatrix3(e), this.setXYZ(t, xn.x, xn.y, xn.z); return this } applyMatrix4(e) { for (let t = 0, i = this.count; t < i; t++)xn.fromBufferAttribute(this, t), xn.applyMatrix4(e), this.setXYZ(t, xn.x, xn.y, xn.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)xn.fromBufferAttribute(this, t), xn.applyNormalMatrix(e), this.setXYZ(t, xn.x, xn.y, xn.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)xn.fromBufferAttribute(this, t), xn.transformDirection(e), this.setXYZ(t, xn.x, xn.y, xn.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = Rs(t, this.array)), t } setX(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = Rs(t, this.array)), t } setY(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = Rs(t, this.array)), t } setZ(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = Rs(t, this.array)), t } setW(e, t) { return this.normalized && (t = zt(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, i) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this } setXYZW(e, t, i, r, s) { return e *= this.itemSize, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== Vf && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } copyColorsArray() { console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.") } copyVector2sArray() { console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.") } copyVector3sArray() { console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.") } copyVector4sArray() { console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.") } } class $N extends It { constructor(e, t, i) { super(new Int8Array(e), t, i) } } class eO extends It { constructor(e, t, i) { super(new Uint8Array(e), t, i) } } class tO extends It { constructor(e, t, i) { super(new Uint8ClampedArray(e), t, i) } } class nO extends It { constructor(e, t, i) { super(new Int16Array(e), t, i) } } class HA extends It { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } class iO extends It { constructor(e, t, i) { super(new Int32Array(e), t, i) } } class VA extends It { constructor(e, t, i) { super(new Uint32Array(e), t, i) } } class rO extends It { constructor(e, t, i) { super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0 } } class We extends It { constructor(e, t, i) { super(new Float32Array(e), t, i) } } class sO extends It { constructor(e, t, i) { super(new Float64Array(e), t, i) } } let oO = 0; const ir = new it, Oy = new bt, Il = new I, Di = new Xo, Bc = new Xo, Fn = new I; class ut extends os { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: oO++ }), this.uuid = Ui(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (gB(e) ? VA : HA)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const i = this.attributes.normal; if (i !== void 0) { const s = new li().getNormalMatrix(e); i.applyNormalMatrix(s), i.needsUpdate = !0 } const r = this.attributes.tangent; return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return ir.makeRotationFromQuaternion(e), this.applyMatrix4(ir), this } rotateX(e) { return ir.makeRotationX(e), this.applyMatrix4(ir), this } rotateY(e) { return ir.makeRotationY(e), this.applyMatrix4(ir), this } rotateZ(e) { return ir.makeRotationZ(e), this.applyMatrix4(ir), this } translate(e, t, i) { return ir.makeTranslation(e, t, i), this.applyMatrix4(ir), this } scale(e, t, i) { return ir.makeScale(e, t, i), this.applyMatrix4(ir), this } lookAt(e) { return Oy.lookAt(e), Oy.updateMatrix(), this.applyMatrix4(Oy.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(Il).negate(), this.translate(Il.x, Il.y, Il.z), this } setFromPoints(e) { const t = []; for (let i = 0, r = e.length; i < r; i++) { const s = e[i]; t.push(s.x, s.y, s.z || 0) } return this.setAttribute("position", new We(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Xo); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new I(-1 / 0, -1 / 0, -1 / 0), new I(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; Di.setFromBufferAttribute(s), this.morphTargetsRelative ? (Fn.addVectors(this.boundingBox.min, Di.min), this.boundingBox.expandByPoint(Fn), Fn.addVectors(this.boundingBox.max, Di.max), this.boundingBox.expandByPoint(Fn)) : (this.boundingBox.expandByPoint(Di.min), this.boundingBox.expandByPoint(Di.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new Yo); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new I, 1 / 0); return } if (e) { const i = this.boundingSphere.center; if (Di.setFromBufferAttribute(e), t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s]; Bc.setFromBufferAttribute(a), this.morphTargetsRelative ? (Fn.addVectors(Di.min, Bc.min), Di.expandByPoint(Fn), Fn.addVectors(Di.max, Bc.max), Di.expandByPoint(Fn)) : (Di.expandByPoint(Bc.min), Di.expandByPoint(Bc.max)) } Di.getCenter(i); let r = 0; for (let s = 0, o = e.count; s < o; s++)Fn.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(Fn)); if (t) for (let s = 0, o = t.length; s < o; s++) { const a = t[s], l = this.morphTargetsRelative; for (let f = 0, d = a.count; f < d; f++)Fn.fromBufferAttribute(a, f), l && (Il.fromBufferAttribute(e, f), Fn.add(Il)), r = Math.max(r, i.distanceToSquared(Fn)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new It(new Float32Array(4 * a), 4)); const l = this.getAttribute("tangent").array, f = [], d = []; for (let L = 0; L < a; L++)f[L] = new I, d[L] = new I; const h = new I, p = new I, m = new I, v = new pe, y = new pe, x = new pe, A = new I, _ = new I; function w(L, U, q) { h.fromArray(r, L * 3), p.fromArray(r, U * 3), m.fromArray(r, q * 3), v.fromArray(o, L * 2), y.fromArray(o, U * 2), x.fromArray(o, q * 2), p.sub(h), m.sub(h), y.sub(v), x.sub(v); const W = 1 / (y.x * x.y - x.x * y.y); isFinite(W) && (A.copy(p).multiplyScalar(x.y).addScaledVector(m, -y.y).multiplyScalar(W), _.copy(m).multiplyScalar(y.x).addScaledVector(p, -x.x).multiplyScalar(W), f[L].add(A), f[U].add(A), f[q].add(A), d[L].add(_), d[U].add(_), d[q].add(_)) } let S = this.groups; S.length === 0 && (S = [{ start: 0, count: i.length }]); for (let L = 0, U = S.length; L < U; ++L) { const q = S[L], W = q.start, G = q.count; for (let K = W, ne = W + G; K < ne; K += 3)w(i[K + 0], i[K + 1], i[K + 2]) } const T = new I, P = new I, R = new I, E = new I; function B(L) { R.fromArray(s, L * 3), E.copy(R); const U = f[L]; T.copy(U), T.sub(R.multiplyScalar(R.dot(U))).normalize(), P.crossVectors(E, U); const W = P.dot(d[L]) < 0 ? -1 : 1; l[L * 4] = T.x, l[L * 4 + 1] = T.y, l[L * 4 + 2] = T.z, l[L * 4 + 3] = W } for (let L = 0, U = S.length; L < U; ++L) { const q = S[L], W = q.start, G = q.count; for (let K = W, ne = W + G; K < ne; K += 3)B(i[K + 0]), B(i[K + 1]), B(i[K + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let i = this.getAttribute("normal"); if (i === void 0) i = new It(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i); else for (let p = 0, m = i.count; p < m; p++)i.setXYZ(p, 0, 0, 0); const r = new I, s = new I, o = new I, a = new I, l = new I, f = new I, d = new I, h = new I; if (e) for (let p = 0, m = e.count; p < m; p += 3) { const v = e.getX(p + 0), y = e.getX(p + 1), x = e.getX(p + 2); r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, y), o.fromBufferAttribute(t, x), d.subVectors(o, s), h.subVectors(r, s), d.cross(h), a.fromBufferAttribute(i, v), l.fromBufferAttribute(i, y), f.fromBufferAttribute(i, x), a.add(d), l.add(d), f.add(d), i.setXYZ(v, a.x, a.y, a.z), i.setXYZ(y, l.x, l.y, l.z), i.setXYZ(x, f.x, f.y, f.z) } else for (let p = 0, m = t.count; p < m; p += 3)r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), d.subVectors(o, s), h.subVectors(r, s), d.cross(h), i.setXYZ(p + 0, d.x, d.y, d.z), i.setXYZ(p + 1, d.x, d.y, d.z), i.setXYZ(p + 2, d.x, d.y, d.z); this.normalizeNormals(), i.needsUpdate = !0 } } merge() { return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, i = e.count; t < i; t++)Fn.fromBufferAttribute(e, t), Fn.normalize(), e.setXYZ(t, Fn.x, Fn.y, Fn.z) } toNonIndexed() { function e(a, l) { const f = a.array, d = a.itemSize, h = a.normalized, p = new f.constructor(l.length * d); let m = 0, v = 0; for (let y = 0, x = l.length; y < x; y++) { a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * d; for (let A = 0; A < d; A++)p[v++] = f[m++] } return new It(p, d, h) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new ut, i = this.index.array, r = this.attributes; for (const a in r) { const l = r[a], f = e(l, i); t.setAttribute(a, f) } const s = this.morphAttributes; for (const a in s) { const l = [], f = s[a]; for (let d = 0, h = f.length; d < h; d++) { const p = f[d], m = e(p, i); l.push(m) } t.morphAttributes[a] = l } t.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let a = 0, l = o.length; a < l; a++) { const f = o[a]; t.addGroup(f.start, f.count, f.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const f in l) l[f] !== void 0 && (e[f] = l[f]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const i = this.attributes; for (const l in i) { const f = i[l]; e.data.attributes[l] = f.toJSON(e.data) } const r = {}; let s = !1; for (const l in this.morphAttributes) { const f = this.morphAttributes[l], d = []; for (let h = 0, p = f.length; h < p; h++) { const m = f[h]; d.push(m.toJSON(e.data)) } d.length > 0 && (r[l] = d, s = !0) } s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o))); const a = this.boundingSphere; return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const i = e.index; i !== null && this.setIndex(i.clone(t)); const r = e.attributes; for (const f in r) { const d = r[f]; this.setAttribute(f, d.clone(t)) } const s = e.morphAttributes; for (const f in s) { const d = [], h = s[f]; for (let p = 0, m = h.length; p < m; p++)d.push(h[p].clone(t)); this.morphAttributes[f] = d } this.morphTargetsRelative = e.morphTargetsRelative; const o = e.groups; for (let f = 0, d = o.length; f < d; f++) { const h = o[f]; this.addGroup(h.start, h.count, h.materialIndex) } const a = e.boundingBox; a !== null && (this.boundingBox = a.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const fC = new it, Fl = new dd, ky = new Yo, Rc = new I, Lc = new I, Dc = new I, Uy = new I, sp = new I, op = new pe, ap = new pe, lp = new pe, zy = new I, up = new I; class Tn extends bt { constructor(e = new ut, t = new Oi) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } getVertexPosition(e, t) { const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, o = i.morphTargetsRelative; t.fromBufferAttribute(r, e); const a = this.morphTargetInfluences; if (s && a) { sp.set(0, 0, 0); for (let l = 0, f = s.length; l < f; l++) { const d = a[l], h = s[l]; d !== 0 && (Uy.fromBufferAttribute(h, e), o ? sp.addScaledVector(Uy, d) : sp.addScaledVector(Uy.sub(t), d)) } t.add(sp) } return this.isSkinnedMesh && this.boneTransform(e, t), t } raycast(e, t) { const i = this.geometry, r = this.material, s = this.matrixWorld; if (r === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), ky.copy(i.boundingSphere), ky.applyMatrix4(s), e.ray.intersectsSphere(ky) === !1) || (fC.copy(s).invert(), Fl.copy(e.ray).applyMatrix4(fC), i.boundingBox !== null && Fl.intersectsBox(i.boundingBox) === !1)) return; let o; const a = i.index, l = i.attributes.position, f = i.attributes.uv, d = i.attributes.uv2, h = i.groups, p = i.drawRange; if (a !== null) if (Array.isArray(r)) for (let m = 0, v = h.length; m < v; m++) { const y = h[m], x = r[y.materialIndex], A = Math.max(y.start, p.start), _ = Math.min(a.count, Math.min(y.start + y.count, p.start + p.count)); for (let w = A, S = _; w < S; w += 3) { const T = a.getX(w), P = a.getX(w + 1), R = a.getX(w + 2); o = cp(this, x, e, Fl, f, d, T, P, R), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = y.materialIndex, t.push(o)) } } else { const m = Math.max(0, p.start), v = Math.min(a.count, p.start + p.count); for (let y = m, x = v; y < x; y += 3) { const A = a.getX(y), _ = a.getX(y + 1), w = a.getX(y + 2); o = cp(this, r, e, Fl, f, d, A, _, w), o && (o.faceIndex = Math.floor(y / 3), t.push(o)) } } else if (l !== void 0) if (Array.isArray(r)) for (let m = 0, v = h.length; m < v; m++) { const y = h[m], x = r[y.materialIndex], A = Math.max(y.start, p.start), _ = Math.min(l.count, Math.min(y.start + y.count, p.start + p.count)); for (let w = A, S = _; w < S; w += 3) { const T = w, P = w + 1, R = w + 2; o = cp(this, x, e, Fl, f, d, T, P, R), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = y.materialIndex, t.push(o)) } } else { const m = Math.max(0, p.start), v = Math.min(l.count, p.start + p.count); for (let y = m, x = v; y < x; y += 3) { const A = y, _ = y + 1, w = y + 2; o = cp(this, r, e, Fl, f, d, A, _, w), o && (o.faceIndex = Math.floor(y / 3), t.push(o)) } } } } function aO(n, e, t, i, r, s, o, a) { let l; if (e.side === Ei ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === is, a), l === null) return null; up.copy(a), up.applyMatrix4(n.matrixWorld); const f = t.ray.origin.distanceTo(up); return f < t.near || f > t.far ? null : { distance: f, point: up.clone(), object: n } } function cp(n, e, t, i, r, s, o, a, l) { n.getVertexPosition(o, Rc), n.getVertexPosition(a, Lc), n.getVertexPosition(l, Dc); const f = aO(n, e, t, i, Rc, Lc, Dc, zy); if (f) { r && (op.fromBufferAttribute(r, o), ap.fromBufferAttribute(r, a), lp.fromBufferAttribute(r, l), f.uv = ur.getUV(zy, Rc, Lc, Dc, op, ap, lp, new pe)), s && (op.fromBufferAttribute(s, o), ap.fromBufferAttribute(s, a), lp.fromBufferAttribute(s, l), f.uv2 = ur.getUV(zy, Rc, Lc, Dc, op, ap, lp, new pe)); const d = { a: o, b: a, c: l, normal: new I, materialIndex: 0 }; ur.getNormal(Rc, Lc, Dc, d.normal), f.face = d } return f } class Ko extends ut { constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: o }; const a = this; r = Math.floor(r), s = Math.floor(s), o = Math.floor(o); const l = [], f = [], d = [], h = []; let p = 0, m = 0; v("z", "y", "x", -1, -1, i, t, e, o, s, 0), v("z", "y", "x", 1, -1, i, t, -e, o, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, o, 2), v("x", "z", "y", 1, -1, e, i, -t, r, o, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new We(f, 3)), this.setAttribute("normal", new We(d, 3)), this.setAttribute("uv", new We(h, 2)); function v(y, x, A, _, w, S, T, P, R, E, B) { const L = S / R, U = T / E, q = S / 2, W = T / 2, G = P / 2, K = R + 1, ne = E + 1; let oe = 0, N = 0; const V = new I; for (let Y = 0; Y < ne; Y++) { const re = Y * U - W; for (let j = 0; j < K; j++) { const ie = j * L - q; V[y] = ie * _, V[x] = re * w, V[A] = G, f.push(V.x, V.y, V.z), V[y] = 0, V[x] = 0, V[A] = P > 0 ? 1 : -1, d.push(V.x, V.y, V.z), h.push(j / R), h.push(1 - Y / E), oe += 1 } } for (let Y = 0; Y < E; Y++)for (let re = 0; re < R; re++) { const j = p + re + K * Y, ie = p + re + K * (Y + 1), ve = p + (re + 1) + K * (Y + 1), Ae = p + (re + 1) + K * Y; l.push(j, ie, Ae), l.push(ie, ve, Ae), N += 6 } a.addGroup(m, N, B), m += N, p += oe } } static fromJSON(e) { return new Ko(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Lu(n) { const e = {}; for (const t in n) { e[t] = {}; for (const i in n[t]) { const r = n[t][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r } } return e } function si(n) { const e = {}; for (let t = 0; t < n.length; t++) { const i = Lu(n[t]); for (const r in i) e[r] = i[r] } return e } function lO(n) { const e = []; for (let t = 0; t < n.length; t++)e.push(n[t].clone()); return e } function vB(n) { return n.getRenderTarget() === null && n.outputEncoding === Ct ? Tr : Ru } const xB = { clone: Lu, merge: si }; var uO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, cO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class ss extends Mn { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = uO, this.fragmentShader = cO, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Lu(e.uniforms), this.uniformsGroups = lO(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const r in this.uniforms) { const o = this.uniforms[r].value; o && o.isTexture ? t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[r] = { type: "m4", value: o.toArray() } : t.uniforms[r] = { value: o } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const i = {}; for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t } } class hd extends bt { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new it, this.projectionMatrix = new it, this.projectionMatrixInverse = new it } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } class Gt extends hd { constructor(e = 50, t = 1, i = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = Wf * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(Wa * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return Wf * 2 * Math.atan(Math.tan(Wa * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, i, r, s, o) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(Wa * .5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -.5 * r; const o = this.view; if (this.view !== null && this.view.enabled) { const l = o.fullWidth, f = o.fullHeight; s += o.offsetX * r / l, t -= o.offsetY * i / f, r *= o.width / l, i *= o.height / f } const a = this.filmOffset; a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const Nl = -90, Ol = 1; class WA extends bt { constructor(e, t, i) { super(), this.type = "CubeCamera", this.renderTarget = i; const r = new Gt(Nl, Ol, e, t); r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r); const s = new Gt(Nl, Ol, e, t); s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s); const o = new Gt(Nl, Ol, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o); const a = new Gt(Nl, Ol, e, t); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a); const l = new Gt(Nl, Ol, e, t); l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l); const f = new Gt(Nl, Ol, e, t); f.layers = this.layers, f.up.set(0, 1, 0), f.lookAt(0, 0, -1), this.add(f) } update(e, t) { this.parent === null && this.updateMatrixWorld(); const i = this.renderTarget, [r, s, o, a, l, f] = this.children, d = e.getRenderTarget(), h = e.toneMapping, p = e.xr.enabled; e.toneMapping = Dr, e.xr.enabled = !1; const m = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, s), e.setRenderTarget(i, 2), e.render(t, o), e.setRenderTarget(i, 3), e.render(t, a), e.setRenderTarget(i, 4), e.render(t, l), i.texture.generateMipmaps = m, e.setRenderTarget(i, 5), e.render(t, f), e.setRenderTarget(d), e.toneMapping = h, e.xr.enabled = p, i.texture.needsPMREMUpdate = !0 } } class pd extends Qt { constructor(e, t, i, r, s, o, a, l, f, d) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : Oo, super(e, t, i, r, s, o, a, l, f, d), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class jA extends Nr {
	constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i]; this.texture = new pd(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : en } fromEquirectangularTexture(e, t) {
		this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const i = {
			uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new Ko(5, 5, 5), s = new ss({ name: "CubemapFromEquirect", uniforms: Lu(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Ei, blending: Fs }); s.uniforms.tEquirect.value = t; const o = new Tn(r, s), a = t.minFilter; return t.minFilter === rs && (t.minFilter = en), new WA(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
	} clear(e, t, i, r) { const s = e.getRenderTarget(); for (let o = 0; o < 6; o++)e.setRenderTarget(this, o), e.clear(t, i, r); e.setRenderTarget(s) }
} const Gy = new I, fO = new I, dO = new li; class go { constructor(e = new I(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, r) { return this.normal.set(e, t, i), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { const r = Gy.subVectors(i, t).cross(fO.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { const i = e.delta(Gy), r = this.normal.dot(i); if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const s = -(e.start.dot(this.normal) + this.constant) / r; return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const i = t || dO.getNormalMatrix(e), r = this.coplanarPoint(Gy).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize(); return this.constant = -r.dot(s), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const kl = new Yo, fp = new I; class wg { constructor(e = new go, t = new go, i = new go, r = new go, s = new go, o = new go) { this.planes = [e, t, i, r, s, o] } set(e, t, i, r, s, o) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this } copy(e) { const t = this.planes; for (let i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this } setFromProjectionMatrix(e) { const t = this.planes, i = e.elements, r = i[0], s = i[1], o = i[2], a = i[3], l = i[4], f = i[5], d = i[6], h = i[7], p = i[8], m = i[9], v = i[10], y = i[11], x = i[12], A = i[13], _ = i[14], w = i[15]; return t[0].setComponents(a - r, h - l, y - p, w - x).normalize(), t[1].setComponents(a + r, h + l, y + p, w + x).normalize(), t[2].setComponents(a + s, h + f, y + m, w + A).normalize(), t[3].setComponents(a - s, h - f, y - m, w - A).normalize(), t[4].setComponents(a - o, h - d, y - v, w - _).normalize(), t[5].setComponents(a + o, h + d, y + v, w + _).normalize(), this } intersectsObject(e) { const t = e.geometry; return t.boundingSphere === null && t.computeBoundingSphere(), kl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(kl) } intersectsSprite(e) { return kl.center.set(0, 0, 0), kl.radius = .7071067811865476, kl.applyMatrix4(e.matrixWorld), this.intersectsSphere(kl) } intersectsSphere(e) { const t = this.planes, i = e.center, r = -e.radius; for (let s = 0; s < 6; s++)if (t[s].distanceToPoint(i) < r) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let i = 0; i < 6; i++) { const r = t[i]; if (fp.x = r.normal.x > 0 ? e.max.x : e.min.x, fp.y = r.normal.y > 0 ? e.max.y : e.min.y, fp.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(fp) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let i = 0; i < 6; i++)if (t[i].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function AB() { let n = null, e = !1, t = null, i = null; function r(s, o) { t(s, o), i = n.requestAnimationFrame(r) } return { start: function () { e !== !0 && t !== null && (i = n.requestAnimationFrame(r), e = !0) }, stop: function () { n.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (s) { t = s }, setContext: function (s) { n = s } } } function hO(n, e) { const t = e.isWebGL2, i = new WeakMap; function r(f, d) { const h = f.array, p = f.usage, m = n.createBuffer(); n.bindBuffer(d, m), n.bufferData(d, h, p), f.onUploadCallback(); let v; if (h instanceof Float32Array) v = 5126; else if (h instanceof Uint16Array) if (f.isFloat16BufferAttribute) if (t) v = 5131; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else v = 5123; else if (h instanceof Int16Array) v = 5122; else if (h instanceof Uint32Array) v = 5125; else if (h instanceof Int32Array) v = 5124; else if (h instanceof Int8Array) v = 5120; else if (h instanceof Uint8Array) v = 5121; else if (h instanceof Uint8ClampedArray) v = 5121; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h); return { buffer: m, type: v, bytesPerElement: h.BYTES_PER_ELEMENT, version: f.version } } function s(f, d, h) { const p = d.array, m = d.updateRange; n.bindBuffer(h, f), m.count === -1 ? n.bufferSubData(h, 0, p) : (t ? n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p, m.offset, m.count) : n.bufferSubData(h, m.offset * p.BYTES_PER_ELEMENT, p.subarray(m.offset, m.offset + m.count)), m.count = -1), d.onUploadCallback() } function o(f) { return f.isInterleavedBufferAttribute && (f = f.data), i.get(f) } function a(f) { f.isInterleavedBufferAttribute && (f = f.data); const d = i.get(f); d && (n.deleteBuffer(d.buffer), i.delete(f)) } function l(f, d) { if (f.isGLBufferAttribute) { const p = i.get(f); (!p || p.version < f.version) && i.set(f, { buffer: f.buffer, type: f.type, bytesPerElement: f.elementSize, version: f.version }); return } f.isInterleavedBufferAttribute && (f = f.data); const h = i.get(f); h === void 0 ? i.set(f, r(f, d)) : h.version < f.version && (s(h.buffer, f, d), h.version = f.version) } return { get: o, remove: a, update: l } } class Wu extends ut { constructor(e = 1, t = 1, i = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r }; const s = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(r), f = a + 1, d = l + 1, h = e / a, p = t / l, m = [], v = [], y = [], x = []; for (let A = 0; A < d; A++) { const _ = A * p - o; for (let w = 0; w < f; w++) { const S = w * h - s; v.push(S, -_, 0), y.push(0, 0, 1), x.push(w / a), x.push(1 - A / l) } } for (let A = 0; A < l; A++)for (let _ = 0; _ < a; _++) { const w = _ + f * A, S = _ + f * (A + 1), T = _ + 1 + f * (A + 1), P = _ + 1 + f * A; m.push(w, S, P), m.push(S, T, P) } this.setIndex(m), this.setAttribute("position", new We(v, 3)), this.setAttribute("normal", new We(y, 3)), this.setAttribute("uv", new We(x, 2)) } static fromJSON(e) { return new Wu(e.width, e.height, e.widthSegments, e.heightSegments) } } var pO = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, mO = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, gO = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, yO = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, vO = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, xO = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, AO = "vec3 transformed = vec3( position );", _O = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, MO = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, wO = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, SO = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, CO = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, EO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, TO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, bO = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, PO = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, BO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, RO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, LO = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, DO = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, IO = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, FO = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, NO = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, OO = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, kO = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, UO = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, zO = "gl_FragColor = linearToOutputTexel( gl_FragColor );", GO = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, HO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, VO = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, WO = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, jO = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, JO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, XO = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, YO = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, KO = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, QO = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, ZO = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, qO = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, $O = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, ek = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, tk = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, nk = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, ik = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, rk = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, sk = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ok = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, ak = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, lk = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, uk = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, ck = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, fk = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, dk = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, hk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, pk = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, mk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, gk = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, yk = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, vk = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, xk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Ak = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, _k = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Mk = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, wk = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Sk = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Ck = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, Ek = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Tk = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, bk = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Pk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Bk = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Rk = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Lk = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, Dk = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, Ik = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, Fk = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, Nk = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Ok = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, kk = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, Uk = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, zk = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Gk = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Hk = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Vk = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Wk = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, jk = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, Jk = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Xk = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Yk = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Kk = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Qk = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, Zk = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, qk = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, $k = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, eU = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, tU = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, nU = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, iU = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, rU = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, sU = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, oU = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, aU = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, lU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, uU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, cU = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, fU = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const dU = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, hU = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, pU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, mU = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, gU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, yU = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, vU = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, xU = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, AU = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, _U = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, MU = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, wU = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, SU = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, CU = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, EU = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, TU = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bU = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, PU = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, BU = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, RU = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, LU = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, DU = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, IU = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, FU = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, NU = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, OU = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, kU = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, UU = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, zU = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, GU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, HU = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, VU = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, WU = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, jU = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, pt = { alphamap_fragment: pO, alphamap_pars_fragment: mO, alphatest_fragment: gO, alphatest_pars_fragment: yO, aomap_fragment: vO, aomap_pars_fragment: xO, begin_vertex: AO, beginnormal_vertex: _O, bsdfs: MO, iridescence_fragment: wO, bumpmap_pars_fragment: SO, clipping_planes_fragment: CO, clipping_planes_pars_fragment: EO, clipping_planes_pars_vertex: TO, clipping_planes_vertex: bO, color_fragment: PO, color_pars_fragment: BO, color_pars_vertex: RO, color_vertex: LO, common: DO, cube_uv_reflection_fragment: IO, defaultnormal_vertex: FO, displacementmap_pars_vertex: NO, displacementmap_vertex: OO, emissivemap_fragment: kO, emissivemap_pars_fragment: UO, encodings_fragment: zO, encodings_pars_fragment: GO, envmap_fragment: HO, envmap_common_pars_fragment: VO, envmap_pars_fragment: WO, envmap_pars_vertex: jO, envmap_physical_pars_fragment: ik, envmap_vertex: JO, fog_vertex: XO, fog_pars_vertex: YO, fog_fragment: KO, fog_pars_fragment: QO, gradientmap_pars_fragment: ZO, lightmap_fragment: qO, lightmap_pars_fragment: $O, lights_lambert_fragment: ek, lights_lambert_pars_fragment: tk, lights_pars_begin: nk, lights_toon_fragment: rk, lights_toon_pars_fragment: sk, lights_phong_fragment: ok, lights_phong_pars_fragment: ak, lights_physical_fragment: lk, lights_physical_pars_fragment: uk, lights_fragment_begin: ck, lights_fragment_maps: fk, lights_fragment_end: dk, logdepthbuf_fragment: hk, logdepthbuf_pars_fragment: pk, logdepthbuf_pars_vertex: mk, logdepthbuf_vertex: gk, map_fragment: yk, map_pars_fragment: vk, map_particle_fragment: xk, map_particle_pars_fragment: Ak, metalnessmap_fragment: _k, metalnessmap_pars_fragment: Mk, morphcolor_vertex: wk, morphnormal_vertex: Sk, morphtarget_pars_vertex: Ck, morphtarget_vertex: Ek, normal_fragment_begin: Tk, normal_fragment_maps: bk, normal_pars_fragment: Pk, normal_pars_vertex: Bk, normal_vertex: Rk, normalmap_pars_fragment: Lk, clearcoat_normal_fragment_begin: Dk, clearcoat_normal_fragment_maps: Ik, clearcoat_pars_fragment: Fk, iridescence_pars_fragment: Nk, output_fragment: Ok, packing: kk, premultiplied_alpha_fragment: Uk, project_vertex: zk, dithering_fragment: Gk, dithering_pars_fragment: Hk, roughnessmap_fragment: Vk, roughnessmap_pars_fragment: Wk, shadowmap_pars_fragment: jk, shadowmap_pars_vertex: Jk, shadowmap_vertex: Xk, shadowmask_pars_fragment: Yk, skinbase_vertex: Kk, skinning_pars_vertex: Qk, skinning_vertex: Zk, skinnormal_vertex: qk, specularmap_fragment: $k, specularmap_pars_fragment: eU, tonemapping_fragment: tU, tonemapping_pars_fragment: nU, transmission_fragment: iU, transmission_pars_fragment: rU, uv_pars_fragment: sU, uv_pars_vertex: oU, uv_vertex: aU, uv2_pars_fragment: lU, uv2_pars_vertex: uU, uv2_vertex: cU, worldpos_vertex: fU, background_vert: dU, background_frag: hU, backgroundCube_vert: pU, backgroundCube_frag: mU, cube_vert: gU, cube_frag: yU, depth_vert: vU, depth_frag: xU, distanceRGBA_vert: AU, distanceRGBA_frag: _U, equirect_vert: MU, equirect_frag: wU, linedashed_vert: SU, linedashed_frag: CU, meshbasic_vert: EU, meshbasic_frag: TU, meshlambert_vert: bU, meshlambert_frag: PU, meshmatcap_vert: BU, meshmatcap_frag: RU, meshnormal_vert: LU, meshnormal_frag: DU, meshphong_vert: IU, meshphong_frag: FU, meshphysical_vert: NU, meshphysical_frag: OU, meshtoon_vert: kU, meshtoon_frag: UU, points_vert: zU, points_frag: GU, shadow_vert: HU, shadow_frag: VU, sprite_vert: WU, sprite_frag: jU }, Re = { common: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new li }, uv2Transform: { value: new li }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new pe(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Le(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new li } }, sprite: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, center: { value: new pe(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new li } } }, Pr = { basic: { uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]), vertexShader: pt.meshbasic_vert, fragmentShader: pt.meshbasic_frag }, lambert: { uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, { emissive: { value: new Le(0) } }]), vertexShader: pt.meshlambert_vert, fragmentShader: pt.meshlambert_frag }, phong: { uniforms: si([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, { emissive: { value: new Le(0) }, specular: { value: new Le(1118481) }, shininess: { value: 30 } }]), vertexShader: pt.meshphong_vert, fragmentShader: pt.meshphong_frag }, standard: { uniforms: si([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, { emissive: { value: new Le(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: pt.meshphysical_vert, fragmentShader: pt.meshphysical_frag }, toon: { uniforms: si([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, { emissive: { value: new Le(0) } }]), vertexShader: pt.meshtoon_vert, fragmentShader: pt.meshtoon_frag }, matcap: { uniforms: si([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, { matcap: { value: null } }]), vertexShader: pt.meshmatcap_vert, fragmentShader: pt.meshmatcap_frag }, points: { uniforms: si([Re.points, Re.fog]), vertexShader: pt.points_vert, fragmentShader: pt.points_frag }, dashed: { uniforms: si([Re.common, Re.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: pt.linedashed_vert, fragmentShader: pt.linedashed_frag }, depth: { uniforms: si([Re.common, Re.displacementmap]), vertexShader: pt.depth_vert, fragmentShader: pt.depth_frag }, normal: { uniforms: si([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, { opacity: { value: 1 } }]), vertexShader: pt.meshnormal_vert, fragmentShader: pt.meshnormal_frag }, sprite: { uniforms: si([Re.sprite, Re.fog]), vertexShader: pt.sprite_vert, fragmentShader: pt.sprite_frag }, background: { uniforms: { uvTransform: { value: new li }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: pt.background_vert, fragmentShader: pt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: pt.backgroundCube_vert, fragmentShader: pt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: pt.cube_vert, fragmentShader: pt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: pt.equirect_vert, fragmentShader: pt.equirect_frag }, distanceRGBA: { uniforms: si([Re.common, Re.displacementmap, { referencePosition: { value: new I }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: pt.distanceRGBA_vert, fragmentShader: pt.distanceRGBA_frag }, shadow: { uniforms: si([Re.lights, Re.fog, { color: { value: new Le(0) }, opacity: { value: 1 } }]), vertexShader: pt.shadow_vert, fragmentShader: pt.shadow_frag } }; Pr.physical = { uniforms: si([Pr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new pe(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Le(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new pe }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Le(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Le(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: pt.meshphysical_vert, fragmentShader: pt.meshphysical_frag }; const dp = { r: 0, b: 0, g: 0 }; function JU(n, e, t, i, r, s, o) { const a = new Le(0); let l = s === !0 ? 0 : 1, f, d, h = null, p = 0, m = null; function v(x, A) { let _ = !1, w = A.isScene === !0 ? A.background : null; w && w.isTexture && (w = (A.backgroundBlurriness > 0 ? t : e).get(w)); const S = n.xr, T = S.getSession && S.getSession(); T && T.environmentBlendMode === "additive" && (w = null), w === null ? y(a, l) : w && w.isColor && (y(w, 1), _ = !0), (n.autoClear || _) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), w && (w.isCubeTexture || w.mapping === Vu) ? (d === void 0 && (d = new Tn(new Ko(1, 1, 1), new ss({ name: "BackgroundCubeMaterial", uniforms: Lu(Pr.backgroundCube.uniforms), vertexShader: Pr.backgroundCube.vertexShader, fragmentShader: Pr.backgroundCube.fragmentShader, side: Ei, depthTest: !1, depthWrite: !1, fog: !1 })), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function (P, R, E) { this.matrixWorld.copyPosition(E.matrixWorld) }, Object.defineProperty(d.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(d)), d.material.uniforms.envMap.value = w, d.material.uniforms.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, d.material.toneMapped = w.encoding !== Ct, (h !== w || p !== w.version || m !== n.toneMapping) && (d.material.needsUpdate = !0, h = w, p = w.version, m = n.toneMapping), d.layers.enableAll(), x.unshift(d, d.geometry, d.material, 0, 0, null)) : w && w.isTexture && (f === void 0 && (f = new Tn(new Wu(2, 2), new ss({ name: "BackgroundMaterial", uniforms: Lu(Pr.background.uniforms), vertexShader: Pr.background.vertexShader, fragmentShader: Pr.background.fragmentShader, side: is, depthTest: !1, depthWrite: !1, fog: !1 })), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(f)), f.material.uniforms.t2D.value = w, f.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, f.material.toneMapped = w.encoding !== Ct, w.matrixAutoUpdate === !0 && w.updateMatrix(), f.material.uniforms.uvTransform.value.copy(w.matrix), (h !== w || p !== w.version || m !== n.toneMapping) && (f.material.needsUpdate = !0, h = w, p = w.version, m = n.toneMapping), f.layers.enableAll(), x.unshift(f, f.geometry, f.material, 0, 0, null)) } function y(x, A) { x.getRGB(dp, vB(n)), i.buffers.color.setClear(dp.r, dp.g, dp.b, A, o) } return { getClearColor: function () { return a }, setClearColor: function (x, A = 1) { a.set(x), l = A, y(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (x) { l = x, y(a, l) }, render: v } } function XU(n, e, t, i) { const r = n.getParameter(34921), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, a = {}, l = x(null); let f = l, d = !1; function h(G, K, ne, oe, N) { let V = !1; if (o) { const Y = y(oe, ne, K); f !== Y && (f = Y, m(f.object)), V = A(G, oe, ne, N), V && _(G, oe, ne, N) } else { const Y = K.wireframe === !0; (f.geometry !== oe.id || f.program !== ne.id || f.wireframe !== Y) && (f.geometry = oe.id, f.program = ne.id, f.wireframe = Y, V = !0) } N !== null && t.update(N, 34963), (V || d) && (d = !1, E(G, K, ne, oe), N !== null && n.bindBuffer(34963, t.get(N).buffer)) } function p() { return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES() } function m(G) { return i.isWebGL2 ? n.bindVertexArray(G) : s.bindVertexArrayOES(G) } function v(G) { return i.isWebGL2 ? n.deleteVertexArray(G) : s.deleteVertexArrayOES(G) } function y(G, K, ne) { const oe = ne.wireframe === !0; let N = a[G.id]; N === void 0 && (N = {}, a[G.id] = N); let V = N[K.id]; V === void 0 && (V = {}, N[K.id] = V); let Y = V[oe]; return Y === void 0 && (Y = x(p()), V[oe] = Y), Y } function x(G) { const K = [], ne = [], oe = []; for (let N = 0; N < r; N++)K[N] = 0, ne[N] = 0, oe[N] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: K, enabledAttributes: ne, attributeDivisors: oe, object: G, attributes: {}, index: null } } function A(G, K, ne, oe) { const N = f.attributes, V = K.attributes; let Y = 0; const re = ne.getAttributes(); for (const j in re) if (re[j].location >= 0) { const ve = N[j]; let Ae = V[j]; if (Ae === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (Ae = G.instanceMatrix), j === "instanceColor" && G.instanceColor && (Ae = G.instanceColor)), ve === void 0 || ve.attribute !== Ae || Ae && ve.data !== Ae.data) return !0; Y++ } return f.attributesNum !== Y || f.index !== oe } function _(G, K, ne, oe) { const N = {}, V = K.attributes; let Y = 0; const re = ne.getAttributes(); for (const j in re) if (re[j].location >= 0) { let ve = V[j]; ve === void 0 && (j === "instanceMatrix" && G.instanceMatrix && (ve = G.instanceMatrix), j === "instanceColor" && G.instanceColor && (ve = G.instanceColor)); const Ae = {}; Ae.attribute = ve, ve && ve.data && (Ae.data = ve.data), N[j] = Ae, Y++ } f.attributes = N, f.attributesNum = Y, f.index = oe } function w() { const G = f.newAttributes; for (let K = 0, ne = G.length; K < ne; K++)G[K] = 0 } function S(G) { T(G, 0) } function T(G, K) { const ne = f.newAttributes, oe = f.enabledAttributes, N = f.attributeDivisors; ne[G] = 1, oe[G] === 0 && (n.enableVertexAttribArray(G), oe[G] = 1), N[G] !== K && ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](G, K), N[G] = K) } function P() { const G = f.newAttributes, K = f.enabledAttributes; for (let ne = 0, oe = K.length; ne < oe; ne++)K[ne] !== G[ne] && (n.disableVertexAttribArray(ne), K[ne] = 0) } function R(G, K, ne, oe, N, V) { i.isWebGL2 === !0 && (ne === 5124 || ne === 5125) ? n.vertexAttribIPointer(G, K, ne, N, V) : n.vertexAttribPointer(G, K, ne, oe, N, V) } function E(G, K, ne, oe) { if (i.isWebGL2 === !1 && (G.isInstancedMesh || oe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; w(); const N = oe.attributes, V = ne.getAttributes(), Y = K.defaultAttributeValues; for (const re in V) { const j = V[re]; if (j.location >= 0) { let ie = N[re]; if (ie === void 0 && (re === "instanceMatrix" && G.instanceMatrix && (ie = G.instanceMatrix), re === "instanceColor" && G.instanceColor && (ie = G.instanceColor)), ie !== void 0) { const ve = ie.normalized, Ae = ie.itemSize, $ = t.get(ie); if ($ === void 0) continue; const Oe = $.buffer, ke = $.type, He = $.bytesPerElement; if (ie.isInterleavedBufferAttribute) { const Me = ie.data, De = Me.stride, de = ie.offset; if (Me.isInstancedInterleavedBuffer) { for (let ae = 0; ae < j.locationSize; ae++)T(j.location + ae, Me.meshPerAttribute); G.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = Me.meshPerAttribute * Me.count) } else for (let ae = 0; ae < j.locationSize; ae++)S(j.location + ae); n.bindBuffer(34962, Oe); for (let ae = 0; ae < j.locationSize; ae++)R(j.location + ae, Ae / j.locationSize, ke, ve, De * He, (de + Ae / j.locationSize * ae) * He) } else { if (ie.isInstancedBufferAttribute) { for (let Me = 0; Me < j.locationSize; Me++)T(j.location + Me, ie.meshPerAttribute); G.isInstancedMesh !== !0 && oe._maxInstanceCount === void 0 && (oe._maxInstanceCount = ie.meshPerAttribute * ie.count) } else for (let Me = 0; Me < j.locationSize; Me++)S(j.location + Me); n.bindBuffer(34962, Oe); for (let Me = 0; Me < j.locationSize; Me++)R(j.location + Me, Ae / j.locationSize, ke, ve, Ae * He, Ae / j.locationSize * Me * He) } } else if (Y !== void 0) { const ve = Y[re]; if (ve !== void 0) switch (ve.length) { case 2: n.vertexAttrib2fv(j.location, ve); break; case 3: n.vertexAttrib3fv(j.location, ve); break; case 4: n.vertexAttrib4fv(j.location, ve); break; default: n.vertexAttrib1fv(j.location, ve) } } } } P() } function B() { q(); for (const G in a) { const K = a[G]; for (const ne in K) { const oe = K[ne]; for (const N in oe) v(oe[N].object), delete oe[N]; delete K[ne] } delete a[G] } } function L(G) { if (a[G.id] === void 0) return; const K = a[G.id]; for (const ne in K) { const oe = K[ne]; for (const N in oe) v(oe[N].object), delete oe[N]; delete K[ne] } delete a[G.id] } function U(G) { for (const K in a) { const ne = a[K]; if (ne[G.id] === void 0) continue; const oe = ne[G.id]; for (const N in oe) v(oe[N].object), delete oe[N]; delete ne[G.id] } } function q() { W(), d = !0, f !== l && (f = l, m(f.object)) } function W() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: h, reset: q, resetDefaultState: W, dispose: B, releaseStatesOfGeometry: L, releaseStatesOfProgram: U, initAttributes: w, enableAttribute: S, disableUnusedAttributes: P } } function YU(n, e, t, i) { const r = i.isWebGL2; let s; function o(f) { s = f } function a(f, d) { n.drawArrays(s, f, d), t.update(d, s, 1) } function l(f, d, h) { if (h === 0) return; let p, m; if (r) p = n, m = "drawArraysInstanced"; else if (p = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", p === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } p[m](s, f, d, h), t.update(d, s, h) } this.setMode = o, this.render = a, this.renderInstances = l } function KU(n, e, t) { let i; function r() { if (i !== void 0) return i; if (e.has("EXT_texture_filter_anisotropic") === !0) { const R = e.get("EXT_texture_filter_anisotropic"); i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i } function s(R) { if (R === "highp") { if (n.getShaderPrecisionFormat(35633, 36338).precision > 0 && n.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; R = "mediump" } return R === "mediump" && n.getShaderPrecisionFormat(35633, 36337).precision > 0 && n.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext; let a = t.precision !== void 0 ? t.precision : "highp"; const l = s(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); const f = o || e.has("WEBGL_draw_buffers"), d = t.logarithmicDepthBuffer === !0, h = n.getParameter(34930), p = n.getParameter(35660), m = n.getParameter(3379), v = n.getParameter(34076), y = n.getParameter(34921), x = n.getParameter(36347), A = n.getParameter(36348), _ = n.getParameter(36349), w = p > 0, S = o || e.has("OES_texture_float"), T = w && S, P = o ? n.getParameter(36183) : 0; return { isWebGL2: o, drawBuffers: f, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: d, maxTextures: h, maxVertexTextures: p, maxTextureSize: m, maxCubemapSize: v, maxAttributes: y, maxVertexUniforms: x, maxVaryings: A, maxFragmentUniforms: _, vertexTextures: w, floatFragmentTextures: S, floatVertexTextures: T, maxSamples: P } } function QU(n) { const e = this; let t = null, i = 0, r = !1, s = !1; const o = new go, a = new li, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (h, p) { const m = h.length !== 0 || p || i !== 0 || r; return r = p, i = h.length, m }, this.beginShadows = function () { s = !0, d(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (h, p) { t = d(h, p, 0) }, this.setState = function (h, p, m) { const v = h.clippingPlanes, y = h.clipIntersection, x = h.clipShadows, A = n.get(h); if (!r || v === null || v.length === 0 || s && !x) s ? d(null) : f(); else { const _ = s ? 0 : i, w = _ * 4; let S = A.clippingState || null; l.value = S, S = d(v, p, w, m); for (let T = 0; T !== w; ++T)S[T] = t[T]; A.clippingState = S, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += _ } }; function f() { l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 } function d(h, p, m, v) { const y = h !== null ? h.length : 0; let x = null; if (y !== 0) { if (x = l.value, v !== !0 || x === null) { const A = m + y * 4, _ = p.matrixWorldInverse; a.getNormalMatrix(_), (x === null || x.length < A) && (x = new Float32Array(A)); for (let w = 0, S = m; w !== y; ++w, S += 4)o.copy(h[w]).applyMatrix4(_, a), o.normal.toArray(x, S), x[S + 3] = o.constant } l.value = x, l.needsUpdate = !0 } return e.numPlanes = y, e.numIntersection = 0, x } } function ZU(n) { let e = new WeakMap; function t(o, a) { return a === Uf ? o.mapping = Oo : a === zf && (o.mapping = ko), o } function i(o) { if (o && o.isTexture && o.isRenderTargetTexture === !1) { const a = o.mapping; if (a === Uf || a === zf) if (e.has(o)) { const l = e.get(o).texture; return t(l, o.mapping) } else { const l = o.image; if (l && l.height > 0) { const f = new jA(l.height / 2); return f.fromEquirectangularTexture(n, o), e.set(o, f), o.addEventListener("dispose", r), t(f.texture, o.mapping) } else return null } } return o } function r(o) { const a = o.target; a.removeEventListener("dispose", r); const l = e.get(a); l !== void 0 && (e.delete(a), l.dispose()) } function s() { e = new WeakMap } return { get: i, dispose: s } } class Ir extends hd { constructor(e = -1, t = 1, i = 1, r = -1, s = .1, o = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, r, s, o) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let s = i - e, o = i + e, a = r + t, l = r - t; if (this.view !== null && this.view.enabled) { const f = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s += f * this.view.offsetX, o = s + f * this.view.width, a -= d * this.view.offsetY, l = a - d * this.view.height } this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const ou = 4, dC = [.125, .215, .35, .446, .526, .582], ba = 20, Hy = new Ir, hC = new Le; let Vy = null; const wa = (1 + Math.sqrt(5)) / 2, Ul = 1 / wa, pC = [new I(1, 1, 1), new I(-1, 1, 1), new I(1, 1, -1), new I(-1, 1, -1), new I(0, wa, Ul), new I(0, wa, -Ul), new I(Ul, 0, wa), new I(-Ul, 0, wa), new I(wa, Ul, 0), new I(-wa, Ul, 0)]; class qx { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, i = .1, r = 100) { Vy = this._renderer.getRenderTarget(), this._setSize(256); const s = this._allocateTargets(); return s.depthBuffer = !0, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = yC(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = gC(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(Vy), e.scissorTest = !1, hp(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === Oo || e.mapping === ko ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Vy = this._renderer.getRenderTarget(); const i = t || this._allocateTargets(); return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: en, minFilter: en, generateMipmaps: !1, type: Pu, format: Ai, encoding: Vs, depthBuffer: !1 }, r = mC(e, t, i); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = mC(e, t, i); const { _lodMax: s } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = qU(s)), this._blurMaterial = $U(s, e, t) } return r } _compileMaterial(e) { const t = new Tn(this._lodPlanes[0], e); this._renderer.compile(t, Hy) } _sceneToCubeUV(e, t, i, r) { const a = new Gt(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], f = [1, 1, 1, -1, -1, -1], d = this._renderer, h = d.autoClear, p = d.toneMapping; d.getClearColor(hC), d.toneMapping = Dr, d.autoClear = !1; const m = new Oi({ name: "PMREM.Background", side: Ei, depthWrite: !1, depthTest: !1 }), v = new Tn(new Ko, m); let y = !1; const x = e.background; x ? x.isColor && (m.color.copy(x), e.background = null, y = !0) : (m.color.copy(hC), y = !0); for (let A = 0; A < 6; A++) { const _ = A % 3; _ === 0 ? (a.up.set(0, l[A], 0), a.lookAt(f[A], 0, 0)) : _ === 1 ? (a.up.set(0, 0, l[A]), a.lookAt(0, f[A], 0)) : (a.up.set(0, l[A], 0), a.lookAt(0, 0, f[A])); const w = this._cubeSize; hp(r, _ * w, A > 2 ? w : 0, w, w), d.setRenderTarget(r), y && d.render(v, a), d.render(e, a) } v.geometry.dispose(), v.material.dispose(), d.toneMapping = p, d.autoClear = h, e.background = x } _textureToCubeUV(e, t) { const i = this._renderer, r = e.mapping === Oo || e.mapping === ko; r ? (this._cubemapMaterial === null && (this._cubemapMaterial = yC()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = gC()); const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Tn(this._lodPlanes[0], s), a = s.uniforms; a.envMap.value = e; const l = this._cubeSize; hp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Hy) } _applyPMREM(e) { const t = this._renderer, i = t.autoClear; t.autoClear = !1; for (let r = 1; r < this._lodPlanes.length; r++) { const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = pC[(r - 1) % pC.length]; this._blur(e, r - 1, r, s, o) } t.autoClear = i } _blur(e, t, i, r, s) { const o = this._pingPongRenderTarget; this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s) } _halfBlur(e, t, i, r, s, o, a) { const l = this._renderer, f = this._blurMaterial; o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const d = 3, h = new Tn(this._lodPlanes[r], f), p = f.uniforms, m = this._sizeLods[i] - 1, v = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * ba - 1), y = s / v, x = isFinite(s) ? 1 + Math.floor(d * y) : ba; x > ba && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${ba}`); const A = []; let _ = 0; for (let R = 0; R < ba; ++R) { const E = R / y, B = Math.exp(-E * E / 2); A.push(B), R === 0 ? _ += B : R < x && (_ += 2 * B) } for (let R = 0; R < A.length; R++)A[R] = A[R] / _; p.envMap.value = e.texture, p.samples.value = x, p.weights.value = A, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a); const { _lodMax: w } = this; p.dTheta.value = v, p.mipInt.value = w - i; const S = this._sizeLods[r], T = 3 * S * (r > w - ou ? r - w + ou : 0), P = 4 * (this._cubeSize - S); hp(t, T, P, 3 * S, 2 * S), l.setRenderTarget(t), l.render(h, Hy) } } function qU(n) { const e = [], t = [], i = []; let r = n; const s = n - ou + 1 + dC.length; for (let o = 0; o < s; o++) { const a = Math.pow(2, r); t.push(a); let l = 1 / a; o > n - ou ? l = dC[o - n + ou - 1] : o === 0 && (l = 0), i.push(l); const f = 1 / (a - 2), d = -f, h = 1 + f, p = [d, d, h, d, h, h, d, d, h, h, d, h], m = 6, v = 6, y = 3, x = 2, A = 1, _ = new Float32Array(y * v * m), w = new Float32Array(x * v * m), S = new Float32Array(A * v * m); for (let P = 0; P < m; P++) { const R = P % 3 * 2 / 3 - 1, E = P > 2 ? 0 : -1, B = [R, E, 0, R + 2 / 3, E, 0, R + 2 / 3, E + 1, 0, R, E, 0, R + 2 / 3, E + 1, 0, R, E + 1, 0]; _.set(B, y * v * P), w.set(p, x * v * P); const L = [P, P, P, P, P, P]; S.set(L, A * v * P) } const T = new ut; T.setAttribute("position", new It(_, y)), T.setAttribute("uv", new It(w, x)), T.setAttribute("faceIndex", new It(S, A)), e.push(T), r > ou && r-- } return { lodPlanes: e, sizeLods: t, sigmas: i } } function mC(n, e, t) { const i = new Nr(n, e, t); return i.texture.mapping = Vu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i } function hp(n, e, t, i, r) { n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r) } function $U(n, e, t) {
	const i = new Float32Array(ba), r = new I(0, 1, 0); return new ss({
		name: "SphericalGaussianBlur", defines: { n: ba, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: JA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Fs, depthTest: !1, depthWrite: !1
	})
} function gC() {
	return new ss({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: JA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Fs, depthTest: !1, depthWrite: !1
	})
} function yC() {
	return new ss({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: JA(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Fs, depthTest: !1, depthWrite: !1
	})
} function JA() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function e4(n) { let e = new WeakMap, t = null; function i(a) { if (a && a.isTexture) { const l = a.mapping, f = l === Uf || l === zf, d = l === Oo || l === ko; if (f || d) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let h = e.get(a); return t === null && (t = new qx(n)), h = f ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture } else { if (e.has(a)) return e.get(a).texture; { const h = a.image; if (f && h && h.height > 0 || d && h && r(h)) { t === null && (t = new qx(n)); const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a); return e.set(a, p), a.addEventListener("dispose", s), p.texture } else return null } } } return a } function r(a) { let l = 0; const f = 6; for (let d = 0; d < f; d++)a[d] !== void 0 && l++; return l === f } function s(a) { const l = a.target; l.removeEventListener("dispose", s); const f = e.get(l); f !== void 0 && (e.delete(l), f.dispose()) } function o() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: i, dispose: o } } function t4(n) { const e = {}; function t(i) { if (e[i] !== void 0) return e[i]; let r; switch (i) { case "WEBGL_depth_texture": r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = n.getExtension(i) }return e[i] = r, r } return { has: function (i) { return t(i) !== null }, init: function (i) { i.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (i) { const r = t(i); return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r } } } function n4(n, e, t, i) { const r = {}, s = new WeakMap; function o(h) { const p = h.target; p.index !== null && e.remove(p.index); for (const v in p.attributes) e.remove(p.attributes[v]); p.removeEventListener("dispose", o), delete r[p.id]; const m = s.get(p); m && (e.remove(m), s.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries-- } function a(h, p) { return r[p.id] === !0 || (p.addEventListener("dispose", o), r[p.id] = !0, t.memory.geometries++), p } function l(h) { const p = h.attributes; for (const v in p) e.update(p[v], 34962); const m = h.morphAttributes; for (const v in m) { const y = m[v]; for (let x = 0, A = y.length; x < A; x++)e.update(y[x], 34962) } } function f(h) { const p = [], m = h.index, v = h.attributes.position; let y = 0; if (m !== null) { const _ = m.array; y = m.version; for (let w = 0, S = _.length; w < S; w += 3) { const T = _[w + 0], P = _[w + 1], R = _[w + 2]; p.push(T, P, P, R, R, T) } } else { const _ = v.array; y = v.version; for (let w = 0, S = _.length / 3 - 1; w < S; w += 3) { const T = w + 0, P = w + 1, R = w + 2; p.push(T, P, P, R, R, T) } } const x = new (gB(p) ? VA : HA)(p, 1); x.version = y; const A = s.get(h); A && e.remove(A), s.set(h, x) } function d(h) { const p = s.get(h); if (p) { const m = h.index; m !== null && p.version < m.version && f(h) } else f(h); return s.get(h) } return { get: a, update: l, getWireframeAttribute: d } } function i4(n, e, t, i) { const r = i.isWebGL2; let s; function o(p) { s = p } let a, l; function f(p) { a = p.type, l = p.bytesPerElement } function d(p, m) { n.drawElements(s, m, a, p * l), t.update(m, s, 1) } function h(p, m, v) { if (v === 0) return; let y, x; if (r) y = n, x = "drawElementsInstanced"; else if (y = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", y === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } y[x](s, m, a, p * l, v), t.update(m, s, v) } this.setMode = o, this.setIndex = f, this.render = d, this.renderInstances = h } function r4(n) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function i(s, o, a) { switch (t.calls++, o) { case 4: t.triangles += a * (s / 3); break; case 1: t.lines += a * (s / 2); break; case 3: t.lines += a * (s - 1); break; case 2: t.lines += a * s; break; case 0: t.points += a * s; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", o); break } } function r() { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: r, update: i } } function s4(n, e) { return n[0] - e[0] } function o4(n, e) { return Math.abs(e[1]) - Math.abs(n[1]) } function a4(n, e, t) { const i = {}, r = new Float32Array(8), s = new WeakMap, o = new Nt, a = []; for (let f = 0; f < 8; f++)a[f] = [f, 0]; function l(f, d, h, p) { const m = f.morphTargetInfluences; if (e.isWebGL2 === !0) { const y = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color, x = y !== void 0 ? y.length : 0; let A = s.get(d); if (A === void 0 || A.count !== x) { let ne = function () { G.dispose(), s.delete(d), d.removeEventListener("dispose", ne) }; var v = ne; A !== void 0 && A.texture.dispose(); const S = d.morphAttributes.position !== void 0, T = d.morphAttributes.normal !== void 0, P = d.morphAttributes.color !== void 0, R = d.morphAttributes.position || [], E = d.morphAttributes.normal || [], B = d.morphAttributes.color || []; let L = 0; S === !0 && (L = 1), T === !0 && (L = 2), P === !0 && (L = 3); let U = d.attributes.position.count * L, q = 1; U > e.maxTextureSize && (q = Math.ceil(U / e.maxTextureSize), U = e.maxTextureSize); const W = new Float32Array(U * q * 4 * x), G = new Mg(W, U, q, x); G.type = Bs, G.needsUpdate = !0; const K = L * 4; for (let oe = 0; oe < x; oe++) { const N = R[oe], V = E[oe], Y = B[oe], re = U * q * 4 * oe; for (let j = 0; j < N.count; j++) { const ie = j * K; S === !0 && (o.fromBufferAttribute(N, j), W[re + ie + 0] = o.x, W[re + ie + 1] = o.y, W[re + ie + 2] = o.z, W[re + ie + 3] = 0), T === !0 && (o.fromBufferAttribute(V, j), W[re + ie + 4] = o.x, W[re + ie + 5] = o.y, W[re + ie + 6] = o.z, W[re + ie + 7] = 0), P === !0 && (o.fromBufferAttribute(Y, j), W[re + ie + 8] = o.x, W[re + ie + 9] = o.y, W[re + ie + 10] = o.z, W[re + ie + 11] = Y.itemSize === 4 ? o.w : 1) } } A = { count: x, texture: G, size: new pe(U, q) }, s.set(d, A), d.addEventListener("dispose", ne) } let _ = 0; for (let S = 0; S < m.length; S++)_ += m[S]; const w = d.morphTargetsRelative ? 1 : 1 - _; p.getUniforms().setValue(n, "morphTargetBaseInfluence", w), p.getUniforms().setValue(n, "morphTargetInfluences", m), p.getUniforms().setValue(n, "morphTargetsTexture", A.texture, t), p.getUniforms().setValue(n, "morphTargetsTextureSize", A.size) } else { const y = m === void 0 ? 0 : m.length; let x = i[d.id]; if (x === void 0 || x.length !== y) { x = []; for (let T = 0; T < y; T++)x[T] = [T, 0]; i[d.id] = x } for (let T = 0; T < y; T++) { const P = x[T]; P[0] = T, P[1] = m[T] } x.sort(o4); for (let T = 0; T < 8; T++)T < y && x[T][1] ? (a[T][0] = x[T][0], a[T][1] = x[T][1]) : (a[T][0] = Number.MAX_SAFE_INTEGER, a[T][1] = 0); a.sort(s4); const A = d.morphAttributes.position, _ = d.morphAttributes.normal; let w = 0; for (let T = 0; T < 8; T++) { const P = a[T], R = P[0], E = P[1]; R !== Number.MAX_SAFE_INTEGER && E ? (A && d.getAttribute("morphTarget" + T) !== A[R] && d.setAttribute("morphTarget" + T, A[R]), _ && d.getAttribute("morphNormal" + T) !== _[R] && d.setAttribute("morphNormal" + T, _[R]), r[T] = E, w += E) : (A && d.hasAttribute("morphTarget" + T) === !0 && d.deleteAttribute("morphTarget" + T), _ && d.hasAttribute("morphNormal" + T) === !0 && d.deleteAttribute("morphNormal" + T), r[T] = 0) } const S = d.morphTargetsRelative ? 1 : 1 - w; p.getUniforms().setValue(n, "morphTargetBaseInfluence", S), p.getUniforms().setValue(n, "morphTargetInfluences", r) } } return { update: l } } function l4(n, e, t, i) { let r = new WeakMap; function s(l) { const f = i.render.frame, d = l.geometry, h = e.get(l, d); return r.get(h) !== f && (e.update(h), r.set(h, f)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), t.update(l.instanceMatrix, 34962), l.instanceColor !== null && t.update(l.instanceColor, 34962)), h } function o() { r = new WeakMap } function a(l) { const f = l.target; f.removeEventListener("dispose", a), t.remove(f.instanceMatrix), f.instanceColor !== null && t.remove(f.instanceColor) } return { update: s, dispose: o } } const _B = new Qt, MB = new Mg, wB = new GA, SB = new pd, vC = [], xC = [], AC = new Float32Array(16), _C = new Float32Array(9), MC = new Float32Array(4); function ju(n, e, t) { const i = n[0]; if (i <= 0 || i > 0) return n; const r = e * t; let s = vC[r]; if (s === void 0 && (s = new Float32Array(r), vC[r] = s), e !== 0) { i.toArray(s, 0); for (let o = 1, a = 0; o !== e; ++o)a += t, n[o].toArray(s, a) } return s } function bn(n, e) { if (n.length !== e.length) return !1; for (let t = 0, i = n.length; t < i; t++)if (n[t] !== e[t]) return !1; return !0 } function Pn(n, e) { for (let t = 0, i = e.length; t < i; t++)n[t] = e[t] } function Sg(n, e) { let t = xC[e]; t === void 0 && (t = new Int32Array(e), xC[e] = t); for (let i = 0; i !== e; ++i)t[i] = n.allocateTextureUnit(); return t } function u4(n, e) { const t = this.cache; t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e) } function c4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (bn(t, e)) return; n.uniform2fv(this.addr, e), Pn(t, e) } } function f4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (bn(t, e)) return; n.uniform3fv(this.addr, e), Pn(t, e) } } function d4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (bn(t, e)) return; n.uniform4fv(this.addr, e), Pn(t, e) } } function h4(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (bn(t, e)) return; n.uniformMatrix2fv(this.addr, !1, e), Pn(t, e) } else { if (bn(t, i)) return; MC.set(i), n.uniformMatrix2fv(this.addr, !1, MC), Pn(t, i) } } function p4(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (bn(t, e)) return; n.uniformMatrix3fv(this.addr, !1, e), Pn(t, e) } else { if (bn(t, i)) return; _C.set(i), n.uniformMatrix3fv(this.addr, !1, _C), Pn(t, i) } } function m4(n, e) { const t = this.cache, i = e.elements; if (i === void 0) { if (bn(t, e)) return; n.uniformMatrix4fv(this.addr, !1, e), Pn(t, e) } else { if (bn(t, i)) return; AC.set(i), n.uniformMatrix4fv(this.addr, !1, AC), Pn(t, i) } } function g4(n, e) { const t = this.cache; t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e) } function y4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (bn(t, e)) return; n.uniform2iv(this.addr, e), Pn(t, e) } } function v4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (bn(t, e)) return; n.uniform3iv(this.addr, e), Pn(t, e) } } function x4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (bn(t, e)) return; n.uniform4iv(this.addr, e), Pn(t, e) } } function A4(n, e) { const t = this.cache; t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e) } function _4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (bn(t, e)) return; n.uniform2uiv(this.addr, e), Pn(t, e) } } function M4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (bn(t, e)) return; n.uniform3uiv(this.addr, e), Pn(t, e) } } function w4(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (bn(t, e)) return; n.uniform4uiv(this.addr, e), Pn(t, e) } } function S4(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2D(e || _B, r) } function C4(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || wB, r) } function E4(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || SB, r) } function T4(n, e, t) { const i = this.cache, r = t.allocateTextureUnit(); i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || MB, r) } function b4(n) { switch (n) { case 5126: return u4; case 35664: return c4; case 35665: return f4; case 35666: return d4; case 35674: return h4; case 35675: return p4; case 35676: return m4; case 5124: case 35670: return g4; case 35667: case 35671: return y4; case 35668: case 35672: return v4; case 35669: case 35673: return x4; case 5125: return A4; case 36294: return _4; case 36295: return M4; case 36296: return w4; case 35678: case 36198: case 36298: case 36306: case 35682: return S4; case 35679: case 36299: case 36307: return C4; case 35680: case 36300: case 36308: case 36293: return E4; case 36289: case 36303: case 36311: case 36292: return T4 } } function P4(n, e) { n.uniform1fv(this.addr, e) } function B4(n, e) { const t = ju(e, this.size, 2); n.uniform2fv(this.addr, t) } function R4(n, e) { const t = ju(e, this.size, 3); n.uniform3fv(this.addr, t) } function L4(n, e) { const t = ju(e, this.size, 4); n.uniform4fv(this.addr, t) } function D4(n, e) { const t = ju(e, this.size, 4); n.uniformMatrix2fv(this.addr, !1, t) } function I4(n, e) { const t = ju(e, this.size, 9); n.uniformMatrix3fv(this.addr, !1, t) } function F4(n, e) { const t = ju(e, this.size, 16); n.uniformMatrix4fv(this.addr, !1, t) } function N4(n, e) { n.uniform1iv(this.addr, e) } function O4(n, e) { n.uniform2iv(this.addr, e) } function k4(n, e) { n.uniform3iv(this.addr, e) } function U4(n, e) { n.uniform4iv(this.addr, e) } function z4(n, e) { n.uniform1uiv(this.addr, e) } function G4(n, e) { n.uniform2uiv(this.addr, e) } function H4(n, e) { n.uniform3uiv(this.addr, e) } function V4(n, e) { n.uniform4uiv(this.addr, e) } function W4(n, e, t) { const i = this.cache, r = e.length, s = Sg(t, r); bn(i, s) || (n.uniform1iv(this.addr, s), Pn(i, s)); for (let o = 0; o !== r; ++o)t.setTexture2D(e[o] || _B, s[o]) } function j4(n, e, t) { const i = this.cache, r = e.length, s = Sg(t, r); bn(i, s) || (n.uniform1iv(this.addr, s), Pn(i, s)); for (let o = 0; o !== r; ++o)t.setTexture3D(e[o] || wB, s[o]) } function J4(n, e, t) { const i = this.cache, r = e.length, s = Sg(t, r); bn(i, s) || (n.uniform1iv(this.addr, s), Pn(i, s)); for (let o = 0; o !== r; ++o)t.setTextureCube(e[o] || SB, s[o]) } function X4(n, e, t) { const i = this.cache, r = e.length, s = Sg(t, r); bn(i, s) || (n.uniform1iv(this.addr, s), Pn(i, s)); for (let o = 0; o !== r; ++o)t.setTexture2DArray(e[o] || MB, s[o]) } function Y4(n) { switch (n) { case 5126: return P4; case 35664: return B4; case 35665: return R4; case 35666: return L4; case 35674: return D4; case 35675: return I4; case 35676: return F4; case 5124: case 35670: return N4; case 35667: case 35671: return O4; case 35668: case 35672: return k4; case 35669: case 35673: return U4; case 5125: return z4; case 36294: return G4; case 36295: return H4; case 36296: return V4; case 35678: case 36198: case 36298: case 36306: case 35682: return W4; case 35679: case 36299: case 36307: return j4; case 35680: case 36300: case 36308: case 36293: return J4; case 36289: case 36303: case 36311: case 36292: return X4 } } class K4 { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = b4(t.type) } } class Q4 { constructor(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = Y4(t.type) } } class Z4 { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, i) { const r = this.seq; for (let s = 0, o = r.length; s !== o; ++s) { const a = r[s]; a.setValue(e, t[a.id], i) } } } const Wy = /(\w+)(\])?(\[|\.)?/g; function wC(n, e) { n.seq.push(e), n.map[e.id] = e } function q4(n, e, t) { const i = n.name, r = i.length; for (Wy.lastIndex = 0; ;) { const s = Wy.exec(i), o = Wy.lastIndex; let a = s[1]; const l = s[2] === "]", f = s[3]; if (l && (a = a | 0), f === void 0 || f === "[" && o + 2 === r) { wC(t, f === void 0 ? new K4(a, n, e) : new Q4(a, n, e)); break } else { let h = t.map[a]; h === void 0 && (h = new Z4(a), wC(t, h)), t = h } } } class cm { constructor(e, t) { this.seq = [], this.map = {}; const i = e.getProgramParameter(t, 35718); for (let r = 0; r < i; ++r) { const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name); q4(s, o, this) } } setValue(e, t, i, r) { const s = this.map[t]; s !== void 0 && s.setValue(e, i, r) } setOptional(e, t, i) { const r = t[i]; r !== void 0 && this.setValue(e, i, r) } static upload(e, t, i, r) { for (let s = 0, o = t.length; s !== o; ++s) { const a = t[s], l = i[a.id]; l.needsUpdate !== !1 && a.setValue(e, l.value, r) } } static seqWithValue(e, t) { const i = []; for (let r = 0, s = e.length; r !== s; ++r) { const o = e[r]; o.id in t && i.push(o) } return i } } function SC(n, e, t) { const i = n.createShader(e); return n.shaderSource(i, t), n.compileShader(i), i } let $4 = 0; function ez(n, e) {
	const t = n.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length); for (let o = r; o < s; o++) { const a = o + 1; i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`) } return i.join(`
`)
} function tz(n) { switch (n) { case Vs: return ["Linear", "( value )"]; case Ct: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", n), ["Linear", "( value )"] } } function CC(n, e, t) {
	const i = n.getShaderParameter(e, 35713), r = n.getShaderInfoLog(e).trim(); if (i && r === "") return ""; const s = /ERROR: 0:(\d+)/.exec(r); if (s) {
		const o = parseInt(s[1]); return t.toUpperCase() + `

`+ r + `

`+ ez(n.getShaderSource(e), o)
	} else return r
} function nz(n, e) { const t = tz(e); return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }" } function iz(n, e) { let t; switch (e) { case HP: t = "Linear"; break; case VP: t = "Reinhard"; break; case WP: t = "OptimizedCineon"; break; case IA: t = "ACESFilmic"; break; case jP: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function rz(n) {
	return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter($c).join(`
`)
} function sz(n) {
	const e = []; for (const t in n) { const i = n[t]; i !== !1 && e.push("#define " + t + " " + i) } return e.join(`
`)
} function oz(n, e) { const t = {}, i = n.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const s = n.getActiveAttrib(e, r), o = s.name; let a = 1; s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = { type: s.type, location: n.getAttribLocation(e, o), locationSize: a } } return t } function $c(n) { return n !== "" } function EC(n, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function TC(n, e) { return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const az = /^[ \t]*#include +<([\w\d./]+)>/gm; function $x(n) { return n.replace(az, lz) } function lz(n, e) { const t = pt[e]; if (t === void 0) throw new Error("Can not resolve #include <" + e + ">"); return $x(t) } const uz = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function bC(n) { return n.replace(uz, cz) } function cz(n, e, t, i) { let r = ""; for (let s = parseInt(e); s < parseInt(t); s++)r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return r } function PC(n) {
	let e = "precision " + n.precision + ` float;
precision `+ n.precision + " int;"; return n.precision === "highp" ? e += `
#define HIGH_PRECISION`: n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
} function fz(n) { let e = "SHADOWMAP_TYPE_BASIC"; return n.shadowMapType === vg ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === ff ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Da && (e = "SHADOWMAP_TYPE_VSM"), e } function dz(n) { let e = "ENVMAP_TYPE_CUBE"; if (n.envMap) switch (n.envMapMode) { case Oo: case ko: e = "ENVMAP_TYPE_CUBE"; break; case Vu: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function hz(n) { let e = "ENVMAP_MODE_REFLECTION"; if (n.envMap) switch (n.envMapMode) { case ko: e = "ENVMAP_MODE_REFRACTION"; break }return e } function pz(n) { let e = "ENVMAP_BLENDING_NONE"; if (n.envMap) switch (n.combine) { case fd: e = "ENVMAP_BLENDING_MULTIPLY"; break; case zP: e = "ENVMAP_BLENDING_MIX"; break; case GP: e = "ENVMAP_BLENDING_ADD"; break }return e } function mz(n) { const e = n.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, i = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t } } function gz(n, e, t, i) {
	const r = n.getContext(), s = t.defines; let o = t.vertexShader, a = t.fragmentShader; const l = fz(t), f = dz(t), d = hz(t), h = pz(t), p = mz(t), m = t.isWebGL2 ? "" : rz(t), v = sz(s), y = r.createProgram(); let x, A, _ = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (x = [v].filter($c).join(`
`), x.length > 0 && (x += `
`), A = [m, v].filter($c).join(`
`), A.length > 0 && (A += `
`)) : (x = [PC(t), "#define SHADER_NAME " + t.shaderName, v, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + d : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter($c).join(`
`), A = [m, PC(t), "#define SHADER_NAME " + t.shaderName, v, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + d : "", t.envMap ? "#define " + h : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Dr ? "#define TONE_MAPPING" : "", t.toneMapping !== Dr ? pt.tonemapping_pars_fragment : "", t.toneMapping !== Dr ? iz("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", pt.encodings_pars_fragment, nz("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter($c).join(`
`)), o = $x(o), o = EC(o, t), o = TC(o, t), a = $x(a), a = EC(a, t), a = TC(a, t), o = bC(o), a = bC(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, x = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ x, A = ["#define varying in", t.glslVersion === Qx ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Qx ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ A); const w = _ + x + o, S = _ + A + a, T = SC(r, 35633, w), P = SC(r, 35632, S); if (r.attachShader(y, T), r.attachShader(y, P), t.index0AttributeName !== void 0 ? r.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), n.debug.checkShaderErrors) {
		const B = r.getProgramInfoLog(y).trim(), L = r.getShaderInfoLog(T).trim(), U = r.getShaderInfoLog(P).trim(); let q = !0, W = !0; if (r.getProgramParameter(y, 35714) === !1) {
			q = !1; const G = CC(r, T, "vertex"), K = CC(r, P, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(y, 35715) + `

Program Info Log: `+ B + `
`+ G + `
`+ K)
		} else B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (L === "" || U === "") && (W = !1); W && (this.diagnostics = { runnable: q, programLog: B, vertexShader: { log: L, prefix: x }, fragmentShader: { log: U, prefix: A } })
	} r.deleteShader(T), r.deleteShader(P); let R; this.getUniforms = function () { return R === void 0 && (R = new cm(r, y)), R }; let E; return this.getAttributes = function () { return E === void 0 && (E = oz(r, y)), E }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = t.shaderName, this.id = $4++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = T, this.fragmentShader = P, this
} let yz = 0; class vz { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e); return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let i = t.get(e); return i === void 0 && (i = new Set, t.set(e, i)), i } _getShaderStage(e) { const t = this.shaderCache; let i = t.get(e); return i === void 0 && (i = new xz(e), t.set(e, i)), i } } class xz { constructor(e) { this.id = yz++, this.code = e, this.usedTimes = 0 } } function Az(n, e, t, i, r, s, o) { const a = new Ja, l = new vz, f = [], d = r.isWebGL2, h = r.logarithmicDepthBuffer, p = r.vertexTextures; let m = r.precision; const v = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function y(E, B, L, U, q) { const W = U.fog, G = q.geometry, K = E.isMeshStandardMaterial ? U.environment : null, ne = (E.isMeshStandardMaterial ? t : e).get(E.envMap || K), oe = ne && ne.mapping === Vu ? ne.image.height : null, N = v[E.type]; E.precision !== null && (m = r.getMaxPrecision(E.precision), m !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", m, "instead.")); const V = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color, Y = V !== void 0 ? V.length : 0; let re = 0; G.morphAttributes.position !== void 0 && (re = 1), G.morphAttributes.normal !== void 0 && (re = 2), G.morphAttributes.color !== void 0 && (re = 3); let j, ie, ve, Ae; if (N) { const De = Pr[N]; j = De.vertexShader, ie = De.fragmentShader } else j = E.vertexShader, ie = E.fragmentShader, l.update(E), ve = l.getVertexShaderID(E), Ae = l.getFragmentShaderID(E); const $ = n.getRenderTarget(), Oe = E.alphaTest > 0, ke = E.clearcoat > 0, He = E.iridescence > 0; return { isWebGL2: d, shaderID: N, shaderName: E.type, vertexShader: j, fragmentShader: ie, defines: E.defines, customVertexShaderID: ve, customFragmentShaderID: Ae, isRawShaderMaterial: E.isRawShaderMaterial === !0, glslVersion: E.glslVersion, precision: m, instancing: q.isInstancedMesh === !0, instancingColor: q.isInstancedMesh === !0 && q.instanceColor !== null, supportsVertexTextures: p, outputEncoding: $ === null ? n.outputEncoding : $.isXRRenderTarget === !0 ? $.texture.encoding : Vs, map: !!E.map, matcap: !!E.matcap, envMap: !!ne, envMapMode: ne && ne.mapping, envMapCubeUVHeight: oe, lightMap: !!E.lightMap, aoMap: !!E.aoMap, emissiveMap: !!E.emissiveMap, bumpMap: !!E.bumpMap, normalMap: !!E.normalMap, objectSpaceNormalMap: E.normalMapType === hB, tangentSpaceNormalMap: E.normalMapType === Js, decodeVideoTexture: !!E.map && E.map.isVideoTexture === !0 && E.map.encoding === Ct, clearcoat: ke, clearcoatMap: ke && !!E.clearcoatMap, clearcoatRoughnessMap: ke && !!E.clearcoatRoughnessMap, clearcoatNormalMap: ke && !!E.clearcoatNormalMap, iridescence: He, iridescenceMap: He && !!E.iridescenceMap, iridescenceThicknessMap: He && !!E.iridescenceThicknessMap, displacementMap: !!E.displacementMap, roughnessMap: !!E.roughnessMap, metalnessMap: !!E.metalnessMap, specularMap: !!E.specularMap, specularIntensityMap: !!E.specularIntensityMap, specularColorMap: !!E.specularColorMap, opaque: E.transparent === !1 && E.blending === Ga, alphaMap: !!E.alphaMap, alphaTest: Oe, gradientMap: !!E.gradientMap, sheen: E.sheen > 0, sheenColorMap: !!E.sheenColorMap, sheenRoughnessMap: !!E.sheenRoughnessMap, transmission: E.transmission > 0, transmissionMap: !!E.transmissionMap, thicknessMap: !!E.thicknessMap, combine: E.combine, vertexTangents: !!E.normalMap && !!G.attributes.tangent, vertexColors: E.vertexColors, vertexAlphas: E.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4, vertexUvs: !!E.map || !!E.bumpMap || !!E.normalMap || !!E.specularMap || !!E.alphaMap || !!E.emissiveMap || !!E.roughnessMap || !!E.metalnessMap || !!E.clearcoatMap || !!E.clearcoatRoughnessMap || !!E.clearcoatNormalMap || !!E.iridescenceMap || !!E.iridescenceThicknessMap || !!E.displacementMap || !!E.transmissionMap || !!E.thicknessMap || !!E.specularIntensityMap || !!E.specularColorMap || !!E.sheenColorMap || !!E.sheenRoughnessMap, uvsVertexOnly: !(E.map || E.bumpMap || E.normalMap || E.specularMap || E.alphaMap || E.emissiveMap || E.roughnessMap || E.metalnessMap || E.clearcoatNormalMap || E.iridescenceMap || E.iridescenceThicknessMap || E.transmission > 0 || E.transmissionMap || E.thicknessMap || E.specularIntensityMap || E.specularColorMap || E.sheen > 0 || E.sheenColorMap || E.sheenRoughnessMap) && !!E.displacementMap, fog: !!W, useFog: E.fog === !0, fogExp2: W && W.isFogExp2, flatShading: !!E.flatShading, sizeAttenuation: E.sizeAttenuation, logarithmicDepthBuffer: h, skinning: q.isSkinnedMesh === !0, morphTargets: G.morphAttributes.position !== void 0, morphNormals: G.morphAttributes.normal !== void 0, morphColors: G.morphAttributes.color !== void 0, morphTargetsCount: Y, morphTextureStride: re, numDirLights: B.directional.length, numPointLights: B.point.length, numSpotLights: B.spot.length, numSpotLightMaps: B.spotLightMap.length, numRectAreaLights: B.rectArea.length, numHemiLights: B.hemi.length, numDirLightShadows: B.directionalShadowMap.length, numPointLightShadows: B.pointShadowMap.length, numSpotLightShadows: B.spotShadowMap.length, numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: E.dithering, shadowMapEnabled: n.shadowMap.enabled && L.length > 0, shadowMapType: n.shadowMap.type, toneMapping: E.toneMapped ? n.toneMapping : Dr, physicallyCorrectLights: n.physicallyCorrectLights, premultipliedAlpha: E.premultipliedAlpha, doubleSided: E.side === Br, flipSided: E.side === Ei, useDepthPacking: !!E.depthPacking, depthPacking: E.depthPacking || 0, index0AttributeName: E.index0AttributeName, extensionDerivatives: E.extensions && E.extensions.derivatives, extensionFragDepth: E.extensions && E.extensions.fragDepth, extensionDrawBuffers: E.extensions && E.extensions.drawBuffers, extensionShaderTextureLOD: E.extensions && E.extensions.shaderTextureLOD, rendererExtensionFragDepth: d || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"), customProgramCacheKey: E.customProgramCacheKey() } } function x(E) { const B = []; if (E.shaderID ? B.push(E.shaderID) : (B.push(E.customVertexShaderID), B.push(E.customFragmentShaderID)), E.defines !== void 0) for (const L in E.defines) B.push(L), B.push(E.defines[L]); return E.isRawShaderMaterial === !1 && (A(B, E), _(B, E), B.push(n.outputEncoding)), B.push(E.customProgramCacheKey), B.join() } function A(E, B) { E.push(B.precision), E.push(B.outputEncoding), E.push(B.envMapMode), E.push(B.envMapCubeUVHeight), E.push(B.combine), E.push(B.vertexUvs), E.push(B.fogExp2), E.push(B.sizeAttenuation), E.push(B.morphTargetsCount), E.push(B.morphAttributeCount), E.push(B.numDirLights), E.push(B.numPointLights), E.push(B.numSpotLights), E.push(B.numSpotLightMaps), E.push(B.numHemiLights), E.push(B.numRectAreaLights), E.push(B.numDirLightShadows), E.push(B.numPointLightShadows), E.push(B.numSpotLightShadows), E.push(B.numSpotLightShadowsWithMaps), E.push(B.shadowMapType), E.push(B.toneMapping), E.push(B.numClippingPlanes), E.push(B.numClipIntersection), E.push(B.depthPacking) } function _(E, B) { a.disableAll(), B.isWebGL2 && a.enable(0), B.supportsVertexTextures && a.enable(1), B.instancing && a.enable(2), B.instancingColor && a.enable(3), B.map && a.enable(4), B.matcap && a.enable(5), B.envMap && a.enable(6), B.lightMap && a.enable(7), B.aoMap && a.enable(8), B.emissiveMap && a.enable(9), B.bumpMap && a.enable(10), B.normalMap && a.enable(11), B.objectSpaceNormalMap && a.enable(12), B.tangentSpaceNormalMap && a.enable(13), B.clearcoat && a.enable(14), B.clearcoatMap && a.enable(15), B.clearcoatRoughnessMap && a.enable(16), B.clearcoatNormalMap && a.enable(17), B.iridescence && a.enable(18), B.iridescenceMap && a.enable(19), B.iridescenceThicknessMap && a.enable(20), B.displacementMap && a.enable(21), B.specularMap && a.enable(22), B.roughnessMap && a.enable(23), B.metalnessMap && a.enable(24), B.gradientMap && a.enable(25), B.alphaMap && a.enable(26), B.alphaTest && a.enable(27), B.vertexColors && a.enable(28), B.vertexAlphas && a.enable(29), B.vertexUvs && a.enable(30), B.vertexTangents && a.enable(31), B.uvsVertexOnly && a.enable(32), E.push(a.mask), a.disableAll(), B.fog && a.enable(0), B.useFog && a.enable(1), B.flatShading && a.enable(2), B.logarithmicDepthBuffer && a.enable(3), B.skinning && a.enable(4), B.morphTargets && a.enable(5), B.morphNormals && a.enable(6), B.morphColors && a.enable(7), B.premultipliedAlpha && a.enable(8), B.shadowMapEnabled && a.enable(9), B.physicallyCorrectLights && a.enable(10), B.doubleSided && a.enable(11), B.flipSided && a.enable(12), B.useDepthPacking && a.enable(13), B.dithering && a.enable(14), B.specularIntensityMap && a.enable(15), B.specularColorMap && a.enable(16), B.transmission && a.enable(17), B.transmissionMap && a.enable(18), B.thicknessMap && a.enable(19), B.sheen && a.enable(20), B.sheenColorMap && a.enable(21), B.sheenRoughnessMap && a.enable(22), B.decodeVideoTexture && a.enable(23), B.opaque && a.enable(24), E.push(a.mask) } function w(E) { const B = v[E.type]; let L; if (B) { const U = Pr[B]; L = xB.clone(U.uniforms) } else L = E.uniforms; return L } function S(E, B) { let L; for (let U = 0, q = f.length; U < q; U++) { const W = f[U]; if (W.cacheKey === B) { L = W, ++L.usedTimes; break } } return L === void 0 && (L = new gz(n, B, E, s), f.push(L)), L } function T(E) { if (--E.usedTimes === 0) { const B = f.indexOf(E); f[B] = f[f.length - 1], f.pop(), E.destroy() } } function P(E) { l.remove(E) } function R() { l.dispose() } return { getParameters: y, getProgramCacheKey: x, getUniforms: w, acquireProgram: S, releaseProgram: T, releaseShaderCache: P, programs: f, dispose: R } } function _z() { let n = new WeakMap; function e(s) { let o = n.get(s); return o === void 0 && (o = {}, n.set(s, o)), o } function t(s) { n.delete(s) } function i(s, o, a) { n.get(s)[o] = a } function r() { n = new WeakMap } return { get: e, remove: t, update: i, dispose: r } } function Mz(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id } function BC(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id } function RC() { const n = []; let e = 0; const t = [], i = [], r = []; function s() { e = 0, t.length = 0, i.length = 0, r.length = 0 } function o(h, p, m, v, y, x) { let A = n[e]; return A === void 0 ? (A = { id: h.id, object: h, geometry: p, material: m, groupOrder: v, renderOrder: h.renderOrder, z: y, group: x }, n[e] = A) : (A.id = h.id, A.object = h, A.geometry = p, A.material = m, A.groupOrder = v, A.renderOrder = h.renderOrder, A.z = y, A.group = x), e++, A } function a(h, p, m, v, y, x) { const A = o(h, p, m, v, y, x); m.transmission > 0 ? i.push(A) : m.transparent === !0 ? r.push(A) : t.push(A) } function l(h, p, m, v, y, x) { const A = o(h, p, m, v, y, x); m.transmission > 0 ? i.unshift(A) : m.transparent === !0 ? r.unshift(A) : t.unshift(A) } function f(h, p) { t.length > 1 && t.sort(h || Mz), i.length > 1 && i.sort(p || BC), r.length > 1 && r.sort(p || BC) } function d() { for (let h = e, p = n.length; h < p; h++) { const m = n[h]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: t, transmissive: i, transparent: r, init: s, push: a, unshift: l, finish: d, sort: f } } function wz() { let n = new WeakMap; function e(i, r) { const s = n.get(i); let o; return s === void 0 ? (o = new RC, n.set(i, [o])) : r >= s.length ? (o = new RC, s.push(o)) : o = s[r], o } function t() { n = new WeakMap } return { get: e, dispose: t } } function Sz() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new I, color: new Le }; break; case "SpotLight": t = { position: new I, direction: new I, color: new Le, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new I, color: new Le, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new I, skyColor: new Le, groundColor: new Le }; break; case "RectAreaLight": t = { color: new Le, position: new I, halfWidth: new I, halfHeight: new I }; break }return n[e.id] = t, t } } } function Cz() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pe }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pe }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new pe, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return n[e.id] = t, t } } } let Ez = 0; function Tz(n, e) { return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0) } function bz(n, e) { const t = new Sz, i = Cz(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let d = 0; d < 9; d++)r.probe.push(new I); const s = new I, o = new it, a = new it; function l(d, h) { let p = 0, m = 0, v = 0; for (let U = 0; U < 9; U++)r.probe[U].set(0, 0, 0); let y = 0, x = 0, A = 0, _ = 0, w = 0, S = 0, T = 0, P = 0, R = 0, E = 0; d.sort(Tz); const B = h !== !0 ? Math.PI : 1; for (let U = 0, q = d.length; U < q; U++) { const W = d[U], G = W.color, K = W.intensity, ne = W.distance, oe = W.shadow && W.shadow.map ? W.shadow.map.texture : null; if (W.isAmbientLight) p += G.r * K * B, m += G.g * K * B, v += G.b * K * B; else if (W.isLightProbe) for (let N = 0; N < 9; N++)r.probe[N].addScaledVector(W.sh.coefficients[N], K); else if (W.isDirectionalLight) { const N = t.get(W); if (N.color.copy(W.color).multiplyScalar(W.intensity * B), W.castShadow) { const V = W.shadow, Y = i.get(W); Y.shadowBias = V.bias, Y.shadowNormalBias = V.normalBias, Y.shadowRadius = V.radius, Y.shadowMapSize = V.mapSize, r.directionalShadow[y] = Y, r.directionalShadowMap[y] = oe, r.directionalShadowMatrix[y] = W.shadow.matrix, S++ } r.directional[y] = N, y++ } else if (W.isSpotLight) { const N = t.get(W); N.position.setFromMatrixPosition(W.matrixWorld), N.color.copy(G).multiplyScalar(K * B), N.distance = ne, N.coneCos = Math.cos(W.angle), N.penumbraCos = Math.cos(W.angle * (1 - W.penumbra)), N.decay = W.decay, r.spot[A] = N; const V = W.shadow; if (W.map && (r.spotLightMap[R] = W.map, R++, V.updateMatrices(W), W.castShadow && E++), r.spotLightMatrix[A] = V.matrix, W.castShadow) { const Y = i.get(W); Y.shadowBias = V.bias, Y.shadowNormalBias = V.normalBias, Y.shadowRadius = V.radius, Y.shadowMapSize = V.mapSize, r.spotShadow[A] = Y, r.spotShadowMap[A] = oe, P++ } A++ } else if (W.isRectAreaLight) { const N = t.get(W); N.color.copy(G).multiplyScalar(K), N.halfWidth.set(W.width * .5, 0, 0), N.halfHeight.set(0, W.height * .5, 0), r.rectArea[_] = N, _++ } else if (W.isPointLight) { const N = t.get(W); if (N.color.copy(W.color).multiplyScalar(W.intensity * B), N.distance = W.distance, N.decay = W.decay, W.castShadow) { const V = W.shadow, Y = i.get(W); Y.shadowBias = V.bias, Y.shadowNormalBias = V.normalBias, Y.shadowRadius = V.radius, Y.shadowMapSize = V.mapSize, Y.shadowCameraNear = V.camera.near, Y.shadowCameraFar = V.camera.far, r.pointShadow[x] = Y, r.pointShadowMap[x] = oe, r.pointShadowMatrix[x] = W.shadow.matrix, T++ } r.point[x] = N, x++ } else if (W.isHemisphereLight) { const N = t.get(W); N.skyColor.copy(W.color).multiplyScalar(K * B), N.groundColor.copy(W.groundColor).multiplyScalar(K * B), r.hemi[w] = N, w++ } } _ > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1, r.rectAreaLTC2 = Re.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = Re.LTC_HALF_1, r.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = m, r.ambient[2] = v; const L = r.hash; (L.directionalLength !== y || L.pointLength !== x || L.spotLength !== A || L.rectAreaLength !== _ || L.hemiLength !== w || L.numDirectionalShadows !== S || L.numPointShadows !== T || L.numSpotShadows !== P || L.numSpotMaps !== R) && (r.directional.length = y, r.spot.length = A, r.rectArea.length = _, r.point.length = x, r.hemi.length = w, r.directionalShadow.length = S, r.directionalShadowMap.length = S, r.pointShadow.length = T, r.pointShadowMap.length = T, r.spotShadow.length = P, r.spotShadowMap.length = P, r.directionalShadowMatrix.length = S, r.pointShadowMatrix.length = T, r.spotLightMatrix.length = P + R - E, r.spotLightMap.length = R, r.numSpotLightShadowsWithMaps = E, L.directionalLength = y, L.pointLength = x, L.spotLength = A, L.rectAreaLength = _, L.hemiLength = w, L.numDirectionalShadows = S, L.numPointShadows = T, L.numSpotShadows = P, L.numSpotMaps = R, r.version = Ez++) } function f(d, h) { let p = 0, m = 0, v = 0, y = 0, x = 0; const A = h.matrixWorldInverse; for (let _ = 0, w = d.length; _ < w; _++) { const S = d[_]; if (S.isDirectionalLight) { const T = r.directional[p]; T.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(A), p++ } else if (S.isSpotLight) { const T = r.spot[v]; T.position.setFromMatrixPosition(S.matrixWorld), T.position.applyMatrix4(A), T.direction.setFromMatrixPosition(S.matrixWorld), s.setFromMatrixPosition(S.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(A), v++ } else if (S.isRectAreaLight) { const T = r.rectArea[y]; T.position.setFromMatrixPosition(S.matrixWorld), T.position.applyMatrix4(A), a.identity(), o.copy(S.matrixWorld), o.premultiply(A), a.extractRotation(o), T.halfWidth.set(S.width * .5, 0, 0), T.halfHeight.set(0, S.height * .5, 0), T.halfWidth.applyMatrix4(a), T.halfHeight.applyMatrix4(a), y++ } else if (S.isPointLight) { const T = r.point[m]; T.position.setFromMatrixPosition(S.matrixWorld), T.position.applyMatrix4(A), m++ } else if (S.isHemisphereLight) { const T = r.hemi[x]; T.direction.setFromMatrixPosition(S.matrixWorld), T.direction.transformDirection(A), x++ } } } return { setup: l, setupView: f, state: r } } function LC(n, e) { const t = new bz(n, e), i = [], r = []; function s() { i.length = 0, r.length = 0 } function o(h) { i.push(h) } function a(h) { r.push(h) } function l(h) { t.setup(i, h) } function f(h) { t.setupView(i, h) } return { init: s, state: { lightsArray: i, shadowsArray: r, lights: t }, setupLights: l, setupLightsView: f, pushLight: o, pushShadow: a } } function Pz(n, e) { let t = new WeakMap; function i(s, o = 0) { const a = t.get(s); let l; return a === void 0 ? (l = new LC(n, e), t.set(s, [l])) : o >= a.length ? (l = new LC(n, e), a.push(l)) : l = a[o], l } function r() { t = new WeakMap } return { get: i, dispose: r } } class XA extends Mn { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = fB, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class YA extends Mn { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new I, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const Bz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Rz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function Lz(n, e, t) { let i = new wg; const r = new pe, s = new pe, o = new Nt, a = new XA({ depthPacking: dB }), l = new YA, f = {}, d = t.maxTextureSize, h = { [is]: Ei, [Ei]: is, [Br]: Br }, p = new ss({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new pe }, radius: { value: 4 } }, vertexShader: Bz, fragmentShader: Rz }), m = p.clone(); m.defines.HORIZONTAL_PASS = 1; const v = new ut; v.setAttribute("position", new It(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const y = new Tn(v, p), x = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = vg, this.render = function (S, T, P) { if (x.enabled === !1 || x.autoUpdate === !1 && x.needsUpdate === !1 || S.length === 0) return; const R = n.getRenderTarget(), E = n.getActiveCubeFace(), B = n.getActiveMipmapLevel(), L = n.state; L.setBlending(Fs), L.buffers.color.setClear(1, 1, 1, 1), L.buffers.depth.setTest(!0), L.setScissorTest(!1); for (let U = 0, q = S.length; U < q; U++) { const W = S[U], G = W.shadow; if (G === void 0) { console.warn("THREE.WebGLShadowMap:", W, "has no shadow."); continue } if (G.autoUpdate === !1 && G.needsUpdate === !1) continue; r.copy(G.mapSize); const K = G.getFrameExtents(); if (r.multiply(K), s.copy(G.mapSize), (r.x > d || r.y > d) && (r.x > d && (s.x = Math.floor(d / K.x), r.x = s.x * K.x, G.mapSize.x = s.x), r.y > d && (s.y = Math.floor(d / K.y), r.y = s.y * K.y, G.mapSize.y = s.y)), G.map === null) { const oe = this.type !== Da ? { minFilter: fn, magFilter: fn } : {}; G.map = new Nr(r.x, r.y, oe), G.map.texture.name = W.name + ".shadowMap", G.camera.updateProjectionMatrix() } n.setRenderTarget(G.map), n.clear(); const ne = G.getViewportCount(); for (let oe = 0; oe < ne; oe++) { const N = G.getViewport(oe); o.set(s.x * N.x, s.y * N.y, s.x * N.z, s.y * N.w), L.viewport(o), G.updateMatrices(W, oe), i = G.getFrustum(), w(T, P, G.camera, W, this.type) } G.isPointLightShadow !== !0 && this.type === Da && A(G, P), G.needsUpdate = !1 } x.needsUpdate = !1, n.setRenderTarget(R, E, B) }; function A(S, T) { const P = e.update(y); p.defines.VSM_SAMPLES !== S.blurSamples && (p.defines.VSM_SAMPLES = S.blurSamples, m.defines.VSM_SAMPLES = S.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), S.mapPass === null && (S.mapPass = new Nr(r.x, r.y)), p.uniforms.shadow_pass.value = S.map.texture, p.uniforms.resolution.value = S.mapSize, p.uniforms.radius.value = S.radius, n.setRenderTarget(S.mapPass), n.clear(), n.renderBufferDirect(T, null, P, p, y, null), m.uniforms.shadow_pass.value = S.mapPass.texture, m.uniforms.resolution.value = S.mapSize, m.uniforms.radius.value = S.radius, n.setRenderTarget(S.map), n.clear(), n.renderBufferDirect(T, null, P, m, y, null) } function _(S, T, P, R, E, B) { let L = null; const U = P.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial; if (U !== void 0) L = U; else if (L = P.isPointLight === !0 ? l : a, n.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) { const q = L.uuid, W = T.uuid; let G = f[q]; G === void 0 && (G = {}, f[q] = G); let K = G[W]; K === void 0 && (K = L.clone(), G[W] = K), L = K } return L.visible = T.visible, L.wireframe = T.wireframe, B === Da ? L.side = T.shadowSide !== null ? T.shadowSide : T.side : L.side = T.shadowSide !== null ? T.shadowSide : h[T.side], L.alphaMap = T.alphaMap, L.alphaTest = T.alphaTest, L.map = T.map, L.clipShadows = T.clipShadows, L.clippingPlanes = T.clippingPlanes, L.clipIntersection = T.clipIntersection, L.displacementMap = T.displacementMap, L.displacementScale = T.displacementScale, L.displacementBias = T.displacementBias, L.wireframeLinewidth = T.wireframeLinewidth, L.linewidth = T.linewidth, P.isPointLight === !0 && L.isMeshDistanceMaterial === !0 && (L.referencePosition.setFromMatrixPosition(P.matrixWorld), L.nearDistance = R, L.farDistance = E), L } function w(S, T, P, R, E) { if (S.visible === !1) return; if (S.layers.test(T.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && E === Da) && (!S.frustumCulled || i.intersectsObject(S))) { S.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, S.matrixWorld); const U = e.update(S), q = S.material; if (Array.isArray(q)) { const W = U.groups; for (let G = 0, K = W.length; G < K; G++) { const ne = W[G], oe = q[ne.materialIndex]; if (oe && oe.visible) { const N = _(S, oe, R, P.near, P.far, E); n.renderBufferDirect(P, null, U, N, S, ne) } } } else if (q.visible) { const W = _(S, q, R, P.near, P.far, E); n.renderBufferDirect(P, null, U, W, S, null) } } const L = S.children; for (let U = 0, q = L.length; U < q; U++)w(L[U], T, P, R, E) } } function Dz(n, e, t) { const i = t.isWebGL2; function r() { let X = !1; const ce = new Nt; let xe = null; const Ue = new Nt(0, 0, 0, 0); return { setMask: function (Ke) { xe !== Ke && !X && (n.colorMask(Ke, Ke, Ke, Ke), xe = Ke) }, setLocked: function (Ke) { X = Ke }, setClear: function (Ke, Pt, dn, Bn, zr) { zr === !0 && (Ke *= Bn, Pt *= Bn, dn *= Bn), ce.set(Ke, Pt, dn, Bn), Ue.equals(ce) === !1 && (n.clearColor(Ke, Pt, dn, Bn), Ue.copy(ce)) }, reset: function () { X = !1, xe = null, Ue.set(-1, 0, 0, 0) } } } function s() { let X = !1, ce = null, xe = null, Ue = null; return { setTest: function (Ke) { Ke ? Oe(2929) : ke(2929) }, setMask: function (Ke) { ce !== Ke && !X && (n.depthMask(Ke), ce = Ke) }, setFunc: function (Ke) { if (xe !== Ke) { switch (Ke) { case DP: n.depthFunc(512); break; case IP: n.depthFunc(519); break; case FP: n.depthFunc(513); break; case Um: n.depthFunc(515); break; case NP: n.depthFunc(514); break; case OP: n.depthFunc(518); break; case kP: n.depthFunc(516); break; case UP: n.depthFunc(517); break; default: n.depthFunc(515) }xe = Ke } }, setLocked: function (Ke) { X = Ke }, setClear: function (Ke) { Ue !== Ke && (n.clearDepth(Ke), Ue = Ke) }, reset: function () { X = !1, ce = null, xe = null, Ue = null } } } function o() { let X = !1, ce = null, xe = null, Ue = null, Ke = null, Pt = null, dn = null, Bn = null, zr = null; return { setTest: function (kt) { X || (kt ? Oe(2960) : ke(2960)) }, setMask: function (kt) { ce !== kt && !X && (n.stencilMask(kt), ce = kt) }, setFunc: function (kt, ji, pi) { (xe !== kt || Ue !== ji || Ke !== pi) && (n.stencilFunc(kt, ji, pi), xe = kt, Ue = ji, Ke = pi) }, setOp: function (kt, ji, pi) { (Pt !== kt || dn !== ji || Bn !== pi) && (n.stencilOp(kt, ji, pi), Pt = kt, dn = ji, Bn = pi) }, setLocked: function (kt) { X = kt }, setClear: function (kt) { zr !== kt && (n.clearStencil(kt), zr = kt) }, reset: function () { X = !1, ce = null, xe = null, Ue = null, Ke = null, Pt = null, dn = null, Bn = null, zr = null } } } const a = new r, l = new s, f = new o, d = new WeakMap, h = new WeakMap; let p = {}, m = {}, v = new WeakMap, y = [], x = null, A = !1, _ = null, w = null, S = null, T = null, P = null, R = null, E = null, B = !1, L = null, U = null, q = null, W = null, G = null; const K = n.getParameter(35661); let ne = !1, oe = 0; const N = n.getParameter(7938); N.indexOf("WebGL") !== -1 ? (oe = parseFloat(/^WebGL (\d)/.exec(N)[1]), ne = oe >= 1) : N.indexOf("OpenGL ES") !== -1 && (oe = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]), ne = oe >= 2); let V = null, Y = {}; const re = n.getParameter(3088), j = n.getParameter(2978), ie = new Nt().fromArray(re), ve = new Nt().fromArray(j); function Ae(X, ce, xe) { const Ue = new Uint8Array(4), Ke = n.createTexture(); n.bindTexture(X, Ke), n.texParameteri(X, 10241, 9728), n.texParameteri(X, 10240, 9728); for (let Pt = 0; Pt < xe; Pt++)n.texImage2D(ce + Pt, 0, 6408, 1, 1, 0, 6408, 5121, Ue); return Ke } const $ = {}; $[3553] = Ae(3553, 3553, 1), $[34067] = Ae(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), f.setClear(0), Oe(2929), l.setFunc(Um), Be(!1), Ze(_x), Oe(2884), Ce(Fs); function Oe(X) { p[X] !== !0 && (n.enable(X), p[X] = !0) } function ke(X) { p[X] !== !1 && (n.disable(X), p[X] = !1) } function He(X, ce) { return m[X] !== ce ? (n.bindFramebuffer(X, ce), m[X] = ce, i && (X === 36009 && (m[36160] = ce), X === 36160 && (m[36009] = ce)), !0) : !1 } function Me(X, ce) { let xe = y, Ue = !1; if (X) if (xe = v.get(ce), xe === void 0 && (xe = [], v.set(ce, xe)), X.isWebGLMultipleRenderTargets) { const Ke = X.texture; if (xe.length !== Ke.length || xe[0] !== 36064) { for (let Pt = 0, dn = Ke.length; Pt < dn; Pt++)xe[Pt] = 36064 + Pt; xe.length = Ke.length, Ue = !0 } } else xe[0] !== 36064 && (xe[0] = 36064, Ue = !0); else xe[0] !== 1029 && (xe[0] = 1029, Ue = !0); Ue && (t.isWebGL2 ? n.drawBuffers(xe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe)) } function De(X) { return x !== X ? (n.useProgram(X), x = X, !0) : !1 } const de = { [Ta]: 32774, [MP]: 32778, [wP]: 32779 }; if (i) de[Cx] = 32775, de[Ex] = 32776; else { const X = e.get("EXT_blend_minmax"); X !== null && (de[Cx] = X.MIN_EXT, de[Ex] = X.MAX_EXT) } const ae = { [SP]: 0, [CP]: 1, [EP]: 768, [LA]: 770, [LP]: 776, [BP]: 774, [bP]: 772, [TP]: 769, [DA]: 771, [RP]: 775, [PP]: 773 }; function Ce(X, ce, xe, Ue, Ke, Pt, dn, Bn) { if (X === Fs) { A === !0 && (ke(3042), A = !1); return } if (A === !1 && (Oe(3042), A = !0), X !== _P) { if (X !== _ || Bn !== B) { if ((w !== Ta || P !== Ta) && (n.blendEquation(32774), w = Ta, P = Ta), Bn) switch (X) { case Ga: n.blendFuncSeparate(1, 771, 1, 771); break; case Mx: n.blendFunc(1, 1); break; case wx: n.blendFuncSeparate(0, 769, 0, 1); break; case Sx: n.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", X); break } else switch (X) { case Ga: n.blendFuncSeparate(770, 771, 1, 771); break; case Mx: n.blendFunc(770, 1); break; case wx: n.blendFuncSeparate(0, 769, 0, 1); break; case Sx: n.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", X); break }S = null, T = null, R = null, E = null, _ = X, B = Bn } return } Ke = Ke || ce, Pt = Pt || xe, dn = dn || Ue, (ce !== w || Ke !== P) && (n.blendEquationSeparate(de[ce], de[Ke]), w = ce, P = Ke), (xe !== S || Ue !== T || Pt !== R || dn !== E) && (n.blendFuncSeparate(ae[xe], ae[Ue], ae[Pt], ae[dn]), S = xe, T = Ue, R = Pt, E = dn), _ = X, B = !1 } function ze(X, ce) { X.side === Br ? ke(2884) : Oe(2884); let xe = X.side === Ei; ce && (xe = !xe), Be(xe), X.blending === Ga && X.transparent === !1 ? Ce(Fs) : Ce(X.blending, X.blendEquation, X.blendSrc, X.blendDst, X.blendEquationAlpha, X.blendSrcAlpha, X.blendDstAlpha, X.premultipliedAlpha), l.setFunc(X.depthFunc), l.setTest(X.depthTest), l.setMask(X.depthWrite), a.setMask(X.colorWrite); const Ue = X.stencilWrite; f.setTest(Ue), Ue && (f.setMask(X.stencilWriteMask), f.setFunc(X.stencilFunc, X.stencilRef, X.stencilFuncMask), f.setOp(X.stencilFail, X.stencilZFail, X.stencilZPass)), je(X.polygonOffset, X.polygonOffsetFactor, X.polygonOffsetUnits), X.alphaToCoverage === !0 ? Oe(32926) : ke(32926) } function Be(X) { L !== X && (X ? n.frontFace(2304) : n.frontFace(2305), L = X) } function Ze(X) { X !== vP ? (Oe(2884), X !== U && (X === _x ? n.cullFace(1029) : X === xP ? n.cullFace(1028) : n.cullFace(1032))) : ke(2884), U = X } function Je(X) { X !== q && (ne && n.lineWidth(X), q = X) } function je(X, ce, xe) { X ? (Oe(32823), (W !== ce || G !== xe) && (n.polygonOffset(ce, xe), W = ce, G = xe)) : ke(32823) } function vt(X) { X ? Oe(3089) : ke(3089) } function wt(X) { X === void 0 && (X = 33984 + K - 1), V !== X && (n.activeTexture(X), V = X) } function k(X, ce, xe) { xe === void 0 && (V === null ? xe = 33984 + K - 1 : xe = V); let Ue = Y[xe]; Ue === void 0 && (Ue = { type: void 0, texture: void 0 }, Y[xe] = Ue), (Ue.type !== X || Ue.texture !== ce) && (V !== xe && (n.activeTexture(xe), V = xe), n.bindTexture(X, ce || $[X]), Ue.type = X, Ue.texture = ce) } function D() { const X = Y[V]; X !== void 0 && X.type !== void 0 && (n.bindTexture(X.type, null), X.type = void 0, X.texture = void 0) } function se() { try { n.compressedTexImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function we() { try { n.compressedTexImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Ee() { try { n.texSubImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Pe() { try { n.texSubImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function tt() { try { n.compressedTexSubImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Ie() { try { n.compressedTexSubImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function me() { try { n.texStorage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function Xe() { try { n.texStorage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function H() { try { n.texImage2D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function le() { try { n.texImage3D.apply(n, arguments) } catch (X) { console.error("THREE.WebGLState:", X) } } function _e(X) { ie.equals(X) === !1 && (n.scissor(X.x, X.y, X.z, X.w), ie.copy(X)) } function be(X) { ve.equals(X) === !1 && (n.viewport(X.x, X.y, X.z, X.w), ve.copy(X)) } function $e(X, ce) { let xe = h.get(ce); xe === void 0 && (xe = new WeakMap, h.set(ce, xe)); let Ue = xe.get(X); Ue === void 0 && (Ue = n.getUniformBlockIndex(ce, X.name), xe.set(X, Ue)) } function yt(X, ce) { const Ue = h.get(ce).get(X); d.get(ce) !== Ue && (n.uniformBlockBinding(ce, Ue, X.__bindingPointIndex), d.set(ce, Ue)) } function Vt() { n.disable(3042), n.disable(2884), n.disable(2929), n.disable(32823), n.disable(3089), n.disable(2960), n.disable(32926), n.blendEquation(32774), n.blendFunc(1, 0), n.blendFuncSeparate(1, 0, 1, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(513), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(519, 0, 4294967295), n.stencilOp(7680, 7680, 7680), n.clearStencil(0), n.cullFace(1029), n.frontFace(2305), n.polygonOffset(0, 0), n.activeTexture(33984), n.bindFramebuffer(36160, null), i === !0 && (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), p = {}, V = null, Y = {}, m = {}, v = new WeakMap, y = [], x = null, A = !1, _ = null, w = null, S = null, T = null, P = null, R = null, E = null, B = !1, L = null, U = null, q = null, W = null, G = null, ie.set(0, 0, n.canvas.width, n.canvas.height), ve.set(0, 0, n.canvas.width, n.canvas.height), a.reset(), l.reset(), f.reset() } return { buffers: { color: a, depth: l, stencil: f }, enable: Oe, disable: ke, bindFramebuffer: He, drawBuffers: Me, useProgram: De, setBlending: Ce, setMaterial: ze, setFlipSided: Be, setCullFace: Ze, setLineWidth: Je, setPolygonOffset: je, setScissorTest: vt, activeTexture: wt, bindTexture: k, unbindTexture: D, compressedTexImage2D: se, compressedTexImage3D: we, texImage2D: H, texImage3D: le, updateUBOMapping: $e, uniformBlockBinding: yt, texStorage2D: me, texStorage3D: Xe, texSubImage2D: Ee, texSubImage3D: Pe, compressedTexSubImage2D: tt, compressedTexSubImage3D: Ie, scissor: _e, viewport: be, reset: Vt } } function Iz(n, e, t, i, r, s, o) { const a = r.isWebGL2, l = r.maxTextures, f = r.maxCubemapSize, d = r.maxTextureSize, h = r.maxSamples, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), v = new WeakMap; let y; const x = new WeakMap; let A = !1; try { A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function _(k, D) { return A ? new OffscreenCanvas(k, D) : jf("canvas") } function w(k, D, se, we) { let Ee = 1; if ((k.width > we || k.height > we) && (Ee = we / Math.max(k.width, k.height)), Ee < 1 || D === !0) if (typeof HTMLImageElement < "u" && k instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && k instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && k instanceof ImageBitmap) { const Pe = D ? Gm : Math.floor, tt = Pe(Ee * k.width), Ie = Pe(Ee * k.height); y === void 0 && (y = _(tt, Ie)); const me = se ? _(tt, Ie) : y; return me.width = tt, me.height = Ie, me.getContext("2d").drawImage(k, 0, 0, tt, Ie), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + k.width + "x" + k.height + ") to (" + tt + "x" + Ie + ")."), me } else return "data" in k && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + k.width + "x" + k.height + ")."), k; return k } function S(k) { return Zx(k.width) && Zx(k.height) } function T(k) { return a ? !1 : k.wrapS !== zn || k.wrapT !== zn || k.minFilter !== fn && k.minFilter !== en } function P(k, D) { return k.generateMipmaps && D && k.minFilter !== fn && k.minFilter !== en } function R(k) { n.generateMipmap(k) } function E(k, D, se, we, Ee = !1) { if (a === !1) return D; if (k !== null) { if (n[k] !== void 0) return n[k]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + k + "'") } let Pe = D; return D === 6403 && (se === 5126 && (Pe = 33326), se === 5131 && (Pe = 33325), se === 5121 && (Pe = 33321)), D === 33319 && (se === 5126 && (Pe = 33328), se === 5131 && (Pe = 33327), se === 5121 && (Pe = 33323)), D === 6408 && (se === 5126 && (Pe = 34836), se === 5131 && (Pe = 34842), se === 5121 && (Pe = we === Ct && Ee === !1 ? 35907 : 32856), se === 32819 && (Pe = 32854), se === 32820 && (Pe = 32855)), (Pe === 33325 || Pe === 33326 || Pe === 33327 || Pe === 33328 || Pe === 34842 || Pe === 34836) && e.get("EXT_color_buffer_float"), Pe } function B(k, D, se) { return P(k, se) === !0 || k.isFramebufferTexture && k.minFilter !== fn && k.minFilter !== en ? Math.log2(Math.max(D.width, D.height)) + 1 : k.mipmaps !== void 0 && k.mipmaps.length > 0 ? k.mipmaps.length : k.isCompressedTexture && Array.isArray(k.image) ? D.mipmaps.length : 1 } function L(k) { return k === fn || k === Gf || k === vu ? 9728 : 9729 } function U(k) { const D = k.target; D.removeEventListener("dispose", U), W(D), D.isVideoTexture && v.delete(D) } function q(k) { const D = k.target; D.removeEventListener("dispose", q), K(D) } function W(k) { const D = i.get(k); if (D.__webglInit === void 0) return; const se = k.source, we = x.get(se); if (we) { const Ee = we[D.__cacheKey]; Ee.usedTimes--, Ee.usedTimes === 0 && G(k), Object.keys(we).length === 0 && x.delete(se) } i.remove(k) } function G(k) { const D = i.get(k); n.deleteTexture(D.__webglTexture); const se = k.source, we = x.get(se); delete we[D.__cacheKey], o.memory.textures-- } function K(k) { const D = k.texture, se = i.get(k), we = i.get(D); if (we.__webglTexture !== void 0 && (n.deleteTexture(we.__webglTexture), o.memory.textures--), k.depthTexture && k.depthTexture.dispose(), k.isWebGLCubeRenderTarget) for (let Ee = 0; Ee < 6; Ee++)n.deleteFramebuffer(se.__webglFramebuffer[Ee]), se.__webglDepthbuffer && n.deleteRenderbuffer(se.__webglDepthbuffer[Ee]); else { if (n.deleteFramebuffer(se.__webglFramebuffer), se.__webglDepthbuffer && n.deleteRenderbuffer(se.__webglDepthbuffer), se.__webglMultisampledFramebuffer && n.deleteFramebuffer(se.__webglMultisampledFramebuffer), se.__webglColorRenderbuffer) for (let Ee = 0; Ee < se.__webglColorRenderbuffer.length; Ee++)se.__webglColorRenderbuffer[Ee] && n.deleteRenderbuffer(se.__webglColorRenderbuffer[Ee]); se.__webglDepthRenderbuffer && n.deleteRenderbuffer(se.__webglDepthRenderbuffer) } if (k.isWebGLMultipleRenderTargets) for (let Ee = 0, Pe = D.length; Ee < Pe; Ee++) { const tt = i.get(D[Ee]); tt.__webglTexture && (n.deleteTexture(tt.__webglTexture), o.memory.textures--), i.remove(D[Ee]) } i.remove(D), i.remove(k) } let ne = 0; function oe() { ne = 0 } function N() { const k = ne; return k >= l && console.warn("THREE.WebGLTextures: Trying to use " + k + " texture units while this GPU supports only " + l), ne += 1, k } function V(k) { const D = []; return D.push(k.wrapS), D.push(k.wrapT), D.push(k.wrapR || 0), D.push(k.magFilter), D.push(k.minFilter), D.push(k.anisotropy), D.push(k.internalFormat), D.push(k.format), D.push(k.type), D.push(k.generateMipmaps), D.push(k.premultiplyAlpha), D.push(k.flipY), D.push(k.unpackAlignment), D.push(k.encoding), D.join() } function Y(k, D) { const se = i.get(k); if (k.isVideoTexture && vt(k), k.isRenderTargetTexture === !1 && k.version > 0 && se.__version !== k.version) { const we = k.image; if (we === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (we.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { ke(se, k, D); return } } t.bindTexture(3553, se.__webglTexture, 33984 + D) } function re(k, D) { const se = i.get(k); if (k.version > 0 && se.__version !== k.version) { ke(se, k, D); return } t.bindTexture(35866, se.__webglTexture, 33984 + D) } function j(k, D) { const se = i.get(k); if (k.version > 0 && se.__version !== k.version) { ke(se, k, D); return } t.bindTexture(32879, se.__webglTexture, 33984 + D) } function ie(k, D) { const se = i.get(k); if (k.version > 0 && se.__version !== k.version) { He(se, k, D); return } t.bindTexture(34067, se.__webglTexture, 33984 + D) } const ve = { [Uo]: 10497, [zn]: 33071, [bu]: 33648 }, Ae = { [fn]: 9728, [Gf]: 9984, [vu]: 9986, [en]: 9729, [Ag]: 9985, [rs]: 9987 }; function $(k, D, se) { if (se ? (n.texParameteri(k, 10242, ve[D.wrapS]), n.texParameteri(k, 10243, ve[D.wrapT]), (k === 32879 || k === 35866) && n.texParameteri(k, 32882, ve[D.wrapR]), n.texParameteri(k, 10240, Ae[D.magFilter]), n.texParameteri(k, 10241, Ae[D.minFilter])) : (n.texParameteri(k, 10242, 33071), n.texParameteri(k, 10243, 33071), (k === 32879 || k === 35866) && n.texParameteri(k, 32882, 33071), (D.wrapS !== zn || D.wrapT !== zn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(k, 10240, L(D.magFilter)), n.texParameteri(k, 10241, L(D.minFilter)), D.minFilter !== fn && D.minFilter !== en && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) { const we = e.get("EXT_texture_filter_anisotropic"); if (D.magFilter === fn || D.minFilter !== vu && D.minFilter !== rs || D.type === Bs && e.has("OES_texture_float_linear") === !1 || a === !1 && D.type === Pu && e.has("OES_texture_half_float_linear") === !1) return; (D.anisotropy > 1 || i.get(D).__currentAnisotropy) && (n.texParameterf(k, we.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(D.anisotropy, r.getMaxAnisotropy())), i.get(D).__currentAnisotropy = D.anisotropy) } } function Oe(k, D) { let se = !1; k.__webglInit === void 0 && (k.__webglInit = !0, D.addEventListener("dispose", U)); const we = D.source; let Ee = x.get(we); Ee === void 0 && (Ee = {}, x.set(we, Ee)); const Pe = V(D); if (Pe !== k.__cacheKey) { Ee[Pe] === void 0 && (Ee[Pe] = { texture: n.createTexture(), usedTimes: 0 }, o.memory.textures++, se = !0), Ee[Pe].usedTimes++; const tt = Ee[k.__cacheKey]; tt !== void 0 && (Ee[k.__cacheKey].usedTimes--, tt.usedTimes === 0 && G(D)), k.__cacheKey = Pe, k.__webglTexture = Ee[Pe].texture } return se } function ke(k, D, se) { let we = 3553; (D.isDataArrayTexture || D.isCompressedArrayTexture) && (we = 35866), D.isData3DTexture && (we = 32879); const Ee = Oe(k, D), Pe = D.source; t.bindTexture(we, k.__webglTexture, 33984 + se); const tt = i.get(Pe); if (Pe.version !== tt.__version || Ee === !0) { t.activeTexture(33984 + se), n.pixelStorei(37440, D.flipY), n.pixelStorei(37441, D.premultiplyAlpha), n.pixelStorei(3317, D.unpackAlignment), n.pixelStorei(37443, 0); const Ie = T(D) && S(D.image) === !1; let me = w(D.image, Ie, !1, d); me = wt(D, me); const Xe = S(me) || a, H = s.convert(D.format, D.encoding); let le = s.convert(D.type), _e = E(D.internalFormat, H, le, D.encoding, D.isVideoTexture); $(we, D, Xe); let be; const $e = D.mipmaps, yt = a && D.isVideoTexture !== !0, Vt = tt.__version === void 0 || Ee === !0, X = B(D, me, Xe); if (D.isDepthTexture) _e = 6402, a ? D.type === Bs ? _e = 36012 : D.type === Mo ? _e = 33190 : D.type === Ha ? _e = 35056 : _e = 33189 : D.type === Bs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), D.format === Do && _e === 6402 && D.type !== FA && D.type !== Mo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), D.type = Mo, le = s.convert(D.type)), D.format === $a && _e === 6402 && (_e = 34041, D.type !== Ha && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), D.type = Ha, le = s.convert(D.type))), Vt && (yt ? t.texStorage2D(3553, 1, _e, me.width, me.height) : t.texImage2D(3553, 0, _e, me.width, me.height, 0, H, le, null)); else if (D.isDataTexture) if ($e.length > 0 && Xe) { yt && Vt && t.texStorage2D(3553, X, _e, $e[0].width, $e[0].height); for (let ce = 0, xe = $e.length; ce < xe; ce++)be = $e[ce], yt ? t.texSubImage2D(3553, ce, 0, 0, be.width, be.height, H, le, be.data) : t.texImage2D(3553, ce, _e, be.width, be.height, 0, H, le, be.data); D.generateMipmaps = !1 } else yt ? (Vt && t.texStorage2D(3553, X, _e, me.width, me.height), t.texSubImage2D(3553, 0, 0, 0, me.width, me.height, H, le, me.data)) : t.texImage2D(3553, 0, _e, me.width, me.height, 0, H, le, me.data); else if (D.isCompressedTexture) if (D.isCompressedArrayTexture) { yt && Vt && t.texStorage3D(35866, X, _e, $e[0].width, $e[0].height, me.depth); for (let ce = 0, xe = $e.length; ce < xe; ce++)be = $e[ce], D.format !== Ai ? H !== null ? yt ? t.compressedTexSubImage3D(35866, ce, 0, 0, 0, be.width, be.height, me.depth, H, be.data, 0, 0) : t.compressedTexImage3D(35866, ce, _e, be.width, be.height, me.depth, 0, be.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? t.texSubImage3D(35866, ce, 0, 0, 0, be.width, be.height, me.depth, H, le, be.data) : t.texImage3D(35866, ce, _e, be.width, be.height, me.depth, 0, H, le, be.data) } else { yt && Vt && t.texStorage2D(3553, X, _e, $e[0].width, $e[0].height); for (let ce = 0, xe = $e.length; ce < xe; ce++)be = $e[ce], D.format !== Ai ? H !== null ? yt ? t.compressedTexSubImage2D(3553, ce, 0, 0, be.width, be.height, H, be.data) : t.compressedTexImage2D(3553, ce, _e, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : yt ? t.texSubImage2D(3553, ce, 0, 0, be.width, be.height, H, le, be.data) : t.texImage2D(3553, ce, _e, be.width, be.height, 0, H, le, be.data) } else if (D.isDataArrayTexture) yt ? (Vt && t.texStorage3D(35866, X, _e, me.width, me.height, me.depth), t.texSubImage3D(35866, 0, 0, 0, 0, me.width, me.height, me.depth, H, le, me.data)) : t.texImage3D(35866, 0, _e, me.width, me.height, me.depth, 0, H, le, me.data); else if (D.isData3DTexture) yt ? (Vt && t.texStorage3D(32879, X, _e, me.width, me.height, me.depth), t.texSubImage3D(32879, 0, 0, 0, 0, me.width, me.height, me.depth, H, le, me.data)) : t.texImage3D(32879, 0, _e, me.width, me.height, me.depth, 0, H, le, me.data); else if (D.isFramebufferTexture) { if (Vt) if (yt) t.texStorage2D(3553, X, _e, me.width, me.height); else { let ce = me.width, xe = me.height; for (let Ue = 0; Ue < X; Ue++)t.texImage2D(3553, Ue, _e, ce, xe, 0, H, le, null), ce >>= 1, xe >>= 1 } } else if ($e.length > 0 && Xe) { yt && Vt && t.texStorage2D(3553, X, _e, $e[0].width, $e[0].height); for (let ce = 0, xe = $e.length; ce < xe; ce++)be = $e[ce], yt ? t.texSubImage2D(3553, ce, 0, 0, H, le, be) : t.texImage2D(3553, ce, _e, H, le, be); D.generateMipmaps = !1 } else yt ? (Vt && t.texStorage2D(3553, X, _e, me.width, me.height), t.texSubImage2D(3553, 0, 0, 0, H, le, me)) : t.texImage2D(3553, 0, _e, H, le, me); P(D, Xe) && R(we), tt.__version = Pe.version, D.onUpdate && D.onUpdate(D) } k.__version = D.version } function He(k, D, se) { if (D.image.length !== 6) return; const we = Oe(k, D), Ee = D.source; t.bindTexture(34067, k.__webglTexture, 33984 + se); const Pe = i.get(Ee); if (Ee.version !== Pe.__version || we === !0) { t.activeTexture(33984 + se), n.pixelStorei(37440, D.flipY), n.pixelStorei(37441, D.premultiplyAlpha), n.pixelStorei(3317, D.unpackAlignment), n.pixelStorei(37443, 0); const tt = D.isCompressedTexture || D.image[0].isCompressedTexture, Ie = D.image[0] && D.image[0].isDataTexture, me = []; for (let ce = 0; ce < 6; ce++)!tt && !Ie ? me[ce] = w(D.image[ce], !1, !0, f) : me[ce] = Ie ? D.image[ce].image : D.image[ce], me[ce] = wt(D, me[ce]); const Xe = me[0], H = S(Xe) || a, le = s.convert(D.format, D.encoding), _e = s.convert(D.type), be = E(D.internalFormat, le, _e, D.encoding), $e = a && D.isVideoTexture !== !0, yt = Pe.__version === void 0 || we === !0; let Vt = B(D, Xe, H); $(34067, D, H); let X; if (tt) { $e && yt && t.texStorage2D(34067, Vt, be, Xe.width, Xe.height); for (let ce = 0; ce < 6; ce++) { X = me[ce].mipmaps; for (let xe = 0; xe < X.length; xe++) { const Ue = X[xe]; D.format !== Ai ? le !== null ? $e ? t.compressedTexSubImage2D(34069 + ce, xe, 0, 0, Ue.width, Ue.height, le, Ue.data) : t.compressedTexImage2D(34069 + ce, xe, be, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : $e ? t.texSubImage2D(34069 + ce, xe, 0, 0, Ue.width, Ue.height, le, _e, Ue.data) : t.texImage2D(34069 + ce, xe, be, Ue.width, Ue.height, 0, le, _e, Ue.data) } } } else { X = D.mipmaps, $e && yt && (X.length > 0 && Vt++, t.texStorage2D(34067, Vt, be, me[0].width, me[0].height)); for (let ce = 0; ce < 6; ce++)if (Ie) { $e ? t.texSubImage2D(34069 + ce, 0, 0, 0, me[ce].width, me[ce].height, le, _e, me[ce].data) : t.texImage2D(34069 + ce, 0, be, me[ce].width, me[ce].height, 0, le, _e, me[ce].data); for (let xe = 0; xe < X.length; xe++) { const Ke = X[xe].image[ce].image; $e ? t.texSubImage2D(34069 + ce, xe + 1, 0, 0, Ke.width, Ke.height, le, _e, Ke.data) : t.texImage2D(34069 + ce, xe + 1, be, Ke.width, Ke.height, 0, le, _e, Ke.data) } } else { $e ? t.texSubImage2D(34069 + ce, 0, 0, 0, le, _e, me[ce]) : t.texImage2D(34069 + ce, 0, be, le, _e, me[ce]); for (let xe = 0; xe < X.length; xe++) { const Ue = X[xe]; $e ? t.texSubImage2D(34069 + ce, xe + 1, 0, 0, le, _e, Ue.image[ce]) : t.texImage2D(34069 + ce, xe + 1, be, le, _e, Ue.image[ce]) } } } P(D, H) && R(34067), Pe.__version = Ee.version, D.onUpdate && D.onUpdate(D) } k.__version = D.version } function Me(k, D, se, we, Ee) { const Pe = s.convert(se.format, se.encoding), tt = s.convert(se.type), Ie = E(se.internalFormat, Pe, tt, se.encoding); i.get(D).__hasExternalTextures || (Ee === 32879 || Ee === 35866 ? t.texImage3D(Ee, 0, Ie, D.width, D.height, D.depth, 0, Pe, tt, null) : t.texImage2D(Ee, 0, Ie, D.width, D.height, 0, Pe, tt, null)), t.bindFramebuffer(36160, k), je(D) ? p.framebufferTexture2DMultisampleEXT(36160, we, Ee, i.get(se).__webglTexture, 0, Je(D)) : (Ee === 3553 || Ee >= 34069 && Ee <= 34074) && n.framebufferTexture2D(36160, we, Ee, i.get(se).__webglTexture, 0), t.bindFramebuffer(36160, null) } function De(k, D, se) { if (n.bindRenderbuffer(36161, k), D.depthBuffer && !D.stencilBuffer) { let we = 33189; if (se || je(D)) { const Ee = D.depthTexture; Ee && Ee.isDepthTexture && (Ee.type === Bs ? we = 36012 : Ee.type === Mo && (we = 33190)); const Pe = Je(D); je(D) ? p.renderbufferStorageMultisampleEXT(36161, Pe, we, D.width, D.height) : n.renderbufferStorageMultisample(36161, Pe, we, D.width, D.height) } else n.renderbufferStorage(36161, we, D.width, D.height); n.framebufferRenderbuffer(36160, 36096, 36161, k) } else if (D.depthBuffer && D.stencilBuffer) { const we = Je(D); se && je(D) === !1 ? n.renderbufferStorageMultisample(36161, we, 35056, D.width, D.height) : je(D) ? p.renderbufferStorageMultisampleEXT(36161, we, 35056, D.width, D.height) : n.renderbufferStorage(36161, 34041, D.width, D.height), n.framebufferRenderbuffer(36160, 33306, 36161, k) } else { const we = D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture]; for (let Ee = 0; Ee < we.length; Ee++) { const Pe = we[Ee], tt = s.convert(Pe.format, Pe.encoding), Ie = s.convert(Pe.type), me = E(Pe.internalFormat, tt, Ie, Pe.encoding), Xe = Je(D); se && je(D) === !1 ? n.renderbufferStorageMultisample(36161, Xe, me, D.width, D.height) : je(D) ? p.renderbufferStorageMultisampleEXT(36161, Xe, me, D.width, D.height) : n.renderbufferStorage(36161, me, D.width, D.height) } } n.bindRenderbuffer(36161, null) } function de(k, D) { if (D && D.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, k), !(D.depthTexture && D.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!i.get(D.depthTexture).__webglTexture || D.depthTexture.image.width !== D.width || D.depthTexture.image.height !== D.height) && (D.depthTexture.image.width = D.width, D.depthTexture.image.height = D.height, D.depthTexture.needsUpdate = !0), Y(D.depthTexture, 0); const we = i.get(D.depthTexture).__webglTexture, Ee = Je(D); if (D.depthTexture.format === Do) je(D) ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, we, 0, Ee) : n.framebufferTexture2D(36160, 36096, 3553, we, 0); else if (D.depthTexture.format === $a) je(D) ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, we, 0, Ee) : n.framebufferTexture2D(36160, 33306, 3553, we, 0); else throw new Error("Unknown depthTexture format") } function ae(k) { const D = i.get(k), se = k.isWebGLCubeRenderTarget === !0; if (k.depthTexture && !D.__autoAllocateDepthBuffer) { if (se) throw new Error("target.depthTexture not supported in Cube render targets"); de(D.__webglFramebuffer, k) } else if (se) { D.__webglDepthbuffer = []; for (let we = 0; we < 6; we++)t.bindFramebuffer(36160, D.__webglFramebuffer[we]), D.__webglDepthbuffer[we] = n.createRenderbuffer(), De(D.__webglDepthbuffer[we], k, !1) } else t.bindFramebuffer(36160, D.__webglFramebuffer), D.__webglDepthbuffer = n.createRenderbuffer(), De(D.__webglDepthbuffer, k, !1); t.bindFramebuffer(36160, null) } function Ce(k, D, se) { const we = i.get(k); D !== void 0 && Me(we.__webglFramebuffer, k, k.texture, 36064, 3553), se !== void 0 && ae(k) } function ze(k) { const D = k.texture, se = i.get(k), we = i.get(D); k.addEventListener("dispose", q), k.isWebGLMultipleRenderTargets !== !0 && (we.__webglTexture === void 0 && (we.__webglTexture = n.createTexture()), we.__version = D.version, o.memory.textures++); const Ee = k.isWebGLCubeRenderTarget === !0, Pe = k.isWebGLMultipleRenderTargets === !0, tt = S(k) || a; if (Ee) { se.__webglFramebuffer = []; for (let Ie = 0; Ie < 6; Ie++)se.__webglFramebuffer[Ie] = n.createFramebuffer() } else { if (se.__webglFramebuffer = n.createFramebuffer(), Pe) if (r.drawBuffers) { const Ie = k.texture; for (let me = 0, Xe = Ie.length; me < Xe; me++) { const H = i.get(Ie[me]); H.__webglTexture === void 0 && (H.__webglTexture = n.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && k.samples > 0 && je(k) === !1) { const Ie = Pe ? D : [D]; se.__webglMultisampledFramebuffer = n.createFramebuffer(), se.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, se.__webglMultisampledFramebuffer); for (let me = 0; me < Ie.length; me++) { const Xe = Ie[me]; se.__webglColorRenderbuffer[me] = n.createRenderbuffer(), n.bindRenderbuffer(36161, se.__webglColorRenderbuffer[me]); const H = s.convert(Xe.format, Xe.encoding), le = s.convert(Xe.type), _e = E(Xe.internalFormat, H, le, Xe.encoding, k.isXRRenderTarget === !0), be = Je(k); n.renderbufferStorageMultisample(36161, be, _e, k.width, k.height), n.framebufferRenderbuffer(36160, 36064 + me, 36161, se.__webglColorRenderbuffer[me]) } n.bindRenderbuffer(36161, null), k.depthBuffer && (se.__webglDepthRenderbuffer = n.createRenderbuffer(), De(se.__webglDepthRenderbuffer, k, !0)), t.bindFramebuffer(36160, null) } } if (Ee) { t.bindTexture(34067, we.__webglTexture), $(34067, D, tt); for (let Ie = 0; Ie < 6; Ie++)Me(se.__webglFramebuffer[Ie], k, D, 36064, 34069 + Ie); P(D, tt) && R(34067), t.unbindTexture() } else if (Pe) { const Ie = k.texture; for (let me = 0, Xe = Ie.length; me < Xe; me++) { const H = Ie[me], le = i.get(H); t.bindTexture(3553, le.__webglTexture), $(3553, H, tt), Me(se.__webglFramebuffer, k, H, 36064 + me, 3553), P(H, tt) && R(3553) } t.unbindTexture() } else { let Ie = 3553; (k.isWebGL3DRenderTarget || k.isWebGLArrayRenderTarget) && (a ? Ie = k.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Ie, we.__webglTexture), $(Ie, D, tt), Me(se.__webglFramebuffer, k, D, 36064, Ie), P(D, tt) && R(Ie), t.unbindTexture() } k.depthBuffer && ae(k) } function Be(k) { const D = S(k) || a, se = k.isWebGLMultipleRenderTargets === !0 ? k.texture : [k.texture]; for (let we = 0, Ee = se.length; we < Ee; we++) { const Pe = se[we]; if (P(Pe, D)) { const tt = k.isWebGLCubeRenderTarget ? 34067 : 3553, Ie = i.get(Pe).__webglTexture; t.bindTexture(tt, Ie), R(tt), t.unbindTexture() } } } function Ze(k) { if (a && k.samples > 0 && je(k) === !1) { const D = k.isWebGLMultipleRenderTargets ? k.texture : [k.texture], se = k.width, we = k.height; let Ee = 16384; const Pe = [], tt = k.stencilBuffer ? 33306 : 36096, Ie = i.get(k), me = k.isWebGLMultipleRenderTargets === !0; if (me) for (let Xe = 0; Xe < D.length; Xe++)t.bindFramebuffer(36160, Ie.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, null), t.bindFramebuffer(36160, Ie.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Xe, 3553, null, 0); t.bindFramebuffer(36008, Ie.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, Ie.__webglFramebuffer); for (let Xe = 0; Xe < D.length; Xe++) { Pe.push(36064 + Xe), k.depthBuffer && Pe.push(tt); const H = Ie.__ignoreDepthValues !== void 0 ? Ie.__ignoreDepthValues : !1; if (H === !1 && (k.depthBuffer && (Ee |= 256), k.stencilBuffer && (Ee |= 1024)), me && n.framebufferRenderbuffer(36008, 36064, 36161, Ie.__webglColorRenderbuffer[Xe]), H === !0 && (n.invalidateFramebuffer(36008, [tt]), n.invalidateFramebuffer(36009, [tt])), me) { const le = i.get(D[Xe]).__webglTexture; n.framebufferTexture2D(36009, 36064, 3553, le, 0) } n.blitFramebuffer(0, 0, se, we, 0, 0, se, we, Ee, 9728), m && n.invalidateFramebuffer(36008, Pe) } if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), me) for (let Xe = 0; Xe < D.length; Xe++) { t.bindFramebuffer(36160, Ie.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(36160, 36064 + Xe, 36161, Ie.__webglColorRenderbuffer[Xe]); const H = i.get(D[Xe]).__webglTexture; t.bindFramebuffer(36160, Ie.__webglFramebuffer), n.framebufferTexture2D(36009, 36064 + Xe, 3553, H, 0) } t.bindFramebuffer(36009, Ie.__webglMultisampledFramebuffer) } } function Je(k) { return Math.min(h, k.samples) } function je(k) { const D = i.get(k); return a && k.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && D.__useRenderToTexture !== !1 } function vt(k) { const D = o.render.frame; v.get(k) !== D && (v.set(k, D), k.update()) } function wt(k, D) { const se = k.encoding, we = k.format, Ee = k.type; return k.isCompressedTexture === !0 || k.isVideoTexture === !0 || k.format === zm || se !== Vs && (se === Ct ? a === !1 ? e.has("EXT_sRGB") === !0 && we === Ai ? (k.format = zm, k.minFilter = en, k.generateMipmaps = !1) : D = zA.sRGBToLinear(D) : (we !== Ai || Ee !== Hs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", se)), D } this.allocateTextureUnit = N, this.resetTextureUnits = oe, this.setTexture2D = Y, this.setTexture2DArray = re, this.setTexture3D = j, this.setTextureCube = ie, this.rebindTextures = Ce, this.setupRenderTarget = ze, this.updateRenderTargetMipmap = Be, this.updateMultisampleRenderTarget = Ze, this.setupDepthRenderbuffer = ae, this.setupFrameBufferTexture = Me, this.useMultisampledRTT = je } function CB(n, e, t) { const i = t.isWebGL2; function r(s, o = null) { let a; if (s === Hs) return 5121; if (s === KP) return 32819; if (s === QP) return 32820; if (s === JP) return 5120; if (s === XP) return 5122; if (s === FA) return 5123; if (s === YP) return 5124; if (s === Mo) return 5125; if (s === Bs) return 5126; if (s === Pu) return i ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (s === ZP) return 6406; if (s === Ai) return 6408; if (s === qP) return 6409; if (s === $P) return 6410; if (s === Do) return 6402; if (s === $a) return 34041; if (s === zm) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (s === eB) return 6403; if (s === tB) return 36244; if (s === nB) return 33319; if (s === iB) return 33320; if (s === rB) return 36249; if (s === nm || s === im || s === rm || s === sm) if (o === Ct) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (s === nm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === im) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === rm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === sm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (s === nm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === im) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === rm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === sm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === Tx || s === bx || s === Px || s === Bx) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (s === Tx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === bx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === Px) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === Bx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === sB) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (s === Rx || s === Lx) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) { if (s === Rx) return o === Ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (s === Lx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === Dx || s === Ix || s === Fx || s === Nx || s === Ox || s === kx || s === Ux || s === zx || s === Gx || s === Hx || s === Vx || s === Wx || s === jx || s === Jx) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) { if (s === Dx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === Ix) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === Fx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === Nx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === Ox) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === kx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === Ux) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === zx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === Gx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === Hx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === Vx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === Wx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === jx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === Jx) return o === Ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === om) if (a = e.get("EXT_texture_compression_bptc"), a !== null) { if (s === om) return o === Ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } else return null; if (s === oB || s === Xx || s === Yx || s === Kx) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) { if (s === om) return a.COMPRESSED_RED_RGTC1_EXT; if (s === Xx) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === Yx) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === Kx) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === Ha ? i ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null } return { convert: r } } class EB extends Gt { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class Ls extends bt { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const Fz = { type: "move" }; class jy { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new Ls, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new Ls, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new I, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new I), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new Ls, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new I, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new I), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const i of e.hand.values()) this._getHandJoint(t, i) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, t, i) { let r = null, s = null, o = null; const a = this._targetRay, l = this._grip, f = this._hand; if (e && t.session.visibilityState !== "visible-blurred") { if (f && e.hand) { o = !0; for (const y of e.hand.values()) { const x = t.getJointPose(y, i), A = this._getHandJoint(f, y); x !== null && (A.matrix.fromArray(x.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.jointRadius = x.radius), A.visible = x !== null } const d = f.joints["index-finger-tip"], h = f.joints["thumb-tip"], p = d.position.distanceTo(h.position), m = .02, v = .005; f.inputState.pinching && p > m + v ? (f.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !f.inputState.pinching && p <= m - v && (f.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1)); a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Fz))) } return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), f !== null && (f.visible = o !== null), this } _getHandJoint(e, t) { if (e.joints[t.jointName] === void 0) { const i = new Ls; i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i) } return e.joints[t.jointName] } } class TB extends Qt { constructor(e, t, i, r, s, o, a, l, f, d) { if (d = d !== void 0 ? d : Do, d !== Do && d !== $a) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); i === void 0 && d === Do && (i = Mo), i === void 0 && d === $a && (i = Ha), super(null, r, s, o, a, l, d, i, f), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : fn, this.minFilter = l !== void 0 ? l : fn, this.flipY = !1, this.generateMipmaps = !1 } } class Nz extends os { constructor(e, t) { super(); const i = this; let r = null, s = 1, o = null, a = "local-floor", l = 1, f = null, d = null, h = null, p = null, m = null, v = null; const y = t.getContextAttributes(); let x = null, A = null; const _ = [], w = [], S = new Set, T = new Map, P = new Gt; P.layers.enable(1), P.viewport = new Nt; const R = new Gt; R.layers.enable(2), R.viewport = new Nt; const E = [P, R], B = new EB; B.layers.enable(1), B.layers.enable(2); let L = null, U = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (j) { let ie = _[j]; return ie === void 0 && (ie = new jy, _[j] = ie), ie.getTargetRaySpace() }, this.getControllerGrip = function (j) { let ie = _[j]; return ie === void 0 && (ie = new jy, _[j] = ie), ie.getGripSpace() }, this.getHand = function (j) { let ie = _[j]; return ie === void 0 && (ie = new jy, _[j] = ie), ie.getHandSpace() }; function q(j) { const ie = w.indexOf(j.inputSource); if (ie === -1) return; const ve = _[ie]; ve !== void 0 && ve.dispatchEvent({ type: j.type, data: j.inputSource }) } function W() { r.removeEventListener("select", q), r.removeEventListener("selectstart", q), r.removeEventListener("selectend", q), r.removeEventListener("squeeze", q), r.removeEventListener("squeezestart", q), r.removeEventListener("squeezeend", q), r.removeEventListener("end", W), r.removeEventListener("inputsourceschange", G); for (let j = 0; j < _.length; j++) { const ie = w[j]; ie !== null && (w[j] = null, _[j].disconnect(ie)) } L = null, U = null, e.setRenderTarget(x), m = null, p = null, h = null, r = null, A = null, re.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (j) { s = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (j) { a = j, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return f || o }, this.setReferenceSpace = function (j) { f = j }, this.getBaseLayer = function () { return p !== null ? p : m }, this.getBinding = function () { return h }, this.getFrame = function () { return v }, this.getSession = function () { return r }, this.setSession = async function (j) { if (r = j, r !== null) { if (x = e.getRenderTarget(), r.addEventListener("select", q), r.addEventListener("selectstart", q), r.addEventListener("selectend", q), r.addEventListener("squeeze", q), r.addEventListener("squeezestart", q), r.addEventListener("squeezeend", q), r.addEventListener("end", W), r.addEventListener("inputsourceschange", G), y.xrCompatible !== !0 && await t.makeXRCompatible(), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const ie = { antialias: r.renderState.layers === void 0 ? y.antialias : !0, alpha: y.alpha, depth: y.depth, stencil: y.stencil, framebufferScaleFactor: s }; m = new XRWebGLLayer(r, t, ie), r.updateRenderState({ baseLayer: m }), A = new Nr(m.framebufferWidth, m.framebufferHeight, { format: Ai, type: Hs, encoding: e.outputEncoding, stencilBuffer: y.stencil }) } else { let ie = null, ve = null, Ae = null; y.depth && (Ae = y.stencil ? 35056 : 33190, ie = y.stencil ? $a : Do, ve = y.stencil ? Ha : Mo); const $ = { colorFormat: 32856, depthFormat: Ae, scaleFactor: s }; h = new XRWebGLBinding(r, t), p = h.createProjectionLayer($), r.updateRenderState({ layers: [p] }), A = new Nr(p.textureWidth, p.textureHeight, { format: Ai, type: Hs, depthTexture: new TB(p.textureWidth, p.textureHeight, ve, void 0, void 0, void 0, void 0, void 0, void 0, ie), stencilBuffer: y.stencil, encoding: e.outputEncoding, samples: y.antialias ? 4 : 0 }); const Oe = e.properties.get(A); Oe.__ignoreDepthValues = p.ignoreDepthValues } A.isXRRenderTarget = !0, this.setFoveation(l), f = null, o = await r.requestReferenceSpace(a), re.setContext(r), re.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" }) } }; function G(j) { for (let ie = 0; ie < j.removed.length; ie++) { const ve = j.removed[ie], Ae = w.indexOf(ve); Ae >= 0 && (w[Ae] = null, _[Ae].disconnect(ve)) } for (let ie = 0; ie < j.added.length; ie++) { const ve = j.added[ie]; let Ae = w.indexOf(ve); if (Ae === -1) { for (let Oe = 0; Oe < _.length; Oe++)if (Oe >= w.length) { w.push(ve), Ae = Oe; break } else if (w[Oe] === null) { w[Oe] = ve, Ae = Oe; break } if (Ae === -1) break } const $ = _[Ae]; $ && $.connect(ve) } } const K = new I, ne = new I; function oe(j, ie, ve) { K.setFromMatrixPosition(ie.matrixWorld), ne.setFromMatrixPosition(ve.matrixWorld); const Ae = K.distanceTo(ne), $ = ie.projectionMatrix.elements, Oe = ve.projectionMatrix.elements, ke = $[14] / ($[10] - 1), He = $[14] / ($[10] + 1), Me = ($[9] + 1) / $[5], De = ($[9] - 1) / $[5], de = ($[8] - 1) / $[0], ae = (Oe[8] + 1) / Oe[0], Ce = ke * de, ze = ke * ae, Be = Ae / (-de + ae), Ze = Be * -de; ie.matrixWorld.decompose(j.position, j.quaternion, j.scale), j.translateX(Ze), j.translateZ(Be), j.matrixWorld.compose(j.position, j.quaternion, j.scale), j.matrixWorldInverse.copy(j.matrixWorld).invert(); const Je = ke + Be, je = He + Be, vt = Ce - Ze, wt = ze + (Ae - Ze), k = Me * He / je * Je, D = De * He / je * Je; j.projectionMatrix.makePerspective(vt, wt, k, D, Je, je) } function N(j, ie) { ie === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(ie.matrixWorld, j.matrix), j.matrixWorldInverse.copy(j.matrixWorld).invert() } this.updateCamera = function (j) { if (r === null) return; B.near = R.near = P.near = j.near, B.far = R.far = P.far = j.far, (L !== B.near || U !== B.far) && (r.updateRenderState({ depthNear: B.near, depthFar: B.far }), L = B.near, U = B.far); const ie = j.parent, ve = B.cameras; N(B, ie); for (let $ = 0; $ < ve.length; $++)N(ve[$], ie); B.matrixWorld.decompose(B.position, B.quaternion, B.scale), j.matrix.copy(B.matrix), j.matrix.decompose(j.position, j.quaternion, j.scale); const Ae = j.children; for (let $ = 0, Oe = Ae.length; $ < Oe; $++)Ae[$].updateMatrixWorld(!0); ve.length === 2 ? oe(B, P, R) : B.projectionMatrix.copy(P.projectionMatrix) }, this.getCamera = function () { return B }, this.getFoveation = function () { if (!(p === null && m === null)) return l }, this.setFoveation = function (j) { l = j, p !== null && (p.fixedFoveation = j), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = j) }, this.getPlanes = function () { return S }; let V = null; function Y(j, ie) { if (d = ie.getViewerPose(f || o), v = ie, d !== null) { const ve = d.views; m !== null && (e.setRenderTargetFramebuffer(A, m.framebuffer), e.setRenderTarget(A)); let Ae = !1; ve.length !== B.cameras.length && (B.cameras.length = 0, Ae = !0); for (let $ = 0; $ < ve.length; $++) { const Oe = ve[$]; let ke = null; if (m !== null) ke = m.getViewport(Oe); else { const Me = h.getViewSubImage(p, Oe); ke = Me.viewport, $ === 0 && (e.setRenderTargetTextures(A, Me.colorTexture, p.ignoreDepthValues ? void 0 : Me.depthStencilTexture), e.setRenderTarget(A)) } let He = E[$]; He === void 0 && (He = new Gt, He.layers.enable($), He.viewport = new Nt, E[$] = He), He.matrix.fromArray(Oe.transform.matrix), He.projectionMatrix.fromArray(Oe.projectionMatrix), He.viewport.set(ke.x, ke.y, ke.width, ke.height), $ === 0 && B.matrix.copy(He.matrix), Ae === !0 && B.cameras.push(He) } } for (let ve = 0; ve < _.length; ve++) { const Ae = w[ve], $ = _[ve]; Ae !== null && $ !== void 0 && $.update(Ae, ie, f || o) } if (V && V(j, ie), ie.detectedPlanes) { i.dispatchEvent({ type: "planesdetected", data: ie.detectedPlanes }); let ve = null; for (const Ae of S) ie.detectedPlanes.has(Ae) || (ve === null && (ve = []), ve.push(Ae)); if (ve !== null) for (const Ae of ve) S.delete(Ae), T.delete(Ae), i.dispatchEvent({ type: "planeremoved", data: Ae }); for (const Ae of ie.detectedPlanes) if (!S.has(Ae)) S.add(Ae), T.set(Ae, ie.lastChangedTime), i.dispatchEvent({ type: "planeadded", data: Ae }); else { const $ = T.get(Ae); Ae.lastChangedTime > $ && (T.set(Ae, Ae.lastChangedTime), i.dispatchEvent({ type: "planechanged", data: Ae })) } } v = null } const re = new AB; re.setAnimationLoop(Y), this.setAnimationLoop = function (j) { V = j }, this.dispose = function () { } } } function Oz(n, e) { function t(y, x) { x.color.getRGB(y.fogColor.value, vB(n)), x.isFog ? (y.fogNear.value = x.near, y.fogFar.value = x.far) : x.isFogExp2 && (y.fogDensity.value = x.density) } function i(y, x, A, _, w) { x.isMeshBasicMaterial || x.isMeshLambertMaterial ? r(y, x) : x.isMeshToonMaterial ? (r(y, x), d(y, x)) : x.isMeshPhongMaterial ? (r(y, x), f(y, x)) : x.isMeshStandardMaterial ? (r(y, x), h(y, x), x.isMeshPhysicalMaterial && p(y, x, w)) : x.isMeshMatcapMaterial ? (r(y, x), m(y, x)) : x.isMeshDepthMaterial ? r(y, x) : x.isMeshDistanceMaterial ? (r(y, x), v(y, x)) : x.isMeshNormalMaterial ? r(y, x) : x.isLineBasicMaterial ? (s(y, x), x.isLineDashedMaterial && o(y, x)) : x.isPointsMaterial ? a(y, x, A, _) : x.isSpriteMaterial ? l(y, x) : x.isShadowMaterial ? (y.color.value.copy(x.color), y.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1) } function r(y, x) { y.opacity.value = x.opacity, x.color && y.diffuse.value.copy(x.color), x.emissive && y.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.bumpMap && (y.bumpMap.value = x.bumpMap, y.bumpScale.value = x.bumpScale, x.side === Ei && (y.bumpScale.value *= -1)), x.displacementMap && (y.displacementMap.value = x.displacementMap, y.displacementScale.value = x.displacementScale, y.displacementBias.value = x.displacementBias), x.emissiveMap && (y.emissiveMap.value = x.emissiveMap), x.normalMap && (y.normalMap.value = x.normalMap, y.normalScale.value.copy(x.normalScale), x.side === Ei && y.normalScale.value.negate()), x.specularMap && (y.specularMap.value = x.specularMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); const A = e.get(x).envMap; if (A && (y.envMap.value = A, y.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = x.reflectivity, y.ior.value = x.ior, y.refractionRatio.value = x.refractionRatio), x.lightMap) { y.lightMap.value = x.lightMap; const S = n.physicallyCorrectLights !== !0 ? Math.PI : 1; y.lightMapIntensity.value = x.lightMapIntensity * S } x.aoMap && (y.aoMap.value = x.aoMap, y.aoMapIntensity.value = x.aoMapIntensity); let _; x.map ? _ = x.map : x.specularMap ? _ = x.specularMap : x.displacementMap ? _ = x.displacementMap : x.normalMap ? _ = x.normalMap : x.bumpMap ? _ = x.bumpMap : x.roughnessMap ? _ = x.roughnessMap : x.metalnessMap ? _ = x.metalnessMap : x.alphaMap ? _ = x.alphaMap : x.emissiveMap ? _ = x.emissiveMap : x.clearcoatMap ? _ = x.clearcoatMap : x.clearcoatNormalMap ? _ = x.clearcoatNormalMap : x.clearcoatRoughnessMap ? _ = x.clearcoatRoughnessMap : x.iridescenceMap ? _ = x.iridescenceMap : x.iridescenceThicknessMap ? _ = x.iridescenceThicknessMap : x.specularIntensityMap ? _ = x.specularIntensityMap : x.specularColorMap ? _ = x.specularColorMap : x.transmissionMap ? _ = x.transmissionMap : x.thicknessMap ? _ = x.thicknessMap : x.sheenColorMap ? _ = x.sheenColorMap : x.sheenRoughnessMap && (_ = x.sheenRoughnessMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), y.uvTransform.value.copy(_.matrix)); let w; x.aoMap ? w = x.aoMap : x.lightMap && (w = x.lightMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === !0 && w.updateMatrix(), y.uv2Transform.value.copy(w.matrix)) } function s(y, x) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity } function o(y, x) { y.dashSize.value = x.dashSize, y.totalSize.value = x.dashSize + x.gapSize, y.scale.value = x.scale } function a(y, x, A, _) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity, y.size.value = x.size * A, y.scale.value = _ * .5, x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); let w; x.map ? w = x.map : x.alphaMap && (w = x.alphaMap), w !== void 0 && (w.matrixAutoUpdate === !0 && w.updateMatrix(), y.uvTransform.value.copy(w.matrix)) } function l(y, x) { y.diffuse.value.copy(x.color), y.opacity.value = x.opacity, y.rotation.value = x.rotation, x.map && (y.map.value = x.map), x.alphaMap && (y.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (y.alphaTest.value = x.alphaTest); let A; x.map ? A = x.map : x.alphaMap && (A = x.alphaMap), A !== void 0 && (A.matrixAutoUpdate === !0 && A.updateMatrix(), y.uvTransform.value.copy(A.matrix)) } function f(y, x) { y.specular.value.copy(x.specular), y.shininess.value = Math.max(x.shininess, 1e-4) } function d(y, x) { x.gradientMap && (y.gradientMap.value = x.gradientMap) } function h(y, x) { y.roughness.value = x.roughness, y.metalness.value = x.metalness, x.roughnessMap && (y.roughnessMap.value = x.roughnessMap), x.metalnessMap && (y.metalnessMap.value = x.metalnessMap), e.get(x).envMap && (y.envMapIntensity.value = x.envMapIntensity) } function p(y, x, A) { y.ior.value = x.ior, x.sheen > 0 && (y.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen), y.sheenRoughness.value = x.sheenRoughness, x.sheenColorMap && (y.sheenColorMap.value = x.sheenColorMap), x.sheenRoughnessMap && (y.sheenRoughnessMap.value = x.sheenRoughnessMap)), x.clearcoat > 0 && (y.clearcoat.value = x.clearcoat, y.clearcoatRoughness.value = x.clearcoatRoughness, x.clearcoatMap && (y.clearcoatMap.value = x.clearcoatMap), x.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap), x.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), y.clearcoatNormalMap.value = x.clearcoatNormalMap, x.side === Ei && y.clearcoatNormalScale.value.negate())), x.iridescence > 0 && (y.iridescence.value = x.iridescence, y.iridescenceIOR.value = x.iridescenceIOR, y.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1], x.iridescenceMap && (y.iridescenceMap.value = x.iridescenceMap), x.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = x.iridescenceThicknessMap)), x.transmission > 0 && (y.transmission.value = x.transmission, y.transmissionSamplerMap.value = A.texture, y.transmissionSamplerSize.value.set(A.width, A.height), x.transmissionMap && (y.transmissionMap.value = x.transmissionMap), y.thickness.value = x.thickness, x.thicknessMap && (y.thicknessMap.value = x.thicknessMap), y.attenuationDistance.value = x.attenuationDistance, y.attenuationColor.value.copy(x.attenuationColor)), y.specularIntensity.value = x.specularIntensity, y.specularColor.value.copy(x.specularColor), x.specularIntensityMap && (y.specularIntensityMap.value = x.specularIntensityMap), x.specularColorMap && (y.specularColorMap.value = x.specularColorMap) } function m(y, x) { x.matcap && (y.matcap.value = x.matcap) } function v(y, x) { y.referencePosition.value.copy(x.referencePosition), y.nearDistance.value = x.nearDistance, y.farDistance.value = x.farDistance } return { refreshFogUniforms: t, refreshMaterialUniforms: i } } function kz(n, e, t, i) { let r = {}, s = {}, o = []; const a = t.isWebGL2 ? n.getParameter(35375) : 0; function l(_, w) { const S = w.program; i.uniformBlockBinding(_, S) } function f(_, w) { let S = r[_.id]; S === void 0 && (v(_), S = d(_), r[_.id] = S, _.addEventListener("dispose", x)); const T = w.program; i.updateUBOMapping(_, T); const P = e.render.frame; s[_.id] !== P && (p(_), s[_.id] = P) } function d(_) { const w = h(); _.__bindingPointIndex = w; const S = n.createBuffer(), T = _.__size, P = _.usage; return n.bindBuffer(35345, S), n.bufferData(35345, T, P), n.bindBuffer(35345, null), n.bindBufferBase(35345, w, S), S } function h() { for (let _ = 0; _ < a; _++)if (o.indexOf(_) === -1) return o.push(_), _; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function p(_) { const w = r[_.id], S = _.uniforms, T = _.__cache; n.bindBuffer(35345, w); for (let P = 0, R = S.length; P < R; P++) { const E = S[P]; if (m(E, P, T) === !0) { const B = E.__offset, L = Array.isArray(E.value) ? E.value : [E.value]; let U = 0; for (let q = 0; q < L.length; q++) { const W = L[q], G = y(W); typeof W == "number" ? (E.__data[0] = W, n.bufferSubData(35345, B + U, E.__data)) : W.isMatrix3 ? (E.__data[0] = W.elements[0], E.__data[1] = W.elements[1], E.__data[2] = W.elements[2], E.__data[3] = W.elements[0], E.__data[4] = W.elements[3], E.__data[5] = W.elements[4], E.__data[6] = W.elements[5], E.__data[7] = W.elements[0], E.__data[8] = W.elements[6], E.__data[9] = W.elements[7], E.__data[10] = W.elements[8], E.__data[11] = W.elements[0]) : (W.toArray(E.__data, U), U += G.storage / Float32Array.BYTES_PER_ELEMENT) } n.bufferSubData(35345, B, E.__data) } } n.bindBuffer(35345, null) } function m(_, w, S) { const T = _.value; if (S[w] === void 0) { if (typeof T == "number") S[w] = T; else { const P = Array.isArray(T) ? T : [T], R = []; for (let E = 0; E < P.length; E++)R.push(P[E].clone()); S[w] = R } return !0 } else if (typeof T == "number") { if (S[w] !== T) return S[w] = T, !0 } else { const P = Array.isArray(S[w]) ? S[w] : [S[w]], R = Array.isArray(T) ? T : [T]; for (let E = 0; E < P.length; E++) { const B = P[E]; if (B.equals(R[E]) === !1) return B.copy(R[E]), !0 } } return !1 } function v(_) { const w = _.uniforms; let S = 0; const T = 16; let P = 0; for (let R = 0, E = w.length; R < E; R++) { const B = w[R], L = { boundary: 0, storage: 0 }, U = Array.isArray(B.value) ? B.value : [B.value]; for (let q = 0, W = U.length; q < W; q++) { const G = U[q], K = y(G); L.boundary += K.boundary, L.storage += K.storage } if (B.__data = new Float32Array(L.storage / Float32Array.BYTES_PER_ELEMENT), B.__offset = S, R > 0) { P = S % T; const q = T - P; P !== 0 && q - L.boundary < 0 && (S += T - P, B.__offset = S) } S += L.storage } return P = S % T, P > 0 && (S += T - P), _.__size = S, _.__cache = {}, this } function y(_) { const w = { boundary: 0, storage: 0 }; return typeof _ == "number" ? (w.boundary = 4, w.storage = 4) : _.isVector2 ? (w.boundary = 8, w.storage = 8) : _.isVector3 || _.isColor ? (w.boundary = 16, w.storage = 12) : _.isVector4 ? (w.boundary = 16, w.storage = 16) : _.isMatrix3 ? (w.boundary = 48, w.storage = 48) : _.isMatrix4 ? (w.boundary = 64, w.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), w } function x(_) { const w = _.target; w.removeEventListener("dispose", x); const S = o.indexOf(w.__bindingPointIndex); o.splice(S, 1), n.deleteBuffer(r[w.id]), delete r[w.id], delete s[w.id] } function A() { for (const _ in r) n.deleteBuffer(r[_]); o = [], r = {}, s = {} } return { bind: l, update: f, dispose: A } } function Uz() { const n = jf("canvas"); return n.style.display = "block", n } function KA(n = {}) { this.isWebGLRenderer = !0; const e = n.canvas !== void 0 ? n.canvas : Uz(), t = n.context !== void 0 ? n.context : null, i = n.depth !== void 0 ? n.depth : !0, r = n.stencil !== void 0 ? n.stencil : !0, s = n.antialias !== void 0 ? n.antialias : !1, o = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0, a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1, l = n.powerPreference !== void 0 ? n.powerPreference : "default", f = n.failIfMajorPerformanceCaveat !== void 0 ? n.failIfMajorPerformanceCaveat : !1; let d; t !== null ? d = t.getContextAttributes().alpha : d = n.alpha !== void 0 ? n.alpha : !1; let h = null, p = null; const m = [], v = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Vs, this.physicallyCorrectLights = !1, this.toneMapping = Dr, this.toneMappingExposure = 1; const y = this; let x = !1, A = 0, _ = 0, w = null, S = -1, T = null; const P = new Nt, R = new Nt; let E = null, B = e.width, L = e.height, U = 1, q = null, W = null; const G = new Nt(0, 0, B, L), K = new Nt(0, 0, B, L); let ne = !1; const oe = new wg; let N = !1, V = !1, Y = null; const re = new it, j = new pe, ie = new I, ve = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function Ae() { return w === null ? U : 1 } let $ = t; function Oe(F, ee) { for (let he = 0; he < F.length; he++) { const Z = F[he], ge = e.getContext(Z, ee); if (ge !== null) return ge } return null } try { const F = { alpha: !0, depth: i, stencil: r, antialias: s, premultipliedAlpha: o, preserveDrawingBuffer: a, powerPreference: l, failIfMajorPerformanceCaveat: f }; if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${yg}`), e.addEventListener("webglcontextlost", _e, !1), e.addEventListener("webglcontextrestored", be, !1), e.addEventListener("webglcontextcreationerror", $e, !1), $ === null) { const ee = ["webgl2", "webgl", "experimental-webgl"]; if (y.isWebGL1Renderer === !0 && ee.shift(), $ = Oe(ee, F), $ === null) throw Oe(ee) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } $.getShaderPrecisionFormat === void 0 && ($.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (F) { throw console.error("THREE.WebGLRenderer: " + F.message), F } let ke, He, Me, De, de, ae, Ce, ze, Be, Ze, Je, je, vt, wt, k, D, se, we, Ee, Pe, tt, Ie, me, Xe; function H() { ke = new t4($), He = new KU($, ke, n), ke.init(He), Ie = new CB($, ke, He), Me = new Dz($, ke, He), De = new r4, de = new _z, ae = new Iz($, ke, Me, de, He, Ie, De), Ce = new ZU(y), ze = new e4(y), Be = new hO($, He), me = new XU($, ke, Be, He), Ze = new n4($, Be, De, me), Je = new l4($, Ze, Be, De), Ee = new a4($, He, ae), D = new QU(de), je = new Az(y, Ce, ze, ke, He, me, D), vt = new Oz(y, de), wt = new wz, k = new Pz(ke, He), we = new JU(y, Ce, ze, Me, Je, d, o), se = new Lz(y, Je, He), Xe = new kz($, De, He, Me), Pe = new YU($, ke, De, He), tt = new i4($, ke, De, He), De.programs = je.programs, y.capabilities = He, y.extensions = ke, y.properties = de, y.renderLists = wt, y.shadowMap = se, y.state = Me, y.info = De } H(); const le = new Nz(y, $); this.xr = le, this.getContext = function () { return $ }, this.getContextAttributes = function () { return $.getContextAttributes() }, this.forceContextLoss = function () { const F = ke.get("WEBGL_lose_context"); F && F.loseContext() }, this.forceContextRestore = function () { const F = ke.get("WEBGL_lose_context"); F && F.restoreContext() }, this.getPixelRatio = function () { return U }, this.setPixelRatio = function (F) { F !== void 0 && (U = F, this.setSize(B, L, !1)) }, this.getSize = function (F) { return F.set(B, L) }, this.setSize = function (F, ee, he) { if (le.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } B = F, L = ee, e.width = Math.floor(F * U), e.height = Math.floor(ee * U), he !== !1 && (e.style.width = F + "px", e.style.height = ee + "px"), this.setViewport(0, 0, F, ee) }, this.getDrawingBufferSize = function (F) { return F.set(B * U, L * U).floor() }, this.setDrawingBufferSize = function (F, ee, he) { B = F, L = ee, U = he, e.width = Math.floor(F * he), e.height = Math.floor(ee * he), this.setViewport(0, 0, F, ee) }, this.getCurrentViewport = function (F) { return F.copy(P) }, this.getViewport = function (F) { return F.copy(G) }, this.setViewport = function (F, ee, he, Z) { F.isVector4 ? G.set(F.x, F.y, F.z, F.w) : G.set(F, ee, he, Z), Me.viewport(P.copy(G).multiplyScalar(U).floor()) }, this.getScissor = function (F) { return F.copy(K) }, this.setScissor = function (F, ee, he, Z) { F.isVector4 ? K.set(F.x, F.y, F.z, F.w) : K.set(F, ee, he, Z), Me.scissor(R.copy(K).multiplyScalar(U).floor()) }, this.getScissorTest = function () { return ne }, this.setScissorTest = function (F) { Me.setScissorTest(ne = F) }, this.setOpaqueSort = function (F) { q = F }, this.setTransparentSort = function (F) { W = F }, this.getClearColor = function (F) { return F.copy(we.getClearColor()) }, this.setClearColor = function () { we.setClearColor.apply(we, arguments) }, this.getClearAlpha = function () { return we.getClearAlpha() }, this.setClearAlpha = function () { we.setClearAlpha.apply(we, arguments) }, this.clear = function (F = !0, ee = !0, he = !0) { let Z = 0; F && (Z |= 16384), ee && (Z |= 256), he && (Z |= 1024), $.clear(Z) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", _e, !1), e.removeEventListener("webglcontextrestored", be, !1), e.removeEventListener("webglcontextcreationerror", $e, !1), wt.dispose(), k.dispose(), de.dispose(), Ce.dispose(), ze.dispose(), Je.dispose(), me.dispose(), Xe.dispose(), je.dispose(), le.dispose(), le.removeEventListener("sessionstart", Ue), le.removeEventListener("sessionend", Ke), Y && (Y.dispose(), Y = null), Pt.stop() }; function _e(F) { F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0 } function be() { console.log("THREE.WebGLRenderer: Context Restored."), x = !1; const F = De.autoReset, ee = se.enabled, he = se.autoUpdate, Z = se.needsUpdate, ge = se.type; H(), De.autoReset = F, se.enabled = ee, se.autoUpdate = he, se.needsUpdate = Z, se.type = ge } function $e(F) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage) } function yt(F) { const ee = F.target; ee.removeEventListener("dispose", yt), Vt(ee) } function Vt(F) { X(F), de.remove(F) } function X(F) { const ee = de.get(F).programs; ee !== void 0 && (ee.forEach(function (he) { je.releaseProgram(he) }), F.isShaderMaterial && je.releaseShaderCache(F)) } this.renderBufferDirect = function (F, ee, he, Z, ge, qe) { ee === null && (ee = ve); const rt = ge.isMesh && ge.matrixWorld.determinant() < 0, ft = Wg(F, ee, he, Z, ge); Me.setMaterial(Z, rt); let mt = he.index, St = 1; Z.wireframe === !0 && (mt = Ze.getWireframeAttribute(he), St = 2); const At = he.drawRange, _t = he.attributes.position; let on = At.start * St, ti = (At.start + At.count) * St; qe !== null && (on = Math.max(on, qe.start * St), ti = Math.min(ti, (qe.start + qe.count) * St)), mt !== null ? (on = Math.max(on, 0), ti = Math.min(ti, mt.count)) : _t != null && (on = Math.max(on, 0), ti = Math.min(ti, _t.count)); const yr = ti - on; if (yr < 0 || yr === 1 / 0) return; me.setup(ge, Z, ft, he, mt); let as, Jt = Pe; if (mt !== null && (as = Be.get(mt), Jt = tt, Jt.setIndex(as)), ge.isMesh) Z.wireframe === !0 ? (Me.setLineWidth(Z.wireframeLinewidth * Ae()), Jt.setMode(1)) : Jt.setMode(4); else if (ge.isLine) { let dt = Z.linewidth; dt === void 0 && (dt = 1), Me.setLineWidth(dt * Ae()), ge.isLineSegments ? Jt.setMode(1) : ge.isLineLoop ? Jt.setMode(2) : Jt.setMode(3) } else ge.isPoints ? Jt.setMode(0) : ge.isSprite && Jt.setMode(4); if (ge.isInstancedMesh) Jt.renderInstances(on, yr, ge.count); else if (he.isInstancedBufferGeometry) { const dt = he._maxInstanceCount !== void 0 ? he._maxInstanceCount : 1 / 0, $o = Math.min(he.instanceCount, dt); Jt.renderInstances(on, yr, $o) } else Jt.render(on, yr) }, this.compile = function (F, ee) { function he(Z, ge, qe) { Z.transparent === !0 && Z.side === Br && Z.forceSinglePass === !1 ? (Z.side = Ei, Z.needsUpdate = !0, pi(Z, ge, qe), Z.side = is, Z.needsUpdate = !0, pi(Z, ge, qe), Z.side = Br) : pi(Z, ge, qe) } p = k.get(F), p.init(), v.push(p), F.traverseVisible(function (Z) { Z.isLight && Z.layers.test(ee.layers) && (p.pushLight(Z), Z.castShadow && p.pushShadow(Z)) }), p.setupLights(y.physicallyCorrectLights), F.traverse(function (Z) { const ge = Z.material; if (ge) if (Array.isArray(ge)) for (let qe = 0; qe < ge.length; qe++) { const rt = ge[qe]; he(rt, F, Z) } else he(ge, F, Z) }), v.pop(), p = null }; let ce = null; function xe(F) { ce && ce(F) } function Ue() { Pt.stop() } function Ke() { Pt.start() } const Pt = new AB; Pt.setAnimationLoop(xe), typeof self < "u" && Pt.setContext(self), this.setAnimationLoop = function (F) { ce = F, le.setAnimationLoop(F), F === null ? Pt.stop() : Pt.start() }, le.addEventListener("sessionstart", Ue), le.addEventListener("sessionend", Ke), this.render = function (F, ee) { if (ee !== void 0 && ee.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (x === !0) return; F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), ee.parent === null && ee.matrixWorldAutoUpdate === !0 && ee.updateMatrixWorld(), le.enabled === !0 && le.isPresenting === !0 && (le.cameraAutoUpdate === !0 && le.updateCamera(ee), ee = le.getCamera()), F.isScene === !0 && F.onBeforeRender(y, F, ee, w), p = k.get(F, v.length), p.init(), v.push(p), re.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse), oe.setFromProjectionMatrix(re), V = this.localClippingEnabled, N = D.init(this.clippingPlanes, V), h = wt.get(F, m.length), h.init(), m.push(h), dn(F, ee, 0, y.sortObjects), h.finish(), y.sortObjects === !0 && h.sort(q, W), N === !0 && D.beginShadows(); const he = p.state.shadowsArray; if (se.render(he, F, ee), N === !0 && D.endShadows(), this.info.autoReset === !0 && this.info.reset(), we.render(h, F), p.setupLights(y.physicallyCorrectLights), ee.isArrayCamera) { const Z = ee.cameras; for (let ge = 0, qe = Z.length; ge < qe; ge++) { const rt = Z[ge]; Bn(h, F, rt, rt.viewport) } } else Bn(h, F, ee); w !== null && (ae.updateMultisampleRenderTarget(w), ae.updateRenderTargetMipmap(w)), F.isScene === !0 && F.onAfterRender(y, F, ee), me.resetDefaultState(), S = -1, T = null, v.pop(), v.length > 0 ? p = v[v.length - 1] : p = null, m.pop(), m.length > 0 ? h = m[m.length - 1] : h = null }; function dn(F, ee, he, Z) { if (F.visible === !1) return; if (F.layers.test(ee.layers)) { if (F.isGroup) he = F.renderOrder; else if (F.isLOD) F.autoUpdate === !0 && F.update(ee); else if (F.isLight) p.pushLight(F), F.castShadow && p.pushShadow(F); else if (F.isSprite) { if (!F.frustumCulled || oe.intersectsSprite(F)) { Z && ie.setFromMatrixPosition(F.matrixWorld).applyMatrix4(re); const rt = Je.update(F), ft = F.material; ft.visible && h.push(F, rt, ft, he, ie.z, null) } } else if ((F.isMesh || F.isLine || F.isPoints) && (F.isSkinnedMesh && F.skeleton.frame !== De.render.frame && (F.skeleton.update(), F.skeleton.frame = De.render.frame), !F.frustumCulled || oe.intersectsObject(F))) { Z && ie.setFromMatrixPosition(F.matrixWorld).applyMatrix4(re); const rt = Je.update(F), ft = F.material; if (Array.isArray(ft)) { const mt = rt.groups; for (let St = 0, At = mt.length; St < At; St++) { const _t = mt[St], on = ft[_t.materialIndex]; on && on.visible && h.push(F, rt, on, he, ie.z, _t) } } else ft.visible && h.push(F, rt, ft, he, ie.z, null) } } const qe = F.children; for (let rt = 0, ft = qe.length; rt < ft; rt++)dn(qe[rt], ee, he, Z) } function Bn(F, ee, he, Z) { const ge = F.opaque, qe = F.transmissive, rt = F.transparent; p.setupLightsView(he), N === !0 && D.setGlobalState(y.clippingPlanes, he), qe.length > 0 && zr(ge, ee, he), Z && Me.viewport(P.copy(Z)), ge.length > 0 && kt(ge, ee, he), qe.length > 0 && kt(qe, ee, he), rt.length > 0 && kt(rt, ee, he), Me.buffers.depth.setTest(!0), Me.buffers.depth.setMask(!0), Me.buffers.color.setMask(!0), Me.setPolygonOffset(!1) } function zr(F, ee, he) { const Z = He.isWebGL2; Y === null && (Y = new Nr(1, 1, { generateMipmaps: !0, type: ke.has("EXT_color_buffer_half_float") ? Pu : Hs, minFilter: rs, samples: Z && s === !0 ? 4 : 0 })), y.getDrawingBufferSize(j), Z ? Y.setSize(j.x, j.y) : Y.setSize(Gm(j.x), Gm(j.y)); const ge = y.getRenderTarget(); y.setRenderTarget(Y), y.clear(); const qe = y.toneMapping; y.toneMapping = Dr, kt(F, ee, he), y.toneMapping = qe, ae.updateMultisampleRenderTarget(Y), ae.updateRenderTargetMipmap(Y), y.setRenderTarget(ge) } function kt(F, ee, he) { const Z = ee.isScene === !0 ? ee.overrideMaterial : null; for (let ge = 0, qe = F.length; ge < qe; ge++) { const rt = F[ge], ft = rt.object, mt = rt.geometry, St = Z === null ? rt.material : Z, At = rt.group; ft.layers.test(he.layers) && ji(ft, ee, he, mt, St, At) } } function ji(F, ee, he, Z, ge, qe) { F.onBeforeRender(y, ee, he, Z, ge, qe), F.modelViewMatrix.multiplyMatrices(he.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), ge.onBeforeRender(y, ee, he, Z, F, qe), ge.transparent === !0 && ge.side === Br && ge.forceSinglePass === !1 ? (ge.side = Ei, ge.needsUpdate = !0, y.renderBufferDirect(he, ee, Z, ge, F, qe), ge.side = is, ge.needsUpdate = !0, y.renderBufferDirect(he, ee, Z, ge, F, qe), ge.side = Br) : y.renderBufferDirect(he, ee, Z, ge, F, qe), F.onAfterRender(y, ee, he, Z, ge, qe) } function pi(F, ee, he) { ee.isScene !== !0 && (ee = ve); const Z = de.get(F), ge = p.state.lights, qe = p.state.shadowsArray, rt = ge.state.version, ft = je.getParameters(F, ge.state, qe, ee, he), mt = je.getProgramCacheKey(ft); let St = Z.programs; Z.environment = F.isMeshStandardMaterial ? ee.environment : null, Z.fog = ee.fog, Z.envMap = (F.isMeshStandardMaterial ? ze : Ce).get(F.envMap || Z.environment), St === void 0 && (F.addEventListener("dispose", yt), St = new Map, Z.programs = St); let At = St.get(mt); if (At !== void 0) { if (Z.currentProgram === At && Z.lightsStateVersion === rt) return Od(F, ft), At } else ft.uniforms = je.getUniforms(F), F.onBuild(he, ft, y), F.onBeforeCompile(ft, y), At = je.acquireProgram(ft, mt), St.set(mt, At), Z.uniforms = ft.uniforms; const _t = Z.uniforms; (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (_t.clippingPlanes = D.uniform), Od(F, ft), Z.needsLights = $u(F), Z.lightsStateVersion = rt, Z.needsLights && (_t.ambientLightColor.value = ge.state.ambient, _t.lightProbe.value = ge.state.probe, _t.directionalLights.value = ge.state.directional, _t.directionalLightShadows.value = ge.state.directionalShadow, _t.spotLights.value = ge.state.spot, _t.spotLightShadows.value = ge.state.spotShadow, _t.rectAreaLights.value = ge.state.rectArea, _t.ltc_1.value = ge.state.rectAreaLTC1, _t.ltc_2.value = ge.state.rectAreaLTC2, _t.pointLights.value = ge.state.point, _t.pointLightShadows.value = ge.state.pointShadow, _t.hemisphereLights.value = ge.state.hemi, _t.directionalShadowMap.value = ge.state.directionalShadowMap, _t.directionalShadowMatrix.value = ge.state.directionalShadowMatrix, _t.spotShadowMap.value = ge.state.spotShadowMap, _t.spotLightMatrix.value = ge.state.spotLightMatrix, _t.spotLightMap.value = ge.state.spotLightMap, _t.pointShadowMap.value = ge.state.pointShadowMap, _t.pointShadowMatrix.value = ge.state.pointShadowMatrix); const on = At.getUniforms(), ti = cm.seqWithValue(on.seq, _t); return Z.currentProgram = At, Z.uniformsList = ti, At } function Od(F, ee) { const he = de.get(F); he.outputEncoding = ee.outputEncoding, he.instancing = ee.instancing, he.skinning = ee.skinning, he.morphTargets = ee.morphTargets, he.morphNormals = ee.morphNormals, he.morphColors = ee.morphColors, he.morphTargetsCount = ee.morphTargetsCount, he.numClippingPlanes = ee.numClippingPlanes, he.numIntersection = ee.numClipIntersection, he.vertexAlphas = ee.vertexAlphas, he.vertexTangents = ee.vertexTangents, he.toneMapping = ee.toneMapping } function Wg(F, ee, he, Z, ge) { ee.isScene !== !0 && (ee = ve), ae.resetTextureUnits(); const qe = ee.fog, rt = Z.isMeshStandardMaterial ? ee.environment : null, ft = w === null ? y.outputEncoding : w.isXRRenderTarget === !0 ? w.texture.encoding : Vs, mt = (Z.isMeshStandardMaterial ? ze : Ce).get(Z.envMap || rt), St = Z.vertexColors === !0 && !!he.attributes.color && he.attributes.color.itemSize === 4, At = !!Z.normalMap && !!he.attributes.tangent, _t = !!he.morphAttributes.position, on = !!he.morphAttributes.normal, ti = !!he.morphAttributes.color, yr = Z.toneMapped ? y.toneMapping : Dr, as = he.morphAttributes.position || he.morphAttributes.normal || he.morphAttributes.color, Jt = as !== void 0 ? as.length : 0, dt = de.get(Z), $o = p.state.lights; if (N === !0 && (V === !0 || F !== T)) { const Ft = F === T && Z.id === S; D.setState(Z, F, Ft) } let an = !1; Z.version === dt.__version ? (dt.needsLights && dt.lightsStateVersion !== $o.state.version || dt.outputEncoding !== ft || ge.isInstancedMesh && dt.instancing === !1 || !ge.isInstancedMesh && dt.instancing === !0 || ge.isSkinnedMesh && dt.skinning === !1 || !ge.isSkinnedMesh && dt.skinning === !0 || dt.envMap !== mt || Z.fog === !0 && dt.fog !== qe || dt.numClippingPlanes !== void 0 && (dt.numClippingPlanes !== D.numPlanes || dt.numIntersection !== D.numIntersection) || dt.vertexAlphas !== St || dt.vertexTangents !== At || dt.morphTargets !== _t || dt.morphNormals !== on || dt.morphColors !== ti || dt.toneMapping !== yr || He.isWebGL2 === !0 && dt.morphTargetsCount !== Jt) && (an = !0) : (an = !0, dt.__version = Z.version); let ls = dt.currentProgram; an === !0 && (ls = pi(Z, ee, ge)); let dl = !1, Ji = !1, Xi = !1; const ct = ls.getUniforms(), Et = dt.uniforms; if (Me.useProgram(ls.program) && (dl = !0, Ji = !0, Xi = !0), Z.id !== S && (S = Z.id, Ji = !0), dl || T !== F) { if (ct.setValue($, "projectionMatrix", F.projectionMatrix), He.logarithmicDepthBuffer && ct.setValue($, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)), T !== F && (T = F, Ji = !0, Xi = !0), Z.isShaderMaterial || Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshStandardMaterial || Z.envMap) { const Ft = ct.map.cameraPosition; Ft !== void 0 && Ft.setValue($, ie.setFromMatrixPosition(F.matrixWorld)) } (Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshLambertMaterial || Z.isMeshBasicMaterial || Z.isMeshStandardMaterial || Z.isShaderMaterial) && ct.setValue($, "isOrthographic", F.isOrthographicCamera === !0), (Z.isMeshPhongMaterial || Z.isMeshToonMaterial || Z.isMeshLambertMaterial || Z.isMeshBasicMaterial || Z.isMeshStandardMaterial || Z.isShaderMaterial || Z.isShadowMaterial || ge.isSkinnedMesh) && ct.setValue($, "viewMatrix", F.matrixWorldInverse) } if (ge.isSkinnedMesh) { ct.setOptional($, ge, "bindMatrix"), ct.setOptional($, ge, "bindMatrixInverse"); const Ft = ge.skeleton; Ft && (He.floatVertexTextures ? (Ft.boneTexture === null && Ft.computeBoneTexture(), ct.setValue($, "boneTexture", Ft.boneTexture, ae), ct.setValue($, "boneTextureSize", Ft.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const Yi = he.morphAttributes; if ((Yi.position !== void 0 || Yi.normal !== void 0 || Yi.color !== void 0 && He.isWebGL2 === !0) && Ee.update(ge, he, Z, ls), (Ji || dt.receiveShadow !== ge.receiveShadow) && (dt.receiveShadow = ge.receiveShadow, ct.setValue($, "receiveShadow", ge.receiveShadow)), Z.isMeshGouraudMaterial && Z.envMap !== null && (Et.envMap.value = mt, Et.flipEnvMap.value = mt.isCubeTexture && mt.isRenderTargetTexture === !1 ? -1 : 1), Ji && (ct.setValue($, "toneMappingExposure", y.toneMappingExposure), dt.needsLights && kd(Et, Xi), qe && Z.fog === !0 && vt.refreshFogUniforms(Et, qe), vt.refreshMaterialUniforms(Et, Z, U, L, Y), cm.upload($, dt.uniformsList, Et, ae)), Z.isShaderMaterial && Z.uniformsNeedUpdate === !0 && (cm.upload($, dt.uniformsList, Et, ae), Z.uniformsNeedUpdate = !1), Z.isSpriteMaterial && ct.setValue($, "center", ge.center), ct.setValue($, "modelViewMatrix", ge.modelViewMatrix), ct.setValue($, "normalMatrix", ge.normalMatrix), ct.setValue($, "modelMatrix", ge.matrixWorld), Z.isShaderMaterial || Z.isRawShaderMaterial) { const Ft = Z.uniformsGroups; for (let Rn = 0, us = Ft.length; Rn < us; Rn++)if (He.isWebGL2) { const cs = Ft[Rn]; Xe.update(cs, ls), Xe.bind(cs, ls) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return ls } function kd(F, ee) { F.ambientLightColor.needsUpdate = ee, F.lightProbe.needsUpdate = ee, F.directionalLights.needsUpdate = ee, F.directionalLightShadows.needsUpdate = ee, F.pointLights.needsUpdate = ee, F.pointLightShadows.needsUpdate = ee, F.spotLights.needsUpdate = ee, F.spotLightShadows.needsUpdate = ee, F.rectAreaLights.needsUpdate = ee, F.hemisphereLights.needsUpdate = ee } function $u(F) { return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0 } this.getActiveCubeFace = function () { return A }, this.getActiveMipmapLevel = function () { return _ }, this.getRenderTarget = function () { return w }, this.setRenderTargetTextures = function (F, ee, he) { de.get(F.texture).__webglTexture = ee, de.get(F.depthTexture).__webglTexture = he; const Z = de.get(F); Z.__hasExternalTextures = !0, Z.__hasExternalTextures && (Z.__autoAllocateDepthBuffer = he === void 0, Z.__autoAllocateDepthBuffer || ke.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Z.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (F, ee) { const he = de.get(F); he.__webglFramebuffer = ee, he.__useDefaultFramebuffer = ee === void 0 }, this.setRenderTarget = function (F, ee = 0, he = 0) { w = F, A = ee, _ = he; let Z = !0, ge = null, qe = !1, rt = !1; if (F) { const mt = de.get(F); mt.__useDefaultFramebuffer !== void 0 ? (Me.bindFramebuffer(36160, null), Z = !1) : mt.__webglFramebuffer === void 0 ? ae.setupRenderTarget(F) : mt.__hasExternalTextures && ae.rebindTextures(F, de.get(F.texture).__webglTexture, de.get(F.depthTexture).__webglTexture); const St = F.texture; (St.isData3DTexture || St.isDataArrayTexture || St.isCompressedArrayTexture) && (rt = !0); const At = de.get(F).__webglFramebuffer; F.isWebGLCubeRenderTarget ? (ge = At[ee], qe = !0) : He.isWebGL2 && F.samples > 0 && ae.useMultisampledRTT(F) === !1 ? ge = de.get(F).__webglMultisampledFramebuffer : ge = At, P.copy(F.viewport), R.copy(F.scissor), E = F.scissorTest } else P.copy(G).multiplyScalar(U).floor(), R.copy(K).multiplyScalar(U).floor(), E = ne; if (Me.bindFramebuffer(36160, ge) && He.drawBuffers && Z && Me.drawBuffers(F, ge), Me.viewport(P), Me.scissor(R), Me.setScissorTest(E), qe) { const mt = de.get(F.texture); $.framebufferTexture2D(36160, 36064, 34069 + ee, mt.__webglTexture, he) } else if (rt) { const mt = de.get(F.texture), St = ee || 0; $.framebufferTextureLayer(36160, 36064, mt.__webglTexture, he || 0, St) } S = -1 }, this.readRenderTargetPixels = function (F, ee, he, Z, ge, qe, rt) { if (!(F && F.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let ft = de.get(F).__webglFramebuffer; if (F.isWebGLCubeRenderTarget && rt !== void 0 && (ft = ft[rt]), ft) { Me.bindFramebuffer(36160, ft); try { const mt = F.texture, St = mt.format, At = mt.type; if (St !== Ai && Ie.convert(St) !== $.getParameter(35739)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const _t = At === Pu && (ke.has("EXT_color_buffer_half_float") || He.isWebGL2 && ke.has("EXT_color_buffer_float")); if (At !== Hs && Ie.convert(At) !== $.getParameter(35738) && !(At === Bs && (He.isWebGL2 || ke.has("OES_texture_float") || ke.has("WEBGL_color_buffer_float"))) && !_t) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ee >= 0 && ee <= F.width - Z && he >= 0 && he <= F.height - ge && $.readPixels(ee, he, Z, ge, Ie.convert(St), Ie.convert(At), qe) } finally { const mt = w !== null ? de.get(w).__webglFramebuffer : null; Me.bindFramebuffer(36160, mt) } } }, this.copyFramebufferToTexture = function (F, ee, he = 0) { const Z = Math.pow(2, -he), ge = Math.floor(ee.image.width * Z), qe = Math.floor(ee.image.height * Z); ae.setTexture2D(ee, 0), $.copyTexSubImage2D(3553, he, 0, 0, F.x, F.y, ge, qe), Me.unbindTexture() }, this.copyTextureToTexture = function (F, ee, he, Z = 0) { const ge = ee.image.width, qe = ee.image.height, rt = Ie.convert(he.format), ft = Ie.convert(he.type); ae.setTexture2D(he, 0), $.pixelStorei(37440, he.flipY), $.pixelStorei(37441, he.premultiplyAlpha), $.pixelStorei(3317, he.unpackAlignment), ee.isDataTexture ? $.texSubImage2D(3553, Z, F.x, F.y, ge, qe, rt, ft, ee.image.data) : ee.isCompressedTexture ? $.compressedTexSubImage2D(3553, Z, F.x, F.y, ee.mipmaps[0].width, ee.mipmaps[0].height, rt, ee.mipmaps[0].data) : $.texSubImage2D(3553, Z, F.x, F.y, rt, ft, ee.image), Z === 0 && he.generateMipmaps && $.generateMipmap(3553), Me.unbindTexture() }, this.copyTextureToTexture3D = function (F, ee, he, Z, ge = 0) { if (y.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const qe = F.max.x - F.min.x + 1, rt = F.max.y - F.min.y + 1, ft = F.max.z - F.min.z + 1, mt = Ie.convert(Z.format), St = Ie.convert(Z.type); let At; if (Z.isData3DTexture) ae.setTexture3D(Z, 0), At = 32879; else if (Z.isDataArrayTexture) ae.setTexture2DArray(Z, 0), At = 35866; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } $.pixelStorei(37440, Z.flipY), $.pixelStorei(37441, Z.premultiplyAlpha), $.pixelStorei(3317, Z.unpackAlignment); const _t = $.getParameter(3314), on = $.getParameter(32878), ti = $.getParameter(3316), yr = $.getParameter(3315), as = $.getParameter(32877), Jt = he.isCompressedTexture ? he.mipmaps[0] : he.image; $.pixelStorei(3314, Jt.width), $.pixelStorei(32878, Jt.height), $.pixelStorei(3316, F.min.x), $.pixelStorei(3315, F.min.y), $.pixelStorei(32877, F.min.z), he.isDataTexture || he.isData3DTexture ? $.texSubImage3D(At, ge, ee.x, ee.y, ee.z, qe, rt, ft, mt, St, Jt.data) : he.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), $.compressedTexSubImage3D(At, ge, ee.x, ee.y, ee.z, qe, rt, ft, mt, Jt.data)) : $.texSubImage3D(At, ge, ee.x, ee.y, ee.z, qe, rt, ft, mt, St, Jt), $.pixelStorei(3314, _t), $.pixelStorei(32878, on), $.pixelStorei(3316, ti), $.pixelStorei(3315, yr), $.pixelStorei(32877, as), ge === 0 && Z.generateMipmaps && $.generateMipmap(At), Me.unbindTexture() }, this.initTexture = function (F) { F.isCubeTexture ? ae.setTextureCube(F, 0) : F.isData3DTexture ? ae.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? ae.setTexture2DArray(F, 0) : ae.setTexture2D(F, 0), Me.unbindTexture() }, this.resetState = function () { A = 0, _ = 0, w = null, Me.reset(), me.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } class bB extends KA { } bB.prototype.isWebGL1Renderer = !0; class Cg { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new Le(e), this.density = t } clone() { return new Cg(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } class Eg { constructor(e, t = 1, i = 1e3) { this.isFog = !0, this.name = "", this.color = new Le(e), this.near = t, this.far = i } clone() { return new Eg(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } class QA extends bt { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t } get autoUpdate() { return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate } set autoUpdate(e) { console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e } } class md { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Vf, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Ui() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, i) { e *= this.stride, i *= t.stride; for (let r = 0, s = this.stride; r < s; r++)this.array[e + r] = t.array[i + r]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride); return i.setUsage(this.usage), i } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ui()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const ri = new I; class zo { constructor(e, t, i, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, i = this.data.count; t < i; t++)ri.fromBufferAttribute(this, t), ri.applyMatrix4(e), this.setXYZ(t, ri.x, ri.y, ri.z); return this } applyNormalMatrix(e) { for (let t = 0, i = this.count; t < i; t++)ri.fromBufferAttribute(this, t), ri.applyNormalMatrix(e), this.setXYZ(t, ri.x, ri.y, ri.z); return this } transformDirection(e) { for (let t = 0, i = this.count; t < i; t++)ri.fromBufferAttribute(this, t), ri.transformDirection(e), this.setXYZ(t, ri.x, ri.y, ri.z); return this } setX(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = zt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = Rs(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = Rs(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = Rs(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = Rs(t, this.array)), t } setXY(e, t, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this } setXYZW(e, t, i, r, s) { return e = e * this.data.stride + this.offset, this.normalized && (t = zt(t, this.array), i = zt(i, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let i = 0; i < this.count; i++) { const r = i * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return new It(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new zo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let i = 0; i < this.count; i++) { const r = i * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[r + s]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class ZA extends Mn { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Le(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let zl; const Ic = new I, Gl = new I, Hl = new I, Vl = new pe, Fc = new pe, PB = new it, pp = new I, Nc = new I, mp = new I, DC = new pe, Jy = new pe, IC = new pe; class BB extends bt { constructor(e) { if (super(), this.isSprite = !0, this.type = "Sprite", zl === void 0) { zl = new ut; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), i = new md(t, 5); zl.setIndex([0, 1, 2, 0, 2, 3]), zl.setAttribute("position", new zo(i, 3, 0, !1)), zl.setAttribute("uv", new zo(i, 2, 3, !1)) } this.geometry = zl, this.material = e !== void 0 ? e : new ZA, this.center = new pe(.5, .5) } raycast(e, t) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Gl.setFromMatrixScale(this.matrixWorld), PB.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Hl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Gl.multiplyScalar(-Hl.z); const i = this.material.rotation; let r, s; i !== 0 && (s = Math.cos(i), r = Math.sin(i)); const o = this.center; gp(pp.set(-.5, -.5, 0), Hl, o, Gl, r, s), gp(Nc.set(.5, -.5, 0), Hl, o, Gl, r, s), gp(mp.set(.5, .5, 0), Hl, o, Gl, r, s), DC.set(0, 0), Jy.set(1, 0), IC.set(1, 1); let a = e.ray.intersectTriangle(pp, Nc, mp, !1, Ic); if (a === null && (gp(Nc.set(-.5, .5, 0), Hl, o, Gl, r, s), Jy.set(0, 1), a = e.ray.intersectTriangle(pp, mp, Nc, !1, Ic), a === null)) return; const l = e.ray.origin.distanceTo(Ic); l < e.near || l > e.far || t.push({ distance: l, point: Ic.clone(), uv: ur.getUV(Ic, pp, Nc, mp, DC, Jy, IC, new pe), face: null, object: this }) } copy(e, t) { return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function gp(n, e, t, i, r, s) { Vl.subVectors(n, t).addScalar(.5).multiply(i), r !== void 0 ? (Fc.x = s * Vl.x - r * Vl.y, Fc.y = r * Vl.x + s * Vl.y) : Fc.copy(Vl), n.copy(e), n.x += Fc.x, n.y += Fc.y, n.applyMatrix4(PB) } const yp = new I, FC = new I; class RB extends bt { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; this.addLevel(s.object.clone(), s.distance, s.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, i = 0) { t = Math.abs(t); const r = this.levels; let s; for (s = 0; s < r.length && !(t < r[s].distance); s++); return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let i, r; for (i = 1, r = t.length; i < r; i++) { let s = t[i].distance; if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break } return t[i - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { yp.setFromMatrixPosition(this.matrixWorld); const r = e.ray.origin.distanceTo(yp); this.getObjectForDistance(r).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { yp.setFromMatrixPosition(e.matrixWorld), FC.setFromMatrixPosition(this.matrixWorld); const i = yp.distanceTo(FC) / e.zoom; t[0].object.visible = !0; let r, s; for (r = 1, s = t.length; r < s; r++) { let o = t[r].distance; if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = !1, t[r].object.visible = !0; else break } for (this._currentLevel = r - 1; r < s; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = []; const i = this.levels; for (let r = 0, s = i.length; r < s; r++) { const o = i[r]; t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis }) } return t } } const NC = new I, OC = new Nt, kC = new Nt, zz = new I, UC = new it; class qA extends Tn { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new it, this.bindMatrixInverse = new it } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Nt, t = this.geometry.attributes.skinWeight; for (let i = 0, r = t.count; i < r; i++) { e.fromBufferAttribute(t, i); const s = 1 / e.manhattanLength(); s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const i = this.skeleton, r = this.geometry; OC.fromBufferAttribute(r.attributes.skinIndex, e), kC.fromBufferAttribute(r.attributes.skinWeight, e), NC.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let s = 0; s < 4; s++) { const o = kC.getComponent(s); if (o !== 0) { const a = OC.getComponent(s); UC.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(zz.copy(NC).applyMatrix4(UC), o) } } return t.applyMatrix4(this.bindMatrixInverse) } } class Tg extends bt { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class xu extends Qt { constructor(e = null, t = 1, i = 1, r, s, o, a, l, f = fn, d = fn, h, p) { super(null, o, a, l, f, d, r, s, h, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const zC = new it, Gz = new it; class gd { constructor(e = [], t = []) { this.uuid = Ui(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let i = 0, r = this.bones.length; i < r; i++)this.boneInverses.push(new it) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const i = new it; this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const i = this.bones[e]; i && i.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const i = this.bones[e]; i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale)) } } update() { const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture; for (let s = 0, o = e.length; s < o; s++) { const a = e[s] ? e[s].matrixWorld : Gz; zC.multiplyMatrices(a, t[s]), zC.toArray(i, s * 16) } r !== null && (r.needsUpdate = !0) } clone() { return new gd(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = mB(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const i = new xu(t, e, e, Ai, Bs); return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, i = this.bones.length; t < i; t++) { const r = this.bones[t]; if (r.name === e) return r } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let i = 0, r = e.bones.length; i < r; i++) { const s = e.bones[i]; let o = t[s]; o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Tg), this.bones.push(o), this.boneInverses.push(new it().fromArray(e.boneInverses[i])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, i = this.boneInverses; for (let r = 0, s = t.length; r < s; r++) { const o = t[r]; e.bones.push(o.uuid); const a = i[r]; e.boneInverses.push(a.toArray()) } return e } } class Du extends It { constructor(e, t, i, r = 1) { super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const GC = new it, HC = new it, vp = [], Hz = new it, Oc = new Tn; class LB extends Tn { constructor(e, t, i) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Du(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1; for (let r = 0; r < i; r++)this.setMatrixAt(r, Hz) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const i = this.matrixWorld, r = this.count; if (Oc.geometry = this.geometry, Oc.material = this.material, Oc.material !== void 0) for (let s = 0; s < r; s++) { this.getMatrixAt(s, GC), HC.multiplyMatrices(i, GC), Oc.matrixWorld = HC, Oc.raycast(e, vp); for (let o = 0, a = vp.length; o < a; o++) { const l = vp[o]; l.instanceId = s, l.object = this, t.push(l) } vp.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new Du(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class ei extends Mn { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Le(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const VC = new I, WC = new I, jC = new it, Xy = new dd, xp = new Yo; class Ws extends bt { constructor(e = new ut, t = new ei) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, i = [0]; for (let r = 1, s = t.count; r < s; r++)VC.fromBufferAttribute(t, r - 1), WC.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += VC.distanceTo(WC); e.setAttribute("lineDistance", new We(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange; if (i.boundingSphere === null && i.computeBoundingSphere(), xp.copy(i.boundingSphere), xp.applyMatrix4(r), xp.radius += s, e.ray.intersectsSphere(xp) === !1) return; jC.copy(r).invert(), Xy.copy(e.ray).applyMatrix4(jC); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, f = new I, d = new I, h = new I, p = new I, m = this.isLineSegments ? 2 : 1, v = i.index, x = i.attributes.position; if (v !== null) { const A = Math.max(0, o.start), _ = Math.min(v.count, o.start + o.count); for (let w = A, S = _ - 1; w < S; w += m) { const T = v.getX(w), P = v.getX(w + 1); if (f.fromBufferAttribute(x, T), d.fromBufferAttribute(x, P), Xy.distanceSqToSegment(f, d, p, h) > l) continue; p.applyMatrix4(this.matrixWorld); const E = e.ray.origin.distanceTo(p); E < e.near || E > e.far || t.push({ distance: E, point: h.clone().applyMatrix4(this.matrixWorld), index: w, face: null, faceIndex: null, object: this }) } } else { const A = Math.max(0, o.start), _ = Math.min(x.count, o.start + o.count); for (let w = A, S = _ - 1; w < S; w += m) { if (f.fromBufferAttribute(x, w), d.fromBufferAttribute(x, w + 1), Xy.distanceSqToSegment(f, d, p, h) > l) continue; p.applyMatrix4(this.matrixWorld); const P = e.ray.origin.distanceTo(p); P < e.near || P > e.far || t.push({ distance: P, point: h.clone().applyMatrix4(this.matrixWorld), index: w, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } } const JC = new I, XC = new I; class Or extends Ws { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, i = []; for (let r = 0, s = t.count; r < s; r += 2)JC.fromBufferAttribute(t, r), XC.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + JC.distanceTo(XC); e.setAttribute("lineDistance", new We(i, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class $A extends Ws { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class yd extends Mn { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Le(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const YC = new it, e1 = new dd, Ap = new Yo, _p = new I; let e_ = class extends bt { constructor(e = new ut, t = new yd) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange; if (i.boundingSphere === null && i.computeBoundingSphere(), Ap.copy(i.boundingSphere), Ap.applyMatrix4(r), Ap.radius += s, e.ray.intersectsSphere(Ap) === !1) return; YC.copy(r).invert(), e1.copy(e.ray).applyMatrix4(YC); const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, f = i.index, h = i.attributes.position; if (f !== null) { const p = Math.max(0, o.start), m = Math.min(f.count, o.start + o.count); for (let v = p, y = m; v < y; v++) { const x = f.getX(v); _p.fromBufferAttribute(h, x), KC(_p, x, l, r, e, t, this) } } else { const p = Math.max(0, o.start), m = Math.min(h.count, o.start + o.count); for (let v = p, y = m; v < y; v++)_p.fromBufferAttribute(h, v), KC(_p, v, l, r, e, t, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, i = Object.keys(t); if (i.length > 0) { const r = t[i[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { const a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } }; function KC(n, e, t, i, r, s, o) { const a = e1.distanceSqToPoint(n); if (a < t) { const l = new I; e1.closestPointToPoint(n, l), l.applyMatrix4(i); const f = r.ray.origin.distanceTo(l); if (f < r.near || f > r.far) return; s.push({ distance: f, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o }) } } class Vz extends Qt { constructor(e, t, i, r, s, o, a, l, f) { super(e, t, i, r, s, o, a, l, f), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : en, this.magFilter = s !== void 0 ? s : en, this.generateMipmaps = !1; const d = this; function h() { d.needsUpdate = !0, e.requestVideoFrameCallback(h) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class Wz extends Qt { constructor(e, t, i) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = i, this.magFilter = fn, this.minFilter = fn, this.generateMipmaps = !1, this.needsUpdate = !0 } } class t_ extends Qt { constructor(e, t, i, r, s, o, a, l, f, d, h, p) { super(null, o, a, l, f, d, r, s, h, p), this.isCompressedTexture = !0, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } class jz extends t_ { constructor(e, t, i, r, s, o) { super(e, t, i, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = zn } } class Jz extends Qt { constructor(e, t, i, r, s, o, a, l, f) { super(e, t, i, r, s, o, a, l, f), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class kr { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const i = this.getUtoTmapping(e); return this.getPoint(i, t) } getPoints(e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPointAt(i / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let i, r = this.getPoint(0), s = 0; t.push(0); for (let o = 1; o <= e; o++)i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const i = this.getLengths(); let r = 0; const s = i.length; let o; t ? o = t : o = e * i[s - 1]; let a = 0, l = s - 1, f; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), f = i[r] - o, f < 0) a = r + 1; else if (f > 0) l = r - 1; else { l = r; break } if (r = l, i[r] === o) return r / (s - 1); const d = i[r], p = i[r + 1] - d, m = (o - d) / p; return (r + m) / (s - 1) } getTangent(e, t) { let r = e - 1e-4, s = e + 1e-4; r < 0 && (r = 0), s > 1 && (s = 1); const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new pe : new I); return l.copy(a).sub(o).normalize(), l } getTangentAt(e, t) { const i = this.getUtoTmapping(e); return this.getTangent(i, t) } computeFrenetFrames(e, t) { const i = new I, r = [], s = [], o = [], a = new I, l = new it; for (let m = 0; m <= e; m++) { const v = m / e; r[m] = this.getTangentAt(v, new I) } s[0] = new I, o[0] = new I; let f = Number.MAX_VALUE; const d = Math.abs(r[0].x), h = Math.abs(r[0].y), p = Math.abs(r[0].z); d <= f && (f = d, i.set(1, 0, 0)), h <= f && (f = h, i.set(0, 1, 0)), p <= f && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]); for (let m = 1; m <= e; m++) { if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(r[m - 1], r[m]), a.length() > Number.EPSILON) { a.normalize(); const v = Math.acos(gn(r[m - 1].dot(r[m]), -1, 1)); s[m].applyMatrix4(l.makeRotationAxis(a, v)) } o[m].crossVectors(r[m], s[m]) } if (t === !0) { let m = Math.acos(gn(s[0].dot(s[e]), -1, 1)); m /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m); for (let v = 1; v <= e; v++)s[v].applyMatrix4(l.makeRotationAxis(r[v], m * v)), o[v].crossVectors(r[v], s[v]) } return { tangents: r, normals: s, binormals: o } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class bg extends kr { constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l } getPoint(e, t) { const i = t || new pe, r = Math.PI * 2; let s = this.aEndAngle - this.aStartAngle; const o = Math.abs(s) < Number.EPSILON; for (; s < 0;)s += r; for (; s > r;)s -= r; s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r); const a = this.aStartAngle + e * s; let l = this.aX + this.xRadius * Math.cos(a), f = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { const d = Math.cos(this.aRotation), h = Math.sin(this.aRotation), p = l - this.aX, m = f - this.aY; l = p * d - m * h + this.aX, f = p * h + m * d + this.aY } return i.set(l, f) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class DB extends bg { constructor(e, t, i, r, s, o) { super(e, t, i, i, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve" } } function n_() { let n = 0, e = 0, t = 0, i = 0; function r(s, o, a, l) { n = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l } return { initCatmullRom: function (s, o, a, l, f) { r(o, a, f * (a - s), f * (l - o)) }, initNonuniformCatmullRom: function (s, o, a, l, f, d, h) { let p = (o - s) / f - (a - s) / (f + d) + (a - o) / d, m = (a - o) / d - (l - o) / (d + h) + (l - a) / h; p *= d, m *= d, r(o, a, p, m) }, calc: function (s) { const o = s * s, a = o * s; return n + e * s + t * o + i * a } } } const Mp = new I, Yy = new n_, Ky = new n_, Qy = new n_; class IB extends kr { constructor(e = [], t = !1, i = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r } getPoint(e, t = new I) { const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e; let a = Math.floor(o), l = o - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1); let f, d; this.closed || a > 0 ? f = r[(a - 1) % s] : (Mp.subVectors(r[0], r[1]).add(r[0]), f = Mp); const h = r[a % s], p = r[(a + 1) % s]; if (this.closed || a + 2 < s ? d = r[(a + 2) % s] : (Mp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), d = Mp), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let v = Math.pow(f.distanceToSquared(h), m), y = Math.pow(h.distanceToSquared(p), m), x = Math.pow(p.distanceToSquared(d), m); y < 1e-4 && (y = 1), v < 1e-4 && (v = y), x < 1e-4 && (x = y), Yy.initNonuniformCatmullRom(f.x, h.x, p.x, d.x, v, y, x), Ky.initNonuniformCatmullRom(f.y, h.y, p.y, d.y, v, y, x), Qy.initNonuniformCatmullRom(f.z, h.z, p.z, d.z, v, y, x) } else this.curveType === "catmullrom" && (Yy.initCatmullRom(f.x, h.x, p.x, d.x, this.tension), Ky.initCatmullRom(f.y, h.y, p.y, d.y, this.tension), Qy.initCatmullRom(f.z, h.z, p.z, d.z, this.tension)); return i.set(Yy.calc(l), Ky.calc(l), Qy.calc(l)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(new I().fromArray(r)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function QC(n, e, t, i, r) { const s = (i - e) * .5, o = (r - t) * .5, a = n * n, l = n * a; return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t } function Xz(n, e) { const t = 1 - n; return t * t * e } function Yz(n, e) { return 2 * (1 - n) * n * e } function Kz(n, e) { return n * n * e } function hf(n, e, t, i) { return Xz(n, e) + Yz(n, t) + Kz(n, i) } function Qz(n, e) { const t = 1 - n; return t * t * t * e } function Zz(n, e) { const t = 1 - n; return 3 * t * t * n * e } function qz(n, e) { return 3 * (1 - n) * n * n * e } function $z(n, e) { return n * n * n * e } function pf(n, e, t, i, r) { return Qz(n, e) + Zz(n, t) + qz(n, i) + $z(n, r) } class i_ extends kr { constructor(e = new pe, t = new pe, i = new pe, r = new pe) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new pe) { const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return i.set(pf(e, r.x, s.x, o.x, a.x), pf(e, r.y, s.y, o.y, a.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class FB extends kr { constructor(e = new I, t = new I, i = new I, r = new I) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new I) { const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return i.set(pf(e, r.x, s.x, o.x, a.x), pf(e, r.y, s.y, o.y, a.y), pf(e, r.z, s.z, o.z, a.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class Pg extends kr { constructor(e = new pe, t = new pe) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new pe) { const i = t; return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const i = t || new pe; return i.copy(this.v2).sub(this.v1).normalize(), i } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class NB extends kr { constructor(e = new I, t = new I) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new I) { const i = t; return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class r_ extends kr { constructor(e = new pe, t = new pe, i = new pe) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new pe) { const i = t, r = this.v0, s = this.v1, o = this.v2; return i.set(hf(e, r.x, s.x, o.x), hf(e, r.y, s.y, o.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class s_ extends kr { constructor(e = new I, t = new I, i = new I) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new I) { const i = t, r = this.v0, s = this.v1, o = this.v2; return i.set(hf(e, r.x, s.x, o.x), hf(e, r.y, s.y, o.y), hf(e, r.z, s.z, o.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class o_ extends kr { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new pe) { const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], f = r[o], d = r[o > r.length - 2 ? r.length - 1 : o + 1], h = r[o > r.length - 3 ? r.length - 1 : o + 2]; return i.set(QC(a, l.x, f.x, d.x, h.x), QC(a, l.y, f.y, d.y, h.y)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const r = this.points[t]; e.points.push(r.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const r = e.points[t]; this.points.push(new pe().fromArray(r)) } return this } } var a_ = Object.freeze({ __proto__: null, ArcCurve: DB, CatmullRomCurve3: IB, CubicBezierCurve: i_, CubicBezierCurve3: FB, EllipseCurve: bg, LineCurve: Pg, LineCurve3: NB, QuadraticBezierCurve: r_, QuadraticBezierCurve3: s_, SplineCurve: o_ }); class OB extends kr { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new Pg(t, e)) } getPoint(e, t) { const i = e * this.getLength(), r = this.getCurveLengths(); let s = 0; for (; s < r.length;) { if (r[s] >= i) { const o = r[s] - i, a = this.curves[s], l = a.getLength(), f = l === 0 ? 0 : 1 - o / l; return a.getPointAt(f, t) } s++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let i = 0, r = this.curves.length; i < r; i++)t += this.curves[i].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let i; for (let r = 0, s = this.curves; r < s.length; r++) { const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a); for (let f = 0; f < l.length; f++) { const d = l[f]; i && i.equals(d) || (t.push(d), i = d) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const r = e.curves[t]; this.curves.push(r.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, i = this.curves.length; t < i; t++) { const r = this.curves[t]; e.curves.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const r = e.curves[t]; this.curves.push(new a_[r.type]().fromJSON(r)) } return this } } class Jf extends OB { constructor(e) { super(), this.type = "Path", this.currentPoint = new pe, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, i = e.length; t < i; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const i = new Pg(this.currentPoint.clone(), new pe(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, i, r) { const s = new r_(this.currentPoint.clone(), new pe(e, t), new pe(i, r)); return this.curves.push(s), this.currentPoint.set(i, r), this } bezierCurveTo(e, t, i, r, s, o) { const a = new i_(this.currentPoint.clone(), new pe(e, t), new pe(i, r), new pe(s, o)); return this.curves.push(a), this.currentPoint.set(s, o), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), i = new o_(t); return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, i, r, s, o) { const a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + a, t + l, i, r, s, o), this } absarc(e, t, i, r, s, o) { return this.absellipse(e, t, i, i, r, s, o), this } ellipse(e, t, i, r, s, o, a, l) { const f = this.currentPoint.x, d = this.currentPoint.y; return this.absellipse(e + f, t + d, i, r, s, o, a, l), this } absellipse(e, t, i, r, s, o, a, l) { const f = new bg(e, t, i, r, s, o, a, l); if (this.curves.length > 0) { const h = f.getPoint(0); h.equals(this.currentPoint) || this.lineTo(h.x, h.y) } this.curves.push(f); const d = f.getPoint(1); return this.currentPoint.copy(d), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Ju extends ut { constructor(e = [new pe(0, -.5), new pe(.5, 0), new pe(0, .5)], t = 12, i = 0, r = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = gn(r, 0, Math.PI * 2); const s = [], o = [], a = [], l = [], f = [], d = 1 / t, h = new I, p = new pe, m = new I, v = new I, y = new I; let x = 0, A = 0; for (let _ = 0; _ <= e.length - 1; _++)switch (_) { case 0: x = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -x, m.z = A * 0, y.copy(m), m.normalize(), l.push(m.x, m.y, m.z); break; case e.length - 1: l.push(y.x, y.y, y.z); break; default: x = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -x, m.z = A * 0, v.copy(m), m.x += y.x, m.y += y.y, m.z += y.z, m.normalize(), l.push(m.x, m.y, m.z), y.copy(v) }for (let _ = 0; _ <= t; _++) { const w = i + _ * d * r, S = Math.sin(w), T = Math.cos(w); for (let P = 0; P <= e.length - 1; P++) { h.x = e[P].x * S, h.y = e[P].y, h.z = e[P].x * T, o.push(h.x, h.y, h.z), p.x = _ / t, p.y = P / (e.length - 1), a.push(p.x, p.y); const R = l[3 * P + 0] * S, E = l[3 * P + 1], B = l[3 * P + 0] * T; f.push(R, E, B) } } for (let _ = 0; _ < t; _++)for (let w = 0; w < e.length - 1; w++) { const S = w + _ * e.length, T = S, P = S + e.length, R = S + e.length + 1, E = S + 1; s.push(T, P, E), s.push(R, E, P) } this.setIndex(s), this.setAttribute("position", new We(o, 3)), this.setAttribute("uv", new We(a, 2)), this.setAttribute("normal", new We(f, 3)) } static fromJSON(e) { return new Ju(e.points, e.segments, e.phiStart, e.phiLength) } } class vd extends Ju { constructor(e = 1, t = 1, i = 4, r = 8) { const s = new Jf; s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, height: t, capSegments: i, radialSegments: r } } static fromJSON(e) { return new vd(e.radius, e.length, e.capSegments, e.radialSegments) } } class xd extends ut { constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t); const s = [], o = [], a = [], l = [], f = new I, d = new pe; o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5); for (let h = 0, p = 3; h <= t; h++, p += 3) { const m = i + h / t * r; f.x = e * Math.cos(m), f.y = e * Math.sin(m), o.push(f.x, f.y, f.z), a.push(0, 0, 1), d.x = (o[p] / e + 1) / 2, d.y = (o[p + 1] / e + 1) / 2, l.push(d.x, d.y) } for (let h = 1; h <= t; h++)s.push(h, h + 1, 0); this.setIndex(s), this.setAttribute("position", new We(o, 3)), this.setAttribute("normal", new We(a, 3)), this.setAttribute("uv", new We(l, 2)) } static fromJSON(e) { return new xd(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class ol extends ut { constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l }; const f = this; r = Math.floor(r), s = Math.floor(s); const d = [], h = [], p = [], m = []; let v = 0; const y = [], x = i / 2; let A = 0; _(), o === !1 && (e > 0 && w(!0), t > 0 && w(!1)), this.setIndex(d), this.setAttribute("position", new We(h, 3)), this.setAttribute("normal", new We(p, 3)), this.setAttribute("uv", new We(m, 2)); function _() { const S = new I, T = new I; let P = 0; const R = (t - e) / i; for (let E = 0; E <= s; E++) { const B = [], L = E / s, U = L * (t - e) + e; for (let q = 0; q <= r; q++) { const W = q / r, G = W * l + a, K = Math.sin(G), ne = Math.cos(G); T.x = U * K, T.y = -L * i + x, T.z = U * ne, h.push(T.x, T.y, T.z), S.set(K, R, ne).normalize(), p.push(S.x, S.y, S.z), m.push(W, 1 - L), B.push(v++) } y.push(B) } for (let E = 0; E < r; E++)for (let B = 0; B < s; B++) { const L = y[B][E], U = y[B + 1][E], q = y[B + 1][E + 1], W = y[B][E + 1]; d.push(L, U, W), d.push(U, q, W), P += 6 } f.addGroup(A, P, 0), A += P } function w(S) { const T = v, P = new pe, R = new I; let E = 0; const B = S === !0 ? e : t, L = S === !0 ? 1 : -1; for (let q = 1; q <= r; q++)h.push(0, x * L, 0), p.push(0, L, 0), m.push(.5, .5), v++; const U = v; for (let q = 0; q <= r; q++) { const G = q / r * l + a, K = Math.cos(G), ne = Math.sin(G); R.x = B * ne, R.y = x * L, R.z = B * K, h.push(R.x, R.y, R.z), p.push(0, L, 0), P.x = K * .5 + .5, P.y = ne * .5 * L + .5, m.push(P.x, P.y), v++ } for (let q = 0; q < r; q++) { const W = T + q, G = U + q; S === !0 ? d.push(G, G + 1, W) : d.push(G + 1, G, W), E += 3 } f.addGroup(A, E, S === !0 ? 1 : 2), A += E } } static fromJSON(e) { return new ol(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Ad extends ol { constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) { super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a } } static fromJSON(e) { return new Ad(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Xs extends ut { constructor(e = [], t = [], i = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r }; const s = [], o = []; a(r), f(i), d(), this.setAttribute("position", new We(s, 3)), this.setAttribute("normal", new We(s.slice(), 3)), this.setAttribute("uv", new We(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a(_) { const w = new I, S = new I, T = new I; for (let P = 0; P < t.length; P += 3)m(t[P + 0], w), m(t[P + 1], S), m(t[P + 2], T), l(w, S, T, _) } function l(_, w, S, T) { const P = T + 1, R = []; for (let E = 0; E <= P; E++) { R[E] = []; const B = _.clone().lerp(S, E / P), L = w.clone().lerp(S, E / P), U = P - E; for (let q = 0; q <= U; q++)q === 0 && E === P ? R[E][q] = B : R[E][q] = B.clone().lerp(L, q / U) } for (let E = 0; E < P; E++)for (let B = 0; B < 2 * (P - E) - 1; B++) { const L = Math.floor(B / 2); B % 2 === 0 ? (p(R[E][L + 1]), p(R[E + 1][L]), p(R[E][L])) : (p(R[E][L + 1]), p(R[E + 1][L + 1]), p(R[E + 1][L])) } } function f(_) { const w = new I; for (let S = 0; S < s.length; S += 3)w.x = s[S + 0], w.y = s[S + 1], w.z = s[S + 2], w.normalize().multiplyScalar(_), s[S + 0] = w.x, s[S + 1] = w.y, s[S + 2] = w.z } function d() { const _ = new I; for (let w = 0; w < s.length; w += 3) { _.x = s[w + 0], _.y = s[w + 1], _.z = s[w + 2]; const S = x(_) / 2 / Math.PI + .5, T = A(_) / Math.PI + .5; o.push(S, 1 - T) } v(), h() } function h() { for (let _ = 0; _ < o.length; _ += 6) { const w = o[_ + 0], S = o[_ + 2], T = o[_ + 4], P = Math.max(w, S, T), R = Math.min(w, S, T); P > .9 && R < .1 && (w < .2 && (o[_ + 0] += 1), S < .2 && (o[_ + 2] += 1), T < .2 && (o[_ + 4] += 1)) } } function p(_) { s.push(_.x, _.y, _.z) } function m(_, w) { const S = _ * 3; w.x = e[S + 0], w.y = e[S + 1], w.z = e[S + 2] } function v() { const _ = new I, w = new I, S = new I, T = new I, P = new pe, R = new pe, E = new pe; for (let B = 0, L = 0; B < s.length; B += 9, L += 6) { _.set(s[B + 0], s[B + 1], s[B + 2]), w.set(s[B + 3], s[B + 4], s[B + 5]), S.set(s[B + 6], s[B + 7], s[B + 8]), P.set(o[L + 0], o[L + 1]), R.set(o[L + 2], o[L + 3]), E.set(o[L + 4], o[L + 5]), T.copy(_).add(w).add(S).divideScalar(3); const U = x(T); y(P, L + 0, _, U), y(R, L + 2, w, U), y(E, L + 4, S, U) } } function y(_, w, S, T) { T < 0 && _.x === 1 && (o[w] = _.x - 1), S.x === 0 && S.z === 0 && (o[w] = T / 2 / Math.PI + .5) } function x(_) { return Math.atan2(_.z, -_.x) } function A(_) { return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) } } static fromJSON(e) { return new Xs(e.vertices, e.indices, e.radius, e.details) } } class _d extends Xs { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2, r = 1 / i, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new _d(e.radius, e.detail) } } const wp = new I, Sp = new I, Zy = new I, Cp = new ur; class kB extends ut { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const r = Math.pow(10, 4), s = Math.cos(Wa * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, f = [0, 0, 0], d = ["a", "b", "c"], h = new Array(3), p = {}, m = []; for (let v = 0; v < l; v += 3) { o ? (f[0] = o.getX(v), f[1] = o.getX(v + 1), f[2] = o.getX(v + 2)) : (f[0] = v, f[1] = v + 1, f[2] = v + 2); const { a: y, b: x, c: A } = Cp; if (y.fromBufferAttribute(a, f[0]), x.fromBufferAttribute(a, f[1]), A.fromBufferAttribute(a, f[2]), Cp.getNormal(Zy), h[0] = `${Math.round(y.x * r)},${Math.round(y.y * r)},${Math.round(y.z * r)}`, h[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(x.z * r)}`, h[2] = `${Math.round(A.x * r)},${Math.round(A.y * r)},${Math.round(A.z * r)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0])) for (let _ = 0; _ < 3; _++) { const w = (_ + 1) % 3, S = h[_], T = h[w], P = Cp[d[_]], R = Cp[d[w]], E = `${S}_${T}`, B = `${T}_${S}`; B in p && p[B] ? (Zy.dot(p[B].normal) <= s && (m.push(P.x, P.y, P.z), m.push(R.x, R.y, R.z)), p[B] = null) : E in p || (p[E] = { index0: f[_], index1: f[w], normal: Zy.clone() }) } } for (const v in p) if (p[v]) { const { index0: y, index1: x } = p[v]; wp.fromBufferAttribute(a, y), Sp.fromBufferAttribute(a, x), m.push(wp.x, wp.y, wp.z), m.push(Sp.x, Sp.y, Sp.z) } this.setAttribute("position", new We(m, 3)) } } } class Xa extends Jf { constructor(e) { super(e), this.uuid = Ui(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let i = 0, r = this.holes.length; i < r; i++)t[i] = this.holes[i].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const r = e.holes[t]; this.holes.push(r.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, i = this.holes.length; t < i; t++) { const r = this.holes[t]; e.holes.push(r.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const r = e.holes[t]; this.holes.push(new Jf().fromJSON(r)) } return this } } const eG = { triangulate: function (n, e, t = 2) { const i = e && e.length, r = i ? e[0] * t : n.length; let s = UB(n, 0, r, t, !0); const o = []; if (!s || s.next === s.prev) return o; let a, l, f, d, h, p, m; if (i && (s = sG(n, e, s, t)), n.length > 80 * t) { a = f = n[0], l = d = n[1]; for (let v = t; v < r; v += t)h = n[v], p = n[v + 1], h < a && (a = h), p < l && (l = p), h > f && (f = h), p > d && (d = p); m = Math.max(f - a, d - l), m = m !== 0 ? 32767 / m : 0 } return Xf(s, o, t, a, l, m, 0), o } }; function UB(n, e, t, i, r) { let s, o; if (r === gG(n, e, t, i) > 0) for (s = e; s < t; s += i)o = ZC(s, n[s], n[s + 1], o); else for (s = t - i; s >= e; s -= i)o = ZC(s, n[s], n[s + 1], o); return o && Bg(o, o.next) && (Kf(o), o = o.next), o } function tl(n, e) { if (!n) return n; e || (e = n); let t = n, i; do if (i = !1, !t.steiner && (Bg(t, t.next) || tn(t.prev, t, t.next) === 0)) { if (Kf(t), t = e = t.prev, t === t.next) break; i = !0 } else t = t.next; while (i || t !== e); return e } function Xf(n, e, t, i, r, s, o) { if (!n) return; !o && s && cG(n, i, r, s); let a = n, l, f; for (; n.prev !== n.next;) { if (l = n.prev, f = n.next, s ? nG(n, i, r, s) : tG(n)) { e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(f.i / t | 0), Kf(n), n = f.next, a = f.next; continue } if (n = f, n === a) { o ? o === 1 ? (n = iG(tl(n), e, t), Xf(n, e, t, i, r, s, 2)) : o === 2 && rG(n, e, t, i, r, s) : Xf(tl(n), e, t, i, r, s, 1); break } } } function tG(n) { const e = n.prev, t = n, i = n.next; if (tn(e, t, i) >= 0) return !1; const r = e.x, s = t.x, o = i.x, a = e.y, l = t.y, f = i.y, d = r < s ? r < o ? r : o : s < o ? s : o, h = a < l ? a < f ? a : f : l < f ? l : f, p = r > s ? r > o ? r : o : s > o ? s : o, m = a > l ? a > f ? a : f : l > f ? l : f; let v = i.next; for (; v !== e;) { if (v.x >= d && v.x <= p && v.y >= h && v.y <= m && au(r, a, s, l, o, f, v.x, v.y) && tn(v.prev, v, v.next) >= 0) return !1; v = v.next } return !0 } function nG(n, e, t, i) { const r = n.prev, s = n, o = n.next; if (tn(r, s, o) >= 0) return !1; const a = r.x, l = s.x, f = o.x, d = r.y, h = s.y, p = o.y, m = a < l ? a < f ? a : f : l < f ? l : f, v = d < h ? d < p ? d : p : h < p ? h : p, y = a > l ? a > f ? a : f : l > f ? l : f, x = d > h ? d > p ? d : p : h > p ? h : p, A = t1(m, v, e, t, i), _ = t1(y, x, e, t, i); let w = n.prevZ, S = n.nextZ; for (; w && w.z >= A && S && S.z <= _;) { if (w.x >= m && w.x <= y && w.y >= v && w.y <= x && w !== r && w !== o && au(a, d, l, h, f, p, w.x, w.y) && tn(w.prev, w, w.next) >= 0 || (w = w.prevZ, S.x >= m && S.x <= y && S.y >= v && S.y <= x && S !== r && S !== o && au(a, d, l, h, f, p, S.x, S.y) && tn(S.prev, S, S.next) >= 0)) return !1; S = S.nextZ } for (; w && w.z >= A;) { if (w.x >= m && w.x <= y && w.y >= v && w.y <= x && w !== r && w !== o && au(a, d, l, h, f, p, w.x, w.y) && tn(w.prev, w, w.next) >= 0) return !1; w = w.prevZ } for (; S && S.z <= _;) { if (S.x >= m && S.x <= y && S.y >= v && S.y <= x && S !== r && S !== o && au(a, d, l, h, f, p, S.x, S.y) && tn(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } return !0 } function iG(n, e, t) { let i = n; do { const r = i.prev, s = i.next.next; !Bg(r, s) && zB(r, i, i.next, s) && Yf(r, s) && Yf(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Kf(i), Kf(i.next), i = n = s), i = i.next } while (i !== n); return tl(i) } function rG(n, e, t, i, r, s) { let o = n; do { let a = o.next.next; for (; a !== o.prev;) { if (o.i !== a.i && hG(o, a)) { let l = GB(o, a); o = tl(o, o.next), l = tl(l, l.next), Xf(o, e, t, i, r, s, 0), Xf(l, e, t, i, r, s, 0); return } a = a.next } o = o.next } while (o !== n) } function sG(n, e, t, i) { const r = []; let s, o, a, l, f; for (s = 0, o = e.length; s < o; s++)a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n.length, f = UB(n, a, l, i, !1), f === f.next && (f.steiner = !0), r.push(dG(f)); for (r.sort(oG), s = 0; s < r.length; s++)t = aG(r[s], t); return t } function oG(n, e) { return n.x - e.x } function aG(n, e) { const t = lG(n, e); if (!t) return e; const i = GB(t, n); return tl(i, i.next), tl(t, t.next) } function lG(n, e) { let t = e, i = -1 / 0, r; const s = n.x, o = n.y; do { if (o <= t.y && o >= t.next.y && t.next.y !== t.y) { const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (p <= s && p > i && (i = p, r = t.x < t.next.x ? t : t.next, p === s)) return r } t = t.next } while (t !== e); if (!r) return null; const a = r, l = r.x, f = r.y; let d = 1 / 0, h; t = r; do s >= t.x && t.x >= l && s !== t.x && au(o < f ? s : i, o, l, f, o < f ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x), Yf(t, n) && (h < d || h === d && (t.x > r.x || t.x === r.x && uG(r, t))) && (r = t, d = h)), t = t.next; while (t !== a); return r } function uG(n, e) { return tn(n.prev, n, e.prev) < 0 && tn(e.next, n, n.next) < 0 } function cG(n, e, t, i) { let r = n; do r.z === 0 && (r.z = t1(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== n); r.prevZ.nextZ = null, r.prevZ = null, fG(r) } function fG(n) { let e, t, i, r, s, o, a, l, f = 1; do { for (t = n, n = null, s = null, o = 0; t;) { for (o++, i = t, a = 0, e = 0; e < f && (a++, i = i.nextZ, !!i); e++); for (l = f; a > 0 || l > 0 && i;)a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r; t = i } s.nextZ = null, f *= 2 } while (o > 1); return n } function t1(n, e, t, i, r) { return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1 } function dG(n) { let e = n, t = n; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n); return t } function au(n, e, t, i, r, s, o, a) { return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a) } function hG(n, e) { return n.next.i !== e.i && n.prev.i !== e.i && !pG(n, e) && (Yf(n, e) && Yf(e, n) && mG(n, e) && (tn(n.prev, n, e.prev) || tn(n, e.prev, e)) || Bg(n, e) && tn(n.prev, n, n.next) > 0 && tn(e.prev, e, e.next) > 0) } function tn(n, e, t) { return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y) } function Bg(n, e) { return n.x === e.x && n.y === e.y } function zB(n, e, t, i) { const r = Tp(tn(n, e, t)), s = Tp(tn(n, e, i)), o = Tp(tn(t, i, n)), a = Tp(tn(t, i, e)); return !!(r !== s && o !== a || r === 0 && Ep(n, t, e) || s === 0 && Ep(n, i, e) || o === 0 && Ep(t, n, i) || a === 0 && Ep(t, e, i)) } function Ep(n, e, t) { return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y) } function Tp(n) { return n > 0 ? 1 : n < 0 ? -1 : 0 } function pG(n, e) { let t = n; do { if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && zB(t, t.next, n, e)) return !0; t = t.next } while (t !== n); return !1 } function Yf(n, e) { return tn(n.prev, n, n.next) < 0 ? tn(n, e, n.next) >= 0 && tn(n, n.prev, e) >= 0 : tn(n, e, n.prev) < 0 || tn(n, n.next, e) < 0 } function mG(n, e) { let t = n, i = !1; const r = (n.x + e.x) / 2, s = (n.y + e.y) / 2; do t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n); return i } function GB(n, e) { const t = new n1(n.i, n.x, n.y), i = new n1(e.i, e.x, e.y), r = n.next, s = e.prev; return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i } function ZC(n, e, t, i) { const r = new n1(n, e, t); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function Kf(n) { n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ) } function n1(n, e, t) { this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function gG(n, e, t, i) { let r = 0; for (let s = e, o = t - i; s < t; s += i)r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]), o = s; return r } class es { static area(e) { const t = e.length; let i = 0; for (let r = t - 1, s = 0; s < t; r = s++)i += e[r].x * e[s].y - e[s].x * e[r].y; return i * .5 } static isClockWise(e) { return es.area(e) < 0 } static triangulateShape(e, t) { const i = [], r = [], s = []; qC(e), $C(i, e); let o = e.length; t.forEach(qC); for (let l = 0; l < t.length; l++)r.push(o), o += t[l].length, $C(i, t[l]); const a = eG.triangulate(i, r); for (let l = 0; l < a.length; l += 3)s.push(a.slice(l, l + 3)); return s } } function qC(n) { const e = n.length; e > 2 && n[e - 1].equals(n[0]) && n.pop() } function $C(n, e) { for (let t = 0; t < e.length; t++)n.push(e[t].x), n.push(e[t].y) } class Md extends ut { constructor(e = new Xa([new pe(.5, .5), new pe(-.5, .5), new pe(-.5, -.5), new pe(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const i = this, r = [], s = []; for (let a = 0, l = e.length; a < l; a++) { const f = e[a]; o(f) } this.setAttribute("position", new We(r, 3)), this.setAttribute("uv", new We(s, 2)), this.computeVertexNormals(); function o(a) { const l = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, d = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1; let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, v = t.bevelSize !== void 0 ? t.bevelSize : m - .1, y = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const A = t.extrudePath, _ = t.UVGenerator !== void 0 ? t.UVGenerator : yG; let w, S = !1, T, P, R, E; A && (w = A.getSpacedPoints(d), S = !0, p = !1, T = A.computeFrenetFrames(d, !1), P = new I, R = new I, E = new I), p || (x = 0, m = 0, v = 0, y = 0); const B = a.extractPoints(f); let L = B.shape; const U = B.holes; if (!es.isClockWise(L)) { L = L.reverse(); for (let de = 0, ae = U.length; de < ae; de++) { const Ce = U[de]; es.isClockWise(Ce) && (U[de] = Ce.reverse()) } } const W = es.triangulateShape(L, U), G = L; for (let de = 0, ae = U.length; de < ae; de++) { const Ce = U[de]; L = L.concat(Ce) } function K(de, ae, Ce) { return ae || console.error("THREE.ExtrudeGeometry: vec does not exist"), ae.clone().multiplyScalar(Ce).add(de) } const ne = L.length, oe = W.length; function N(de, ae, Ce) { let ze, Be, Ze; const Je = de.x - ae.x, je = de.y - ae.y, vt = Ce.x - de.x, wt = Ce.y - de.y, k = Je * Je + je * je, D = Je * wt - je * vt; if (Math.abs(D) > Number.EPSILON) { const se = Math.sqrt(k), we = Math.sqrt(vt * vt + wt * wt), Ee = ae.x - je / se, Pe = ae.y + Je / se, tt = Ce.x - wt / we, Ie = Ce.y + vt / we, me = ((tt - Ee) * wt - (Ie - Pe) * vt) / (Je * wt - je * vt); ze = Ee + Je * me - de.x, Be = Pe + je * me - de.y; const Xe = ze * ze + Be * Be; if (Xe <= 2) return new pe(ze, Be); Ze = Math.sqrt(Xe / 2) } else { let se = !1; Je > Number.EPSILON ? vt > Number.EPSILON && (se = !0) : Je < -Number.EPSILON ? vt < -Number.EPSILON && (se = !0) : Math.sign(je) === Math.sign(wt) && (se = !0), se ? (ze = -je, Be = Je, Ze = Math.sqrt(k)) : (ze = Je, Be = je, Ze = Math.sqrt(k / 2)) } return new pe(ze / Ze, Be / Ze) } const V = []; for (let de = 0, ae = G.length, Ce = ae - 1, ze = de + 1; de < ae; de++, Ce++, ze++)Ce === ae && (Ce = 0), ze === ae && (ze = 0), V[de] = N(G[de], G[Ce], G[ze]); const Y = []; let re, j = V.concat(); for (let de = 0, ae = U.length; de < ae; de++) { const Ce = U[de]; re = []; for (let ze = 0, Be = Ce.length, Ze = Be - 1, Je = ze + 1; ze < Be; ze++, Ze++, Je++)Ze === Be && (Ze = 0), Je === Be && (Je = 0), re[ze] = N(Ce[ze], Ce[Ze], Ce[Je]); Y.push(re), j = j.concat(re) } for (let de = 0; de < x; de++) { const ae = de / x, Ce = m * Math.cos(ae * Math.PI / 2), ze = v * Math.sin(ae * Math.PI / 2) + y; for (let Be = 0, Ze = G.length; Be < Ze; Be++) { const Je = K(G[Be], V[Be], ze); Oe(Je.x, Je.y, -Ce) } for (let Be = 0, Ze = U.length; Be < Ze; Be++) { const Je = U[Be]; re = Y[Be]; for (let je = 0, vt = Je.length; je < vt; je++) { const wt = K(Je[je], re[je], ze); Oe(wt.x, wt.y, -Ce) } } } const ie = v + y; for (let de = 0; de < ne; de++) { const ae = p ? K(L[de], j[de], ie) : L[de]; S ? (R.copy(T.normals[0]).multiplyScalar(ae.x), P.copy(T.binormals[0]).multiplyScalar(ae.y), E.copy(w[0]).add(R).add(P), Oe(E.x, E.y, E.z)) : Oe(ae.x, ae.y, 0) } for (let de = 1; de <= d; de++)for (let ae = 0; ae < ne; ae++) { const Ce = p ? K(L[ae], j[ae], ie) : L[ae]; S ? (R.copy(T.normals[de]).multiplyScalar(Ce.x), P.copy(T.binormals[de]).multiplyScalar(Ce.y), E.copy(w[de]).add(R).add(P), Oe(E.x, E.y, E.z)) : Oe(Ce.x, Ce.y, h / d * de) } for (let de = x - 1; de >= 0; de--) { const ae = de / x, Ce = m * Math.cos(ae * Math.PI / 2), ze = v * Math.sin(ae * Math.PI / 2) + y; for (let Be = 0, Ze = G.length; Be < Ze; Be++) { const Je = K(G[Be], V[Be], ze); Oe(Je.x, Je.y, h + Ce) } for (let Be = 0, Ze = U.length; Be < Ze; Be++) { const Je = U[Be]; re = Y[Be]; for (let je = 0, vt = Je.length; je < vt; je++) { const wt = K(Je[je], re[je], ze); S ? Oe(wt.x, wt.y + w[d - 1].y, w[d - 1].x + Ce) : Oe(wt.x, wt.y, h + Ce) } } } ve(), Ae(); function ve() { const de = r.length / 3; if (p) { let ae = 0, Ce = ne * ae; for (let ze = 0; ze < oe; ze++) { const Be = W[ze]; ke(Be[2] + Ce, Be[1] + Ce, Be[0] + Ce) } ae = d + x * 2, Ce = ne * ae; for (let ze = 0; ze < oe; ze++) { const Be = W[ze]; ke(Be[0] + Ce, Be[1] + Ce, Be[2] + Ce) } } else { for (let ae = 0; ae < oe; ae++) { const Ce = W[ae]; ke(Ce[2], Ce[1], Ce[0]) } for (let ae = 0; ae < oe; ae++) { const Ce = W[ae]; ke(Ce[0] + ne * d, Ce[1] + ne * d, Ce[2] + ne * d) } } i.addGroup(de, r.length / 3 - de, 0) } function Ae() { const de = r.length / 3; let ae = 0; $(G, ae), ae += G.length; for (let Ce = 0, ze = U.length; Ce < ze; Ce++) { const Be = U[Ce]; $(Be, ae), ae += Be.length } i.addGroup(de, r.length / 3 - de, 1) } function $(de, ae) { let Ce = de.length; for (; --Ce >= 0;) { const ze = Ce; let Be = Ce - 1; Be < 0 && (Be = de.length - 1); for (let Ze = 0, Je = d + x * 2; Ze < Je; Ze++) { const je = ne * Ze, vt = ne * (Ze + 1), wt = ae + ze + je, k = ae + Be + je, D = ae + Be + vt, se = ae + ze + vt; He(wt, k, D, se) } } } function Oe(de, ae, Ce) { l.push(de), l.push(ae), l.push(Ce) } function ke(de, ae, Ce) { Me(de), Me(ae), Me(Ce); const ze = r.length / 3, Be = _.generateTopUV(i, r, ze - 3, ze - 2, ze - 1); De(Be[0]), De(Be[1]), De(Be[2]) } function He(de, ae, Ce, ze) { Me(de), Me(ae), Me(ze), Me(ae), Me(Ce), Me(ze); const Be = r.length / 3, Ze = _.generateSideWallUV(i, r, Be - 6, Be - 3, Be - 2, Be - 1); De(Ze[0]), De(Ze[1]), De(Ze[3]), De(Ze[1]), De(Ze[2]), De(Ze[3]) } function Me(de) { r.push(l[de * 3 + 0]), r.push(l[de * 3 + 1]), r.push(l[de * 3 + 2]) } function De(de) { s.push(de.x), s.push(de.y) } } } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options; return vG(t, i, e) } static fromJSON(e, t) { const i = []; for (let s = 0, o = e.shapes.length; s < o; s++) { const a = t[e.shapes[s]]; i.push(a) } const r = e.options.extrudePath; return r !== void 0 && (e.options.extrudePath = new a_[r.type]().fromJSON(r)), new Md(i, e.options) } } const yG = { generateTopUV: function (n, e, t, i, r) { const s = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], f = e[r * 3], d = e[r * 3 + 1]; return [new pe(s, o), new pe(a, l), new pe(f, d)] }, generateSideWallUV: function (n, e, t, i, r, s) { const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], f = e[i * 3], d = e[i * 3 + 1], h = e[i * 3 + 2], p = e[r * 3], m = e[r * 3 + 1], v = e[r * 3 + 2], y = e[s * 3], x = e[s * 3 + 1], A = e[s * 3 + 2]; return Math.abs(a - d) < Math.abs(o - f) ? [new pe(o, 1 - l), new pe(f, 1 - h), new pe(p, 1 - v), new pe(y, 1 - A)] : [new pe(a, 1 - l), new pe(d, 1 - h), new pe(m, 1 - v), new pe(x, 1 - A)] } }; function vG(n, e, t) { if (t.shapes = [], Array.isArray(n)) for (let i = 0, r = n.length; i < r; i++) { const s = n[i]; t.shapes.push(s.uuid) } else t.shapes.push(n.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class wd extends Xs { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2, r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new wd(e.radius, e.detail) } } class Xu extends Xs { constructor(e = 1, t = 0) { const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Xu(e.radius, e.detail) } } class Sd extends ut { constructor(e = .5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: s, thetaLength: o }, i = Math.max(3, i), r = Math.max(1, r); const a = [], l = [], f = [], d = []; let h = e; const p = (t - e) / r, m = new I, v = new pe; for (let y = 0; y <= r; y++) { for (let x = 0; x <= i; x++) { const A = s + x / i * o; m.x = h * Math.cos(A), m.y = h * Math.sin(A), l.push(m.x, m.y, m.z), f.push(0, 0, 1), v.x = (m.x / t + 1) / 2, v.y = (m.y / t + 1) / 2, d.push(v.x, v.y) } h += p } for (let y = 0; y < r; y++) { const x = y * (i + 1); for (let A = 0; A < i; A++) { const _ = A + x, w = _, S = _ + i + 1, T = _ + i + 2, P = _ + 1; a.push(w, S, P), a.push(S, T, P) } } this.setIndex(a), this.setAttribute("position", new We(l, 3)), this.setAttribute("normal", new We(f, 3)), this.setAttribute("uv", new We(d, 2)) } static fromJSON(e) { return new Sd(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class Cd extends ut { constructor(e = new Xa([new pe(0, .5), new pe(-.5, -.5), new pe(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const i = [], r = [], s = [], o = []; let a = 0, l = 0; if (Array.isArray(e) === !1) f(e); else for (let d = 0; d < e.length; d++)f(e[d]), this.addGroup(a, l, d), a += l, l = 0; this.setIndex(i), this.setAttribute("position", new We(r, 3)), this.setAttribute("normal", new We(s, 3)), this.setAttribute("uv", new We(o, 2)); function f(d) { const h = r.length / 3, p = d.extractPoints(t); let m = p.shape; const v = p.holes; es.isClockWise(m) === !1 && (m = m.reverse()); for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; es.isClockWise(_) === !0 && (v[x] = _.reverse()) } const y = es.triangulateShape(m, v); for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; m = m.concat(_) } for (let x = 0, A = m.length; x < A; x++) { const _ = m[x]; r.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y) } for (let x = 0, A = y.length; x < A; x++) { const _ = y[x], w = _[0] + h, S = _[1] + h, T = _[2] + h; i.push(w, S, T), l += 3 } } } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return xG(t, e) } static fromJSON(e, t) { const i = []; for (let r = 0, s = e.shapes.length; r < s; r++) { const o = t[e.shapes[r]]; i.push(o) } return new Cd(i, e.curveSegments) } } function xG(n, e) { if (e.shapes = [], Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) { const r = n[t]; e.shapes.push(r.uuid) } else e.shapes.push(n.uuid); return e } class Yu extends ut { constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i)); const l = Math.min(o + a, Math.PI); let f = 0; const d = [], h = new I, p = new I, m = [], v = [], y = [], x = []; for (let A = 0; A <= i; A++) { const _ = [], w = A / i; let S = 0; A == 0 && o == 0 ? S = .5 / t : A == i && l == Math.PI && (S = -.5 / t); for (let T = 0; T <= t; T++) { const P = T / t; h.x = -e * Math.cos(r + P * s) * Math.sin(o + w * a), h.y = e * Math.cos(o + w * a), h.z = e * Math.sin(r + P * s) * Math.sin(o + w * a), v.push(h.x, h.y, h.z), p.copy(h).normalize(), y.push(p.x, p.y, p.z), x.push(P + S, 1 - w), _.push(f++) } d.push(_) } for (let A = 0; A < i; A++)for (let _ = 0; _ < t; _++) { const w = d[A][_ + 1], S = d[A][_], T = d[A + 1][_], P = d[A + 1][_ + 1]; (A !== 0 || o > 0) && m.push(w, S, P), (A !== i - 1 || l < Math.PI) && m.push(S, T, P) } this.setIndex(m), this.setAttribute("position", new We(v, 3)), this.setAttribute("normal", new We(y, 3)), this.setAttribute("uv", new We(x, 2)) } static fromJSON(e) { return new Yu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class Ed extends Xs { constructor(e = 1, t = 0) { const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Ed(e.radius, e.detail) } } class Td extends ut { constructor(e = 1, t = .4, i = 12, r = 48, s = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }, i = Math.floor(i), r = Math.floor(r); const o = [], a = [], l = [], f = [], d = new I, h = new I, p = new I; for (let m = 0; m <= i; m++)for (let v = 0; v <= r; v++) { const y = v / r * s, x = m / i * Math.PI * 2; h.x = (e + t * Math.cos(x)) * Math.cos(y), h.y = (e + t * Math.cos(x)) * Math.sin(y), h.z = t * Math.sin(x), a.push(h.x, h.y, h.z), d.x = e * Math.cos(y), d.y = e * Math.sin(y), p.subVectors(h, d).normalize(), l.push(p.x, p.y, p.z), f.push(v / r), f.push(m / i) } for (let m = 1; m <= i; m++)for (let v = 1; v <= r; v++) { const y = (r + 1) * m + v - 1, x = (r + 1) * (m - 1) + v - 1, A = (r + 1) * (m - 1) + v, _ = (r + 1) * m + v; o.push(y, x, _), o.push(x, A, _) } this.setIndex(o), this.setAttribute("position", new We(a, 3)), this.setAttribute("normal", new We(l, 3)), this.setAttribute("uv", new We(f, 2)) } static fromJSON(e) { return new Td(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class bd extends ut { constructor(e = 1, t = .4, i = 64, r = 8, s = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: s, q: o }, i = Math.floor(i), r = Math.floor(r); const a = [], l = [], f = [], d = [], h = new I, p = new I, m = new I, v = new I, y = new I, x = new I, A = new I; for (let w = 0; w <= i; ++w) { const S = w / i * s * Math.PI * 2; _(S, s, o, e, m), _(S + .01, s, o, e, v), x.subVectors(v, m), A.addVectors(v, m), y.crossVectors(x, A), A.crossVectors(y, x), y.normalize(), A.normalize(); for (let T = 0; T <= r; ++T) { const P = T / r * Math.PI * 2, R = -t * Math.cos(P), E = t * Math.sin(P); h.x = m.x + (R * A.x + E * y.x), h.y = m.y + (R * A.y + E * y.y), h.z = m.z + (R * A.z + E * y.z), l.push(h.x, h.y, h.z), p.subVectors(h, m).normalize(), f.push(p.x, p.y, p.z), d.push(w / i), d.push(T / r) } } for (let w = 1; w <= i; w++)for (let S = 1; S <= r; S++) { const T = (r + 1) * (w - 1) + (S - 1), P = (r + 1) * w + (S - 1), R = (r + 1) * w + S, E = (r + 1) * (w - 1) + S; a.push(T, P, E), a.push(P, R, E) } this.setIndex(a), this.setAttribute("position", new We(l, 3)), this.setAttribute("normal", new We(f, 3)), this.setAttribute("uv", new We(d, 2)); function _(w, S, T, P, R) { const E = Math.cos(w), B = Math.sin(w), L = T / S * w, U = Math.cos(L); R.x = P * (2 + U) * .5 * E, R.y = P * (2 + U) * B * .5, R.z = P * Math.sin(L) * .5 } } static fromJSON(e) { return new bd(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Pd extends ut { constructor(e = new s_(new I(-1, -1, 0), new I(-1, 1, 0), new I(1, 1, 0)), t = 64, i = 1, r = 8, s = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: s }; const o = e.computeFrenetFrames(t, s); this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals; const a = new I, l = new I, f = new pe; let d = new I; const h = [], p = [], m = [], v = []; y(), this.setIndex(v), this.setAttribute("position", new We(h, 3)), this.setAttribute("normal", new We(p, 3)), this.setAttribute("uv", new We(m, 2)); function y() { for (let w = 0; w < t; w++)x(w); x(s === !1 ? t : 0), _(), A() } function x(w) { d = e.getPointAt(w / t, d); const S = o.normals[w], T = o.binormals[w]; for (let P = 0; P <= r; P++) { const R = P / r * Math.PI * 2, E = Math.sin(R), B = -Math.cos(R); l.x = B * S.x + E * T.x, l.y = B * S.y + E * T.y, l.z = B * S.z + E * T.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = d.x + i * l.x, a.y = d.y + i * l.y, a.z = d.z + i * l.z, h.push(a.x, a.y, a.z) } } function A() { for (let w = 1; w <= t; w++)for (let S = 1; S <= r; S++) { const T = (r + 1) * (w - 1) + (S - 1), P = (r + 1) * w + (S - 1), R = (r + 1) * w + S, E = (r + 1) * (w - 1) + S; v.push(T, P, E), v.push(P, R, E) } } function _() { for (let w = 0; w <= t; w++)for (let S = 0; S <= r; S++)f.x = w / t, f.y = S / r, m.push(f.x, f.y) } } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Pd(new a_[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class HB extends ut { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], i = new Set, r = new I, s = new I; if (e.index !== null) { const o = e.attributes.position, a = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]); for (let f = 0, d = l.length; f < d; ++f) { const h = l[f], p = h.start, m = h.count; for (let v = p, y = p + m; v < y; v += 3)for (let x = 0; x < 3; x++) { const A = a.getX(v + x), _ = a.getX(v + (x + 1) % 3); r.fromBufferAttribute(o, A), s.fromBufferAttribute(o, _), eE(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } } else { const o = e.attributes.position; for (let a = 0, l = o.count / 3; a < l; a++)for (let f = 0; f < 3; f++) { const d = 3 * a + f, h = 3 * a + (f + 1) % 3; r.fromBufferAttribute(o, d), s.fromBufferAttribute(o, h), eE(r, s, i) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)) } } this.setAttribute("position", new We(t, 3)) } } } function eE(n, e, t) { const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`; return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0) } var tE = Object.freeze({ __proto__: null, BoxGeometry: Ko, CapsuleGeometry: vd, CircleGeometry: xd, ConeGeometry: Ad, CylinderGeometry: ol, DodecahedronGeometry: _d, EdgesGeometry: kB, ExtrudeGeometry: Md, IcosahedronGeometry: wd, LatheGeometry: Ju, OctahedronGeometry: Xu, PlaneGeometry: Wu, PolyhedronGeometry: Xs, RingGeometry: Sd, ShapeGeometry: Cd, SphereGeometry: Yu, TetrahedronGeometry: Ed, TorusGeometry: Td, TorusKnotGeometry: bd, TubeGeometry: Pd, WireframeGeometry: HB }); class VB extends Mn { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Le(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class WB extends ss { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class Ku extends Mn { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Le(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class Ys extends Ku { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return gn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Le(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Le(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Le(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e) } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class jB extends Mn { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Le(16777215), this.specular = new Le(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = fd, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class JB extends Mn { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Le(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class XB extends Mn { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class YB extends Mn { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Le(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = fd, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class KB extends Mn { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Le(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Js, this.normalScale = new pe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class QB extends ei { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function or(n, e, t) { return l_(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t) } function Oa(n, e, t) { return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n) } function l_(n) { return ArrayBuffer.isView(n) && !(n instanceof DataView) } function ZB(n) { function e(r, s) { return n[r] - n[s] } const t = n.length, i = new Array(t); for (let r = 0; r !== t; ++r)i[r] = r; return i.sort(e), i } function i1(n, e, t) { const i = n.length, r = new n.constructor(i); for (let s = 0, o = 0; o !== i; ++s) { const a = t[s] * e; for (let l = 0; l !== e; ++l)r[o++] = n[a + l] } return r } function u_(n, e, t, i) { let r = 1, s = n[0]; for (; s !== void 0 && s[i] === void 0;)s = n[r++]; if (s === void 0) return; let o = s[i]; if (o !== void 0) if (Array.isArray(o)) do o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n[r++]; while (s !== void 0); else if (o.toArray !== void 0) do o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n[r++]; while (s !== void 0); else do o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n[r++]; while (s !== void 0) } function AG(n, e, t, i, r = 30) { const s = n.clone(); s.name = e; const o = []; for (let l = 0; l < s.tracks.length; ++l) { const f = s.tracks[l], d = f.getValueSize(), h = [], p = []; for (let m = 0; m < f.times.length; ++m) { const v = f.times[m] * r; if (!(v < t || v >= i)) { h.push(f.times[m]); for (let y = 0; y < d; ++y)p.push(f.values[m * d + y]) } } h.length !== 0 && (f.times = Oa(h, f.times.constructor), f.values = Oa(p, f.values.constructor), o.push(f)) } s.tracks = o; let a = 1 / 0; for (let l = 0; l < s.tracks.length; ++l)a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]); for (let l = 0; l < s.tracks.length; ++l)s.tracks[l].shift(-1 * a); return s.resetDuration(), s } function _G(n, e = 0, t = n, i = 30) { i <= 0 && (i = 30); const r = t.tracks.length, s = e / i; for (let o = 0; o < r; ++o) { const a = t.tracks[o], l = a.ValueTypeName; if (l === "bool" || l === "string") continue; const f = n.tracks.find(function (A) { return A.name === a.name && A.ValueTypeName === l }); if (f === void 0) continue; let d = 0; const h = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = h / 3); let p = 0; const m = f.getValueSize(); f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3); const v = a.times.length - 1; let y; if (s <= a.times[0]) { const A = d, _ = h - d; y = or(a.values, A, _) } else if (s >= a.times[v]) { const A = v * h + d, _ = A + h - d; y = or(a.values, A, _) } else { const A = a.createInterpolant(), _ = d, w = h - d; A.evaluate(s), y = or(A.resultBuffer, _, w) } l === "quaternion" && new Hn().fromArray(y).normalize().conjugate().toArray(y); const x = f.times.length; for (let A = 0; A < x; ++A) { const _ = A * m + p; if (l === "quaternion") Hn.multiplyQuaternionsFlat(f.values, _, y, 0, f.values, _); else { const w = m - p * 2; for (let S = 0; S < w; ++S)f.values[_ + S] -= y[S] } } } return n.blendMode = NA, n } var MG = Object.freeze({ __proto__: null, arraySlice: or, convertArray: Oa, flattenJSON: u_, getKeyframeOrder: ZB, isTypedArray: l_, makeClipAdditive: _G, sortedArray: i1, subclip: AG }); class Qu { constructor(e, t, i, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let i = this._cachedIndex, r = t[i], s = t[i - 1]; e: { t: { let o; n: { i: if (!(e < r)) { for (let a = i + 2; ;) { if (r === void 0) { if (e < s) break i; return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } if (i === a) break; if (s = r, r = t[++i], e < r) break t } o = t.length; break n } if (!(e >= s)) { const a = t[1]; e < a && (i = 2, s = a); for (let l = i - 2; ;) { if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === l) break; if (r = s, s = t[--i - 1], e >= s) break t } o = i, i = 0; break n } break e } for (; i < o;) { const a = i + o >>> 1; e < t[a] ? o = a : i = a + 1 } if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1) } this._cachedIndex = i, this.intervalChanged_(i, s, r) } return this.interpolate_(i, s, e, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r; for (let o = 0; o !== r; ++o)t[o] = i[s + o]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class qB extends Qu { constructor(e, t, i, r) { super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ia, endingEnd: Ia } } intervalChanged_(e, t, i) { const r = this.parameterPositions; let s = e - 2, o = e + 1, a = r[s], l = r[o]; if (a === void 0) switch (this.getSettings_().endingStart) { case Fa: s = e, a = 2 * t - i; break; case Hf: s = r.length - 2, a = t + r[s] - r[s + 1]; break; default: s = e, a = i }if (l === void 0) switch (this.getSettings_().endingEnd) { case Fa: o = e, l = 2 * i - t; break; case Hf: o = 1, l = i + r[1] - r[0]; break; default: o = e - 1, l = t }const f = (i - t) * .5, d = this.valueSize; this._weightPrev = f / (t - a), this._weightNext = f / (l - i), this._offsetPrev = s * d, this._offsetNext = o * d } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, f = l - a, d = this._offsetPrev, h = this._offsetNext, p = this._weightPrev, m = this._weightNext, v = (i - t) / (r - t), y = v * v, x = y * v, A = -p * x + 2 * p * y - p * v, _ = (1 + p) * x + (-1.5 - 2 * p) * y + (-.5 + p) * v + 1, w = (-1 - m) * x + (1.5 + m) * y + .5 * v, S = m * x - m * y; for (let T = 0; T !== a; ++T)s[T] = A * o[d + T] + _ * o[f + T] + w * o[l + T] + S * o[h + T]; return s } } class c_ extends Qu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, f = l - a, d = (i - t) / (r - t), h = 1 - d; for (let p = 0; p !== a; ++p)s[p] = o[f + p] * h + o[l + p] * d; return s } } class $B extends Qu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Ur { constructor(e, t, i, r) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Oa(t, this.TimeBufferType), this.values = Oa(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let i; if (t.toJSON !== this.toJSON) i = t.toJSON(e); else { i = { name: e.name, times: Oa(e.times, Array), values: Oa(e.values, Array) }; const r = e.getInterpolation(); r !== e.DefaultInterpolation && (i.interpolation = r) } return i.type = e.ValueTypeName, i } InterpolantFactoryMethodDiscrete(e) { return new $B(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new c_(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new qB(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case Bu: t = this.InterpolantFactoryMethodDiscrete; break; case el: t = this.InterpolantFactoryMethodLinear; break; case am: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(i); return console.warn("THREE.KeyframeTrack:", i), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Bu; case this.InterpolantFactoryMethodLinear: return el; case this.InterpolantFactoryMethodSmooth: return am } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] *= e } return this } trim(e, t) { const i = this.times, r = i.length; let s = 0, o = r - 1; for (; s !== r && i[s] < e;)++s; for (; o !== -1 && i[o] > t;)--o; if (++o, s !== 0 || o !== r) { s >= o && (o = Math.max(o, 1), s = o - 1); const a = this.getValueSize(); this.times = or(i, s, o), this.values = or(this.values, s * a, o * a) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const i = this.times, r = this.values, s = i.length; s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let o = null; for (let a = 0; a !== s; a++) { const l = i[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1; break } if (o !== null && o > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1; break } o = l } if (r !== void 0 && l_(r)) for (let a = 0, l = r.length; a !== l; ++a) { const f = r[a]; if (isNaN(f)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f), e = !1; break } } return e } optimize() { const e = or(this.times), t = or(this.values), i = this.getValueSize(), r = this.getInterpolation() === am, s = e.length - 1; let o = 1; for (let a = 1; a < s; ++a) { let l = !1; const f = e[a], d = e[a + 1]; if (f !== d && (a !== 1 || f !== e[0])) if (r) l = !0; else { const h = a * i, p = h - i, m = h + i; for (let v = 0; v !== i; ++v) { const y = t[h + v]; if (y !== t[p + v] || y !== t[m + v]) { l = !0; break } } } if (l) { if (a !== o) { e[o] = e[a]; const h = a * i, p = o * i; for (let m = 0; m !== i; ++m)t[p + m] = t[h + m] } ++o } } if (s > 0) { e[o] = e[s]; for (let a = s * i, l = o * i, f = 0; f !== i; ++f)t[l + f] = t[a + f]; ++o } return o !== e.length ? (this.times = or(e, 0, o), this.values = or(t, 0, o * i)) : (this.times = e, this.values = t), this } clone() { const e = or(this.times, 0), t = or(this.values, 0), i = this.constructor, r = new i(this.name, e, t); return r.createInterpolant = this.createInterpolant, r } } Ur.prototype.TimeBufferType = Float32Array; Ur.prototype.ValueBufferType = Float32Array; Ur.prototype.DefaultInterpolation = el; class al extends Ur { } al.prototype.ValueTypeName = "bool"; al.prototype.ValueBufferType = Array; al.prototype.DefaultInterpolation = Bu; al.prototype.InterpolantFactoryMethodLinear = void 0; al.prototype.InterpolantFactoryMethodSmooth = void 0; class f_ extends Ur { } f_.prototype.ValueTypeName = "color"; class Iu extends Ur { } Iu.prototype.ValueTypeName = "number"; class e3 extends Qu { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (i - t) / (r - t); let f = e * a; for (let d = f + a; f !== d; f += 4)Hn.slerpFlat(s, 0, o, f - a, o, f, l); return s } } class Go extends Ur { InterpolantFactoryMethodLinear(e) { return new e3(this.times, this.values, this.getValueSize(), e) } } Go.prototype.ValueTypeName = "quaternion"; Go.prototype.DefaultInterpolation = el; Go.prototype.InterpolantFactoryMethodSmooth = void 0; class ll extends Ur { } ll.prototype.ValueTypeName = "string"; ll.prototype.ValueBufferType = Array; ll.prototype.DefaultInterpolation = Bu; ll.prototype.InterpolantFactoryMethodLinear = void 0; ll.prototype.InterpolantFactoryMethodSmooth = void 0; class Fu extends Ur { } Fu.prototype.ValueTypeName = "vector"; class Nu { constructor(e, t = -1, i, r = _g) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Ui(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], i = e.tracks, r = 1 / (e.fps || 1); for (let o = 0, a = i.length; o !== a; ++o)t.push(SG(i[o]).scale(r)); const s = new this(e.name, e.duration, t, e.blendMode); return s.uuid = e.uuid, s } static toJSON(e) { const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let s = 0, o = i.length; s !== o; ++s)t.push(Ur.toJSON(i[s])); return r } static CreateFromMorphTargetSequence(e, t, i, r) { const s = t.length, o = []; for (let a = 0; a < s; a++) { let l = [], f = []; l.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0); const d = ZB(l); l = i1(l, 1, d), f = i1(f, 1, d), !r && l[0] === 0 && (l.push(s), f.push(f[0])), o.push(new Iu(".morphTargetInfluences[" + t[a].name + "]", l, f).scale(1 / i)) } return new this(e, -1, o) } static findByName(e, t) { let i = e; if (!Array.isArray(e)) { const r = e; i = r.geometry && r.geometry.animations || r.animations } for (let r = 0; r < i.length; r++)if (i[r].name === t) return i[r]; return null } static CreateClipsFromMorphTargetSequences(e, t, i) { const r = {}, s = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = e.length; a < l; a++) { const f = e[a], d = f.name.match(s); if (d && d.length > 1) { const h = d[1]; let p = r[h]; p || (r[h] = p = []), p.push(f) } } const o = []; for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i)); return o } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const i = function (h, p, m, v, y) { if (m.length !== 0) { const x = [], A = []; u_(m, x, A, v), x.length !== 0 && y.push(new h(p, x, A)) } }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode; let l = e.length || -1; const f = e.hierarchy || []; for (let h = 0; h < f.length; h++) { const p = f[h].keys; if (!(!p || p.length === 0)) if (p[0].morphTargets) { const m = {}; let v; for (v = 0; v < p.length; v++)if (p[v].morphTargets) for (let y = 0; y < p[v].morphTargets.length; y++)m[p[v].morphTargets[y]] = -1; for (const y in m) { const x = [], A = []; for (let _ = 0; _ !== p[v].morphTargets.length; ++_) { const w = p[v]; x.push(w.time), A.push(w.morphTarget === y ? 1 : 0) } r.push(new Iu(".morphTargetInfluence[" + y + "]", x, A)) } l = m.length * o } else { const m = ".bones[" + t[h].name + "]"; i(Fu, m + ".position", p, "pos", r), i(Go, m + ".quaternion", p, "rot", r), i(Fu, m + ".scale", p, "scl", r) } } return r.length === 0 ? null : new this(s, l, r, a) } resetDuration() { const e = this.tracks; let t = 0; for (let i = 0, r = e.length; i !== r; ++i) { const s = this.tracks[i]; t = Math.max(t, s.times[s.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function wG(n) { switch (n.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return Iu; case "vector": case "vector2": case "vector3": case "vector4": return Fu; case "color": return f_; case "quaternion": return Go; case "bool": case "boolean": return al; case "string": return ll }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n) } function SG(n) { if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = wG(n.type); if (n.times === void 0) { const t = [], i = []; u_(n.keys, t, i, "value"), n.times = t, n.values = i } return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation) } const nl = { enabled: !1, files: {}, add: function (n, e) { this.enabled !== !1 && (this.files[n] = e) }, get: function (n) { if (this.enabled !== !1) return this.files[n] }, remove: function (n) { delete this.files[n] }, clear: function () { this.files = {} } }; class d_ { constructor(e, t, i) { const r = this; let s = !1, o = 0, a = 0, l; const f = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (d) { a++, s === !1 && r.onStart !== void 0 && r.onStart(d, o, a), s = !0 }, this.itemEnd = function (d) { o++, r.onProgress !== void 0 && r.onProgress(d, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad()) }, this.itemError = function (d) { r.onError !== void 0 && r.onError(d) }, this.resolveURL = function (d) { return l ? l(d) : d }, this.setURLModifier = function (d) { return l = d, this }, this.addHandler = function (d, h) { return f.push(d, h), this }, this.removeHandler = function (d) { const h = f.indexOf(d); return h !== -1 && f.splice(h, 2), this }, this.getHandler = function (d) { for (let h = 0, p = f.length; h < p; h += 2) { const m = f[h], v = f[h + 1]; if (m.global && (m.lastIndex = 0), m.test(d)) return v } return null } } } const lu = new d_; class hi { constructor(e) { this.manager = e !== void 0 ? e : lu, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const i = this; return new Promise(function (r, s) { i.load(e, r, t, s) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const Ms = {}; class CG extends Error { constructor(e, t) { super(e), this.response = t } } class Gi extends hi { constructor(e) { super(e) } load(e, t, i, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = nl.get(e); if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(s), this.manager.itemEnd(e) }, 0), s; if (Ms[e] !== void 0) { Ms[e].push({ onLoad: t, onProgress: i, onError: r }); return } Ms[e] = [], Ms[e].push({ onLoad: t, onProgress: i, onError: r }); const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(o).then(f => { if (f.status === 200 || f.status === 0) { if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0) return f; const d = Ms[e], h = f.body.getReader(), p = f.headers.get("Content-Length") || f.headers.get("X-File-Size"), m = p ? parseInt(p) : 0, v = m !== 0; let y = 0; const x = new ReadableStream({ start(A) { _(); function _() { h.read().then(({ done: w, value: S }) => { if (w) A.close(); else { y += S.byteLength; const T = new ProgressEvent("progress", { lengthComputable: v, loaded: y, total: m }); for (let P = 0, R = d.length; P < R; P++) { const E = d[P]; E.onProgress && E.onProgress(T) } A.enqueue(S), _() } }) } } }); return new Response(x) } else throw new CG(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`, f) }).then(f => { switch (l) { case "arraybuffer": return f.arrayBuffer(); case "blob": return f.blob(); case "document": return f.text().then(d => new DOMParser().parseFromString(d, a)); case "json": return f.json(); default: if (a === void 0) return f.text(); { const h = /charset="?([^;"\s]*)"?/i.exec(a), p = h && h[1] ? h[1].toLowerCase() : void 0, m = new TextDecoder(p); return f.arrayBuffer().then(v => m.decode(v)) } } }).then(f => { nl.add(e, f); const d = Ms[e]; delete Ms[e]; for (let h = 0, p = d.length; h < p; h++) { const m = d[h]; m.onLoad && m.onLoad(f) } }).catch(f => { const d = Ms[e]; if (d === void 0) throw this.manager.itemError(e), f; delete Ms[e]; for (let h = 0, p = d.length; h < p; h++) { const m = d[h]; m.onError && m.onError(f) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class EG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new Gi(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = []; for (let i = 0; i < e.length; i++) { const r = Nu.parse(e[i]); t.push(r) } return t } } class TG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = [], a = new t_, l = new Gi(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials); let f = 0; function d(h) { l.load(e[h], function (p) { const m = s.parse(p, !0); o[h] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, f += 1, f === 6 && (m.mipmapCount === 1 && (a.minFilter = en), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a)) }, i, r) } if (Array.isArray(e)) for (let h = 0, p = e.length; h < p; ++h)d(h); else l.load(e, function (h) { const p = s.parse(h, !0); if (p.isCubemap) { const m = p.mipmaps.length / p.mipmapCount; for (let v = 0; v < m; v++) { o[v] = { mipmaps: [] }; for (let y = 0; y < p.mipmapCount; y++)o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + y]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height } a.image = o } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps; p.mipmapCount === 1 && (a.minFilter = en), a.format = p.format, a.needsUpdate = !0, t && t(a) }, i, r); return a } } class Qf extends hi { constructor(e) { super(e) } load(e, t, i, r) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = nl.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = jf("img"); function l() { d(), nl.add(e, this), t && t(this), s.manager.itemEnd(e) } function f(h) { d(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e) } function d() { a.removeEventListener("load", l, !1), a.removeEventListener("error", f, !1) } return a.addEventListener("load", l, !1), a.addEventListener("error", f, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a } } class bG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = new pd, o = new Qf(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let a = 0; function l(f) { o.load(e[f], function (d) { s.images[f] = d, a++, a === 6 && (s.needsUpdate = !0, t && t(s)) }, void 0, r) } for (let f = 0; f < e.length; ++f)l(f); return s } } class PG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new xu, a = new Gi(this.manager); return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function (l) { const f = s.parse(l); f && (f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width, o.image.height = f.height, o.image.data = f.data), o.wrapS = f.wrapS !== void 0 ? f.wrapS : zn, o.wrapT = f.wrapT !== void 0 ? f.wrapT : zn, o.magFilter = f.magFilter !== void 0 ? f.magFilter : en, o.minFilter = f.minFilter !== void 0 ? f.minFilter : en, o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.encoding !== void 0 && (o.encoding = f.encoding), f.flipY !== void 0 && (o.flipY = f.flipY), f.format !== void 0 && (o.format = f.format), f.type !== void 0 && (o.type = f.type), f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps, o.minFilter = rs), f.mipmapCount === 1 && (o.minFilter = en), f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps), o.needsUpdate = !0, t && t(o, f)) }, i, r), o } } class Bd extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = new Qt, o = new Qf(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function (a) { s.image = a, s.needsUpdate = !0, t !== void 0 && t(s) }, i, r), s } } class Qo extends bt { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Le(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t } } class t3 extends Qo { constructor(e, t, i) { super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Le(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const qy = new it, nE = new I, iE = new I; class h_ { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new pe(512, 512), this.map = null, this.mapPass = null, this.matrix = new it, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new wg, this._frameExtents = new pe(1, 1), this._viewportCount = 1, this._viewports = [new Nt(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, i = this.matrix; nE.setFromMatrixPosition(e.matrixWorld), t.position.copy(nE), iE.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(iE), t.updateMatrixWorld(), qy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(qy), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(qy) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class BG extends h_ { constructor() { super(new Gt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, i = Wf * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far; (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class p_ extends Qo { constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt, this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new BG } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const rE = new it, kc = new I, $y = new I; class RG extends h_ { constructor() { super(new Gt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new pe(4, 2), this._viewportCount = 6, this._viewports = [new Nt(2, 1, 1, 1), new Nt(0, 1, 1, 1), new Nt(3, 1, 1, 1), new Nt(1, 1, 1, 1), new Nt(3, 0, 1, 1), new Nt(1, 0, 1, 1)], this._cubeDirections = [new I(1, 0, 0), new I(-1, 0, 0), new I(0, 0, 1), new I(0, 0, -1), new I(0, 1, 0), new I(0, -1, 0)], this._cubeUps = [new I(0, 1, 0), new I(0, 1, 0), new I(0, 1, 0), new I(0, 1, 0), new I(0, 0, 1), new I(0, 0, -1)] } updateMatrices(e, t = 0) { const i = this.camera, r = this.matrix, s = e.distance || i.far; s !== i.far && (i.far = s, i.updateProjectionMatrix()), kc.setFromMatrixPosition(e.matrixWorld), i.position.copy(kc), $y.copy(i.position), $y.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt($y), i.updateMatrixWorld(), r.makeTranslation(-kc.x, -kc.y, -kc.z), rE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(rE) } } class m_ extends Qo { constructor(e, t, i = 0, r = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new RG } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class LG extends h_ { constructor() { super(new Ir(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class g_ extends Qo { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(bt.DEFAULT_UP), this.updateMatrix(), this.target = new bt, this.shadow = new LG } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class n3 extends Qo { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class i3 extends Qo { constructor(e, t, i = 10, r = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = r } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class r3 { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new I) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const i = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * r), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], .546274 * (i * i - r * r)), t } getIrradianceAt(e, t) { const i = e.x, r = e.y, s = e.z, o = this.coefficients; return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * r), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * i), t.addScaledVector(o[4], 2 * .429043 * i * r), t.addScaledVector(o[5], 2 * .429043 * r * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * i * s), t.addScaledVector(o[8], .429043 * (i * i - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].addScaledVector(e.coefficients[i], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].lerp(e.coefficients[i], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].fromArray(e, t + r * 3); return this } toArray(e = [], t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].toArray(e, t + r * 3); return e } static getBasisAt(e, t) { const i = e.x, r = e.y, s = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * s, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = .546274 * (i * i - r * r) } } class Rg extends Qo { constructor(e = new r3, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class Lg extends hi { constructor(e) { super(e), this.textures = {} } load(e, t, i, r) { const s = this, o = new Gi(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = this.textures; function i(s) { return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s] } const r = Lg.createMaterialFromType(e.type); if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Le().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== 1 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) { const o = e.uniforms[s]; switch (r.uniforms[s] = {}, o.type) { case "t": r.uniforms[s].value = i(o.value); break; case "c": r.uniforms[s].value = new Le().setHex(o.value); break; case "v2": r.uniforms[s].value = new pe().fromArray(o.value); break; case "v3": r.uniforms[s].value = new I().fromArray(o.value); break; case "v4": r.uniforms[s].value = new Nt().fromArray(o.value); break; case "m3": r.uniforms[s].value = new li().fromArray(o.value); break; case "m4": r.uniforms[s].value = new it().fromArray(o.value); break; default: r.uniforms[s].value = o.value } } if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) r.extensions[s] = e.extensions[s]; if (e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) { let s = e.normalScale; Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new pe().fromArray(s) } return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new pe().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: VB, SpriteMaterial: ZA, RawShaderMaterial: WB, ShaderMaterial: ss, PointsMaterial: yd, MeshPhysicalMaterial: Ys, MeshStandardMaterial: Ku, MeshPhongMaterial: jB, MeshToonMaterial: JB, MeshNormalMaterial: XB, MeshLambertMaterial: YB, MeshDepthMaterial: XA, MeshDistanceMaterial: YA, MeshBasicMaterial: Oi, MeshMatcapMaterial: KB, LineDashedMaterial: QB, LineBasicMaterial: ei, Material: Mn }; return new t[e] } } class ts { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let i = 0, r = e.length; i < r; i++)t += String.fromCharCode(e[i]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class s3 extends ut { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class o3 extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new Gi(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function (a) { try { t(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } parse(e) { const t = {}, i = {}; function r(m, v) { if (t[v] !== void 0) return t[v]; const x = m.interleavedBuffers[v], A = s(m, x.buffer), _ = su(x.type, A), w = new md(_, x.stride); return w.uuid = x.uuid, t[v] = w, w } function s(m, v) { if (i[v] !== void 0) return i[v]; const x = m.arrayBuffers[v], A = new Uint32Array(x).buffer; return i[v] = A, A } const o = e.isInstancedBufferGeometry ? new s3 : new ut, a = e.data.index; if (a !== void 0) { const m = su(a.type, a.array); o.setIndex(new It(m, 1)) } const l = e.data.attributes; for (const m in l) { const v = l[m]; let y; if (v.isInterleavedBufferAttribute) { const x = r(e.data, v.data); y = new zo(x, v.itemSize, v.offset, v.normalized) } else { const x = su(v.type, v.array), A = v.isInstancedBufferAttribute ? Du : It; y = new A(x, v.itemSize, v.normalized) } v.name !== void 0 && (y.name = v.name), v.usage !== void 0 && y.setUsage(v.usage), v.updateRange !== void 0 && (y.updateRange.offset = v.updateRange.offset, y.updateRange.count = v.updateRange.count), o.setAttribute(m, y) } const f = e.data.morphAttributes; if (f) for (const m in f) { const v = f[m], y = []; for (let x = 0, A = v.length; x < A; x++) { const _ = v[x]; let w; if (_.isInterleavedBufferAttribute) { const S = r(e.data, _.data); w = new zo(S, _.itemSize, _.offset, _.normalized) } else { const S = su(_.type, _.array); w = new It(S, _.itemSize, _.normalized) } _.name !== void 0 && (w.name = _.name), y.push(w) } o.morphAttributes[m] = y } e.data.morphTargetsRelative && (o.morphTargetsRelative = !0); const h = e.data.groups || e.data.drawcalls || e.data.offsets; if (h !== void 0) for (let m = 0, v = h.length; m !== v; ++m) { const y = h[m]; o.addGroup(y.start, y.count, y.materialIndex) } const p = e.data.boundingSphere; if (p !== void 0) { const m = new I; p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new Yo(m, p.radius) } return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o } } class DG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = this.path === "" ? ts.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || o; const a = new Gi(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { let f = null; try { f = JSON.parse(l) } catch (h) { r !== void 0 && r(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message); return } const d = f.metadata; if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") { r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } s.parse(f, t) }, i, r) } async loadAsync(e, t) { const i = this, r = this.path === "" ? ts.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || r; const s = new Gi(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials); const o = await s.loadAsync(e, t), a = JSON.parse(o), l = a.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await i.parseAsync(a) } parse(e, t) { const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function () { t !== void 0 && t(f) }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), f = this.parseObject(e.object, s, l, a, i), d = this.parseSkeletons(e.skeletons, f); if (this.bindSkeletons(f, d), t !== void 0) { let h = !1; for (const p in o) if (o[p].data instanceof HTMLImageElement) { h = !0; break } h === !1 && t(f) } return f } async parseAsync(e) { const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), f = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, f), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let i = 0, r = e.length; i < r; i++) { const s = new Xa().fromJSON(e[i]); t[s.uuid] = s } return t } parseSkeletons(e, t) { const i = {}, r = {}; if (t.traverse(function (s) { s.isBone && (r[s.uuid] = s) }), e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = new gd().fromJSON(e[s], r); i[a.uuid] = a } return i } parseGeometries(e, t) { const i = {}; if (e !== void 0) { const r = new o3; for (let s = 0, o = e.length; s < o; s++) { let a; const l = e[s]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": a = r.parse(l); break; default: l.type in tE ? a = tE[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === !0 && l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a } } return i } parseMaterials(e, t) { const i = {}, r = {}; if (e !== void 0) { const s = new Lg; s.setTextures(t); for (let o = 0, a = e.length; o < a; o++) { const l = e[o]; i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), r[l.uuid] = i[l.uuid] } } return r } parseAnimations(e) { const t = {}; if (e !== void 0) for (let i = 0; i < e.length; i++) { const r = e[i], s = Nu.parse(r); t[s.uuid] = s } return t } parseImages(e, t) { const i = this, r = {}; let s; function o(l) { return i.manager.itemStart(l), s.load(l, function () { i.manager.itemEnd(l) }, void 0, function () { i.manager.itemError(l), i.manager.itemEnd(l) }) } function a(l) { if (typeof l == "string") { const f = l, d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f; return o(d) } else return l.data ? { data: su(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new d_(t); s = new Qf(l), s.setCrossOrigin(this.crossOrigin); for (let f = 0, d = e.length; f < d; f++) { const h = e[f], p = h.url; if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const x = p[v], A = a(x); A !== null && (A instanceof HTMLImageElement ? m.push(A) : m.push(new xu(A.data, A.width, A.height))) } r[h.uuid] = new Na(m) } else { const m = a(h.url); r[h.uuid] = new Na(m) } } } return r } async parseImagesAsync(e) { const t = this, i = {}; let r; async function s(o) { if (typeof o == "string") { const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a; return await r.loadAsync(l) } else return o.data ? { data: su(o.type, o.data), width: o.width, height: o.height } : null } if (e !== void 0 && e.length > 0) { r = new Qf(this.manager), r.setCrossOrigin(this.crossOrigin); for (let o = 0, a = e.length; o < a; o++) { const l = e[o], f = l.url; if (Array.isArray(f)) { const d = []; for (let h = 0, p = f.length; h < p; h++) { const m = f[h], v = await s(m); v !== null && (v instanceof HTMLImageElement ? d.push(v) : d.push(new xu(v.data, v.width, v.height))) } i[l.uuid] = new Na(d) } else { const d = await s(l.url); i[l.uuid] = new Na(d) } } } return i } parseTextures(e, t) { function i(s, o) { return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]) } const r = {}; if (e !== void 0) for (let s = 0, o = e.length; s < o; s++) { const a = e[s]; a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image); const l = t[a.image], f = l.data; let d; Array.isArray(f) ? (d = new pd, f.length === 6 && (d.needsUpdate = !0)) : (f && f.data ? d = new xu : d = new Qt, f && (d.needsUpdate = !0)), d.source = l, d.uuid = a.uuid, a.name !== void 0 && (d.name = a.name), a.mapping !== void 0 && (d.mapping = i(a.mapping, IG)), a.offset !== void 0 && d.offset.fromArray(a.offset), a.repeat !== void 0 && d.repeat.fromArray(a.repeat), a.center !== void 0 && d.center.fromArray(a.center), a.rotation !== void 0 && (d.rotation = a.rotation), a.wrap !== void 0 && (d.wrapS = i(a.wrap[0], sE), d.wrapT = i(a.wrap[1], sE)), a.format !== void 0 && (d.format = a.format), a.type !== void 0 && (d.type = a.type), a.encoding !== void 0 && (d.encoding = a.encoding), a.minFilter !== void 0 && (d.minFilter = i(a.minFilter, oE)), a.magFilter !== void 0 && (d.magFilter = i(a.magFilter, oE)), a.anisotropy !== void 0 && (d.anisotropy = a.anisotropy), a.flipY !== void 0 && (d.flipY = a.flipY), a.generateMipmaps !== void 0 && (d.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (d.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (d.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (d.userData = a.userData), r[a.uuid] = d } return r } parseObject(e, t, i, r, s) { let o; function a(p) { return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p] } function l(p) { if (p !== void 0) { if (Array.isArray(p)) { const m = []; for (let v = 0, y = p.length; v < y; v++) { const x = p[v]; i[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), m.push(i[x]) } return m } return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p] } } function f(p) { return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p] } let d, h; switch (e.type) { case "Scene": o = new QA, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Le(e.background) : o.background = f(e.background)), e.environment !== void 0 && (o.environment = f(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Eg(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Cg(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity); break; case "PerspectiveCamera": o = new Gt(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "OrthographicCamera": o = new Ir(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view)); break; case "AmbientLight": o = new n3(e.color, e.intensity); break; case "DirectionalLight": o = new g_(e.color, e.intensity); break; case "PointLight": o = new m_(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": o = new i3(e.color, e.intensity, e.width, e.height); break; case "SpotLight": o = new p_(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": o = new t3(e.color, e.groundColor, e.intensity); break; case "LightProbe": o = new Rg().fromJSON(e); break; case "SkinnedMesh": d = a(e.geometry), h = l(e.material), o = new qA(d, h), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton); break; case "Mesh": d = a(e.geometry), h = l(e.material), o = new Tn(d, h); break; case "InstancedMesh": d = a(e.geometry), h = l(e.material); const p = e.count, m = e.instanceMatrix, v = e.instanceColor; o = new LB(d, h, p), o.instanceMatrix = new Du(new Float32Array(m.array), 16), v !== void 0 && (o.instanceColor = new Du(new Float32Array(v.array), v.itemSize)); break; case "LOD": o = new RB; break; case "Line": o = new Ws(a(e.geometry), l(e.material)); break; case "LineLoop": o = new $A(a(e.geometry), l(e.material)); break; case "LineSegments": o = new Or(a(e.geometry), l(e.material)); break; case "PointCloud": case "Points": o = new e_(a(e.geometry), l(e.material)); break; case "Sprite": o = new BB(l(e.material)); break; case "Group": o = new Ls; break; case "Bone": o = new Tg; break; default: o = new bt }if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) { const p = e.children; for (let m = 0; m < p.length; m++)o.add(this.parseObject(p[m], t, i, r, s)) } if (e.animations !== void 0) { const p = e.animations; for (let m = 0; m < p.length; m++) { const v = p[m]; o.animations.push(s[v]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate); const p = e.levels; for (let m = 0; m < p.length; m++) { const v = p[m], y = o.getObjectByProperty("uuid", v.object); y !== void 0 && o.addLevel(y, v.distance, v.hysteresis) } } return o } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (i) { if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) { const r = t[i.skeleton]; r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix) } }) } } const IG = { UVMapping: xg, CubeReflectionMapping: Oo, CubeRefractionMapping: ko, EquirectangularReflectionMapping: Uf, EquirectangularRefractionMapping: zf, CubeUVReflectionMapping: Vu }, sE = { RepeatWrapping: Uo, ClampToEdgeWrapping: zn, MirroredRepeatWrapping: bu }, oE = { NearestFilter: fn, NearestMipmapNearestFilter: Gf, NearestMipmapLinearFilter: vu, LinearFilter: en, LinearMipmapNearestFilter: Ag, LinearMipmapLinearFilter: rs }; class a3 extends hi { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, i, r) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, o = nl.get(e); if (o !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(o), s.manager.itemEnd(e) }, 0), o; const a = {}; a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" })) }).then(function (l) { nl.add(e, l), t && t(l), s.manager.itemEnd(e) }).catch(function (l) { r && r(l), s.manager.itemError(e), s.manager.itemEnd(e) }), s.manager.itemStart(e) } } let bp; class y_ { static getContext() { return bp === void 0 && (bp = new (window.AudioContext || window.webkitAudioContext)), bp } static setContext(e) { bp = e } } class FG extends hi { constructor(e) { super(e) } load(e, t, i, r) { const s = this, o = new Gi(this.manager); o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (a) { try { const l = a.slice(0); y_.getContext().decodeAudioData(l, function (d) { t(d) }) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(e) } }, i, r) } } class NG extends Rg { constructor(e, t, i = 1) { super(void 0, i), this.isHemisphereLightProbe = !0; const r = new Le().set(e), s = new Le().set(t), o = new I(r.r, r.g, r.b), a = new I(s.r, s.g, s.b), l = Math.sqrt(Math.PI), f = l * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(f) } } class OG extends Rg { constructor(e, t = 1) { super(void 0, t), this.isAmbientLightProbe = !0; const i = new Le().set(e); this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } const aE = new it, lE = new it, da = new it; class kG { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Gt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, da.copy(e.projectionMatrix); const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(Wa * t.fov * .5) / t.zoom; let a, l; lE.elements[12] = -r, aE.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, da.elements[0] = 2 * t.near / (l - a), da.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(da), a = -o * t.aspect - s, l = o * t.aspect - s, da.elements[0] = 2 * t.near / (l - a), da.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(da) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(lE), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(aE) } } class v_ { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = uE(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = uE(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function uE() { return (typeof performance > "u" ? Date : performance).now() } const ha = new I, cE = new Hn, UG = new I, pa = new I; class zG extends bt { constructor() { super(), this.type = "AudioListener", this.context = y_.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new v_ } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, i = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ha, cE, UG), pa.set(0, 0, -1).applyQuaternion(cE), t.positionX) { const r = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(ha.x, r), t.positionY.linearRampToValueAtTime(ha.y, r), t.positionZ.linearRampToValueAtTime(ha.z, r), t.forwardX.linearRampToValueAtTime(pa.x, r), t.forwardY.linearRampToValueAtTime(pa.y, r), t.forwardZ.linearRampToValueAtTime(pa.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r) } else t.setPosition(ha.x, ha.y, ha.z), t.setOrientation(pa.x, pa.y, pa.z, i.x, i.y, i.z) } } class l3 extends bt { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const ma = new I, fE = new Hn, GG = new I, ga = new I; class HG extends l3 { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(ma, fE, GG), ga.set(0, 0, 1).applyQuaternion(fE); const t = this.panner; if (t.positionX) { const i = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(ma.x, i), t.positionY.linearRampToValueAtTime(ma.y, i), t.positionZ.linearRampToValueAtTime(ma.z, i), t.orientationX.linearRampToValueAtTime(ga.x, i), t.orientationY.linearRampToValueAtTime(ga.y, i), t.orientationZ.linearRampToValueAtTime(ga.z, i) } else t.setPosition(ma.x, ma.y, ma.z), t.setOrientation(ga.x, ga.y, ga.z) } } class VG { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let i = 0; i < t.length; i++)e += t[i]; return e / t.length } } class u3 { constructor(e, t, i) { this.binding = e, this.valueSize = i; let r, s, o; switch (t) { case "quaternion": r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5; break; case "string": case "bool": r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5); break; default: r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const i = this.buffer, r = this.valueSize, s = e * r + r; let o = this.cumulativeWeight; if (o === 0) { for (let a = 0; a !== r; ++a)i[s + a] = i[a]; o = t } else { o += t; const a = t / o; this._mixBufferRegion(i, s, 0, a, r) } this.cumulativeWeight = o } accumulateAdditive(e) { const t = this.buffer, i = this.valueSize, r = i * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) { const l = t * this._origIndex; this._mixBufferRegion(i, r, l, 1 - s, t) } o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t); for (let l = t, f = t + t; l !== f; ++l)if (i[l] !== i[l + t]) { a.setValue(i, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex; e.getValue(t, r); for (let s = i, o = r; s !== o; ++s)t[s] = t[r + s % i]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let i = e; i < t; i++)this.buffer[i] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let i = 0; i < this.valueSize; i++)this.buffer[t + i] = this.buffer[e + i] } _select(e, t, i, r, s) { if (r >= .5) for (let o = 0; o !== s; ++o)e[t + o] = e[i + o] } _slerp(e, t, i, r) { Hn.slerpFlat(e, t, e, t, e, i, r) } _slerpAdditive(e, t, i, r, s) { const o = this._workIndex * s; Hn.multiplyQuaternionsFlat(e, o, e, t, e, i), Hn.slerpFlat(e, t, e, t, e, o, r) } _lerp(e, t, i, r, s) { const o = 1 - r; for (let a = 0; a !== s; ++a) { const l = t + a; e[l] = e[l] * o + e[i + a] * r } } _lerpAdditive(e, t, i, r, s) { for (let o = 0; o !== s; ++o) { const a = t + o; e[a] = e[a] + e[i + o] * r } } } const x_ = "\\[\\]\\.:\\/", WG = new RegExp("[" + x_ + "]", "g"), A_ = "[^" + x_ + "]", jG = "[^" + x_.replace("\\.", "") + "]", JG = /((?:WC+[\/:])*)/.source.replace("WC", A_), XG = /(WCOD+)?/.source.replace("WCOD", jG), YG = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", A_), KG = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", A_), QG = new RegExp("^" + JG + XG + YG + KG + "$"), ZG = ["material", "materials", "bones", "map"]; class qG { constructor(e, t, i) { const r = i || Tt.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } getValue(e, t) { this.bind(); const i = this._targetGroup.nCachedObjects_, r = this._bindings[i]; r !== void 0 && r.getValue(e, t) } setValue(e, t) { const i = this._bindings; for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)i[r].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } } class Tt { constructor(e, t, i) { this.path = t, this.parsedPath = i || Tt.parseTrackName(t), this.node = Tt.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, i) { return e && e.isAnimationObjectGroup ? new Tt.Composite(e, t, i) : new Tt(e, t, i) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(WG, "") } static parseTrackName(e) { const t = QG.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf("."); if (r !== void 0 && r !== -1) { const s = i.nodeName.substring(r + 1); ZG.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s) } if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const i = e.skeleton.getBoneByName(t); if (i !== void 0) return i } if (e.children) { const i = function (s) { for (let o = 0; o < s.length; o++) { const a = s[o]; if (a.name === t || a.uuid === t) return a; const l = i(a.children); if (l) return l } return null }, r = i(e.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)e[t++] = i[r] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const i = this.resolvedProperty; for (let r = 0, s = i.length; r !== s; ++r)i[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, i = t.objectName, r = t.propertyName; let s = t.propertyIndex; if (e || (e = Tt.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); return } if (i) { let f = t.objectIndex; switch (i) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let d = 0; d < e.length; d++)if (e[d].name === f) { f = d; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[i] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[i] }if (f !== void 0) { if (e[f] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[f] } } const o = e[r]; if (o === void 0) { const f = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e); return } let a = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (s !== void 0) { if (r === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Tt.Composite = qG; Tt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Tt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Tt.prototype.GetterByBindingType = [Tt.prototype._getValue_direct, Tt.prototype._getValue_array, Tt.prototype._getValue_arrayElement, Tt.prototype._getValue_toArray]; Tt.prototype.SetterByBindingTypeAndVersioning = [[Tt.prototype._setValue_direct, Tt.prototype._setValue_direct_setNeedsUpdate, Tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_array, Tt.prototype._setValue_array_setNeedsUpdate, Tt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_arrayElement, Tt.prototype._setValue_arrayElement_setNeedsUpdate, Tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Tt.prototype._setValue_fromArray, Tt.prototype._setValue_fromArray_setNeedsUpdate, Tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class $G { constructor() { this.isAnimationObjectGroup = !0, this.uuid = Ui(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let i = 0, r = arguments.length; i !== r; ++i)e[arguments[i].uuid] = i; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length; let a, l = e.length, f = this.nCachedObjects_; for (let d = 0, h = arguments.length; d !== h; ++d) { const p = arguments[d], m = p.uuid; let v = t[m]; if (v === void 0) { v = l++, t[m] = v, e.push(p); for (let y = 0, x = o; y !== x; ++y)s[y].push(new Tt(p, i[y], r[y])) } else if (v < f) { a = e[v]; const y = --f, x = e[y]; t[x.uuid] = v, e[v] = x, t[m] = y, e[y] = p; for (let A = 0, _ = o; A !== _; ++A) { const w = s[A], S = w[y]; let T = w[v]; w[v] = S, T === void 0 && (T = new Tt(p, i[A], r[A])), w[y] = T } } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = f } remove() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let s = this.nCachedObjects_; for (let o = 0, a = arguments.length; o !== a; ++o) { const l = arguments[o], f = l.uuid, d = t[f]; if (d !== void 0 && d >= s) { const h = s++, p = e[h]; t[p.uuid] = d, e[d] = p, t[f] = h, e[h] = l; for (let m = 0, v = r; m !== v; ++m) { const y = i[m], x = y[h], A = y[d]; y[d] = x, y[h] = A } } } this.nCachedObjects_ = s } uncache() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let s = this.nCachedObjects_, o = e.length; for (let a = 0, l = arguments.length; a !== l; ++a) { const f = arguments[a], d = f.uuid, h = t[d]; if (h !== void 0) if (delete t[d], h < s) { const p = --s, m = e[p], v = --o, y = e[v]; t[m.uuid] = h, e[h] = m, t[y.uuid] = p, e[p] = y, e.pop(); for (let x = 0, A = r; x !== A; ++x) { const _ = i[x], w = _[p], S = _[v]; _[h] = w, _[p] = S, _.pop() } } else { const p = --o, m = e[p]; p > 0 && (t[m.uuid] = h), e[h] = m, e.pop(); for (let v = 0, y = r; v !== y; ++v) { const x = i[v]; x[h] = x[p], x.pop() } } } this.nCachedObjects_ = s } subscribe_(e, t) { const i = this._bindingsIndicesByPath; let r = i[e]; const s = this._bindings; if (r !== void 0) return s[r]; const o = this._paths, a = this._parsedPaths, l = this._objects, f = l.length, d = this.nCachedObjects_, h = new Array(f); r = s.length, i[e] = r, o.push(e), a.push(t), s.push(h); for (let p = d, m = l.length; p !== m; ++p) { const v = l[p]; h[p] = new Tt(v, e, t) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, i = t[e]; if (i !== void 0) { const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], f = e[a]; t[f] = i, o[i] = l, o.pop(), s[i] = s[a], s.pop(), r[i] = r[a], r.pop() } } } class eH { constructor(e, t, i = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r; const s = t.tracks, o = s.length, a = new Array(o), l = { endingStart: Ia, endingEnd: Ia }; for (let f = 0; f !== o; ++f) { const d = s[f].createInterpolant(null); a[f] = d, d.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = lB, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s; e.warp(1, o, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, i) { return e.crossFadeFrom(this, t, i) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { const r = this._mixer, s = r.time, o = this.timeScale; let a = this._timeScaleInterpolant; a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); const l = a.parameterPositions, f = a.sampleValues; return l[0] = s, l[1] = s + i, f[0] = e / o, f[1] = t / o, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, i, r) { if (!this.enabled) { this._updateWeight(e); return } const s = this._startTime; if (s !== null) { const l = (e - s) * i; l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l) } t *= this._updateTimeScale(e); const o = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const l = this._interpolants, f = this._propertyBindings; switch (this.blendMode) { case NA: for (let d = 0, h = l.length; d !== h; ++d)l[d].evaluate(o), f[d].accumulateAdditive(a); break; case _g: default: for (let d = 0, h = l.length; d !== h; ++d)l[d].evaluate(o), f[d].accumulate(r, a) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const i = this._weightInterpolant; if (i !== null) { const r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const i = this._timeScaleInterpolant; if (i !== null) { const r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, i = this.loop; let r = this.time + e, s = this._loopCount; const o = i === uB; if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r; if (i === aB) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) { const a = Math.floor(r / t); r -= t * a, s += Math.abs(a); const l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const f = e < 0; this._setEndings(f, !f, o) } else this._setEndings(!1, !1, o); this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (s & 1) === 1) return t - r } return r } _setEndings(e, t, i) { const r = this._interpolantSettings; i ? (r.endingStart = Fa, r.endingEnd = Fa) : (e ? r.endingStart = this.zeroSlopeAtStart ? Fa : Ia : r.endingStart = Hf, t ? r.endingEnd = this.zeroSlopeAtEnd ? Fa : Ia : r.endingEnd = Hf) } _scheduleFading(e, t, i) { const r = this._mixer, s = r.time; let o = this._weightInterpolant; o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this } } const tH = new Float32Array(1); class nH extends os { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = i.uuid, f = this._bindingsByRootAndName; let d = f[l]; d === void 0 && (d = {}, f[l] = d); for (let h = 0; h !== s; ++h) { const p = r[h], m = p.name; let v = d[m]; if (v !== void 0) ++v.referenceCount, o[h] = v; else { if (v = o[h], v !== void 0) { v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, m)); continue } const y = t && t._propertyBindings[h].binding.parsedPath; v = new u3(Tt.create(i, m, y), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, m), o[h] = v } a[h].resultBuffer = v.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r]; this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i) } const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, i) { const r = this._actions, s = this._actionsByClip; let o = s[t]; if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = o; else { const a = o.knownActions; e._byClipCacheIndex = a.length, a.push(e) } e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e } _removeInactiveAction(e) { const t = this._actions, i = t[t.length - 1], r = e._cacheIndex; i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null; const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, f = l[l.length - 1], d = e._byClipCacheIndex; f._byClipCacheIndex = d, l[d] = f, l.pop(), e._byClipCacheIndex = null; const h = a.actionByRoot, p = (e._localRoot || this._root).uuid; delete h[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let i = 0, r = t.length; i !== r; ++i) { const s = t[i]; --s.referenceCount === 0 && this._removeInactiveBinding(s) } } _lendAction(e) { const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _takeBackAction(e) { const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _addInactiveBinding(e, t, i) { const r = this._bindingsByRootAndName, s = this._bindings; let o = r[t]; o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e) } _removeInactiveBinding(e) { const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], f = e._cacheIndex; l._cacheIndex = f, t[f] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r] } _lendBinding(e) { const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _takeBackBinding(e) { const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r]; e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let i = e[t]; return i === void 0 && (i = new c_(new Float32Array(2), new Float32Array(2), 1, tH), i.__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r]; e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s } clipAction(e, t, i) { const r = t || this._root, s = r.uuid; let o = typeof e == "string" ? Nu.findByName(r, e) : e; const a = o !== null ? o.uuid : e, l = this._actionsByClip[a]; let f = null; if (i === void 0 && (o !== null ? i = o.blendMode : i = _g), l !== void 0) { const h = l.actionByRoot[s]; if (h !== void 0 && h.blendMode === i) return h; f = l.knownActions[0], o === null && (o = f._clip) } if (o === null) return null; const d = new eH(this, o, t, i); return this._bindAction(d, f), this._addInactiveAction(d, a, s), d } existingAction(e, t) { const i = t || this._root, r = i.uuid, s = typeof e == "string" ? Nu.findByName(i, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o]; return a !== void 0 && a.actionByRoot[r] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let i = t - 1; i >= 0; --i)e[i].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1; for (let f = 0; f !== i; ++f)t[f]._update(r, e, s, o); const a = this._bindings, l = this._nActiveBindings; for (let f = 0; f !== l; ++f)a[f].apply(o); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i]; if (s !== void 0) { const o = s.knownActions; for (let a = 0, l = o.length; a !== l; ++a) { const f = o[a]; this._deactivateAction(f); const d = f._cacheIndex, h = t[t.length - 1]; f._cacheIndex = null, f._byClipCacheIndex = null, h._cacheIndex = d, t[d] = h, t.pop(), this._removeInactiveBindingsForAction(f) } delete r[i] } } uncacheRoot(e) { const t = e.uuid, i = this._actionsByClip; for (const o in i) { const a = i[o].actionByRoot, l = a[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const r = this._bindingsByRootAndName, s = r[t]; if (s !== void 0) for (const o in s) { const a = s[o]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction(e, t) { const i = this.existingAction(e, t); i !== null && (this._deactivateAction(i), this._removeInactiveAction(i)) } } class __ { constructor(e) { this.value = e } clone() { return new __(this.value.clone === void 0 ? this.value : this.value.clone()) } } let iH = 0; class rH extends os { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: iH++ }), this.name = "", this.usage = Vf, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let i = 0, r = t.length; i < r; i++)this.uniforms.push(t[i].clone()); return this } clone() { return new this.constructor().copy(this) } } class sH extends md { constructor(e, t, i = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class oH { constructor(e, t, i, r, s) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } class c3 { constructor(e, t, i = 0, r = 1 / 0) { this.ray = new dd(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Ja, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, i = []) { return r1(e, this, i, t), i.sort(dE), i } intersectObjects(e, t = !0, i = []) { for (let r = 0, s = e.length; r < s; r++)r1(e[r], this, i, t); return i.sort(dE), i } } function dE(n, e) { return n.distance - e.distance } function r1(n, e, t, i) { if (n.layers.test(e.layers) && n.raycast(e, t), i === !0) { const r = n.children; for (let s = 0, o = r.length; s < o; s++)r1(r[s], e, t, !0) } } class s1 { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.phi = t, this.theta = i, this } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(gn(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class aH { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.theta = t, this.y = i, this } set(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } clone() { return new this.constructor().copy(this) } } const hE = new pe; class lH { constructor(e = new pe(1 / 0, 1 / 0), t = new pe(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = hE.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return hE.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const pE = new I, Pp = new I; class uH { constructor(e = new I, t = new I) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { pE.subVectors(e, this.start), Pp.subVectors(this.end, this.start); const i = Pp.dot(Pp); let s = Pp.dot(pE) / i; return t && (s = gn(s, 0, 1)), s } closestPointToPoint(e, t, i) { const r = this.closestPointToPointParameter(e, t); return this.delta(i).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const mE = new I; class cH extends bt { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const i = new ut, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, a = 1, l = 32; o < l; o++, a++) { const f = o / l * Math.PI * 2, d = a / l * Math.PI * 2; r.push(Math.cos(f), Math.sin(f), 1, Math.cos(d), Math.sin(d), 1) } i.setAttribute("position", new We(r, 3)); const s = new ei({ fog: !1, toneMapped: !1 }); this.cone = new Or(i, s), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), mE.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(mE), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const lo = new I, Bp = new it, ev = new it; class fH extends Or { constructor(e) { const t = f3(e), i = new ut, r = [], s = [], o = new Le(0, 0, 1), a = new Le(0, 1, 0); for (let f = 0; f < t.length; f++) { const d = t[f]; d.parent && d.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b)) } i.setAttribute("position", new We(r, 3)), i.setAttribute("color", new We(s, 3)); const l = new ei({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(i, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, i = this.geometry, r = i.getAttribute("position"); ev.copy(this.root.matrixWorld).invert(); for (let s = 0, o = 0; s < t.length; s++) { const a = t[s]; a.parent && a.parent.isBone && (Bp.multiplyMatrices(ev, a.matrixWorld), lo.setFromMatrixPosition(Bp), r.setXYZ(o, lo.x, lo.y, lo.z), Bp.multiplyMatrices(ev, a.parent.matrixWorld), lo.setFromMatrixPosition(Bp), r.setXYZ(o + 1, lo.x, lo.y, lo.z), o += 2) } i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function f3(n) { const e = []; n.isBone === !0 && e.push(n); for (let t = 0; t < n.children.length; t++)e.push.apply(e, f3(n.children[t])); return e } class dH extends Tn { constructor(e, t, i) { const r = new Yu(t, 4, 2), s = new Oi({ wireframe: !0, fog: !1, toneMapped: !1 }); super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const hH = new I, gE = new Le, yE = new Le; class pH extends bt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper"; const r = new Xu(t); r.rotateY(Math.PI * .5), this.material = new Oi({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const s = r.getAttribute("position"), o = new Float32Array(s.count * 3); r.setAttribute("color", new It(o, 3)), this.add(new Tn(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); gE.copy(this.light.color), yE.copy(this.light.groundColor); for (let i = 0, r = t.count; i < r; i++) { const s = i < r / 2 ? gE : yE; t.setXYZ(i, s.r, s.g, s.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(hH.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class mH extends Or { constructor(e = 10, t = 10, i = 4473924, r = 8947848) { i = new Le(i), r = new Le(r); const s = t / 2, o = e / t, a = e / 2, l = [], f = []; for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) { l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a); const y = p === s ? i : r; y.toArray(f, m), m += 3, y.toArray(f, m), m += 3, y.toArray(f, m), m += 3, y.toArray(f, m), m += 3 } const d = new ut; d.setAttribute("position", new We(l, 3)), d.setAttribute("color", new We(f, 3)); const h = new ei({ vertexColors: !0, toneMapped: !1 }); super(d, h), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class gH extends Or { constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) { s = new Le(s), o = new Le(o); const a = [], l = []; if (t > 1) for (let h = 0; h < t; h++) { const p = h / t * (Math.PI * 2), m = Math.sin(p) * e, v = Math.cos(p) * e; a.push(0, 0, 0), a.push(m, 0, v); const y = h & 1 ? s : o; l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b) } for (let h = 0; h < i; h++) { const p = h & 1 ? s : o, m = e - e / i * h; for (let v = 0; v < r; v++) { let y = v / r * (Math.PI * 2), x = Math.sin(y) * m, A = Math.cos(y) * m; a.push(x, 0, A), l.push(p.r, p.g, p.b), y = (v + 1) / r * (Math.PI * 2), x = Math.sin(y) * m, A = Math.cos(y) * m, a.push(x, 0, A), l.push(p.r, p.g, p.b) } } const f = new ut; f.setAttribute("position", new We(a, 3)), f.setAttribute("color", new We(l, 3)); const d = new ei({ vertexColors: !0, toneMapped: !1 }); super(f, d), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const vE = new I, Rp = new I, xE = new I; class yH extends bt { constructor(e, t, i) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let r = new ut; r.setAttribute("position", new We([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const s = new ei({ fog: !1, toneMapped: !1 }); this.lightPlane = new Ws(r, s), this.add(this.lightPlane), r = new ut, r.setAttribute("position", new We([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ws(r, s), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), vE.setFromMatrixPosition(this.light.matrixWorld), Rp.setFromMatrixPosition(this.light.target.matrixWorld), xE.subVectors(Rp, vE), this.lightPlane.lookAt(Rp), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Rp), this.targetLine.scale.z = xE.length() } } const Lp = new I, un = new hd; class vH extends Or { constructor(e) { const t = new ut, i = new ei({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a(v, y) { l(v), l(y) } function l(v) { r.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(r.length / 3 - 1) } t.setAttribute("position", new We(r, 3)), t.setAttribute("color", new We(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update(); const f = new Le(16755200), d = new Le(16711680), h = new Le(43775), p = new Le(16777215), m = new Le(3355443); this.setColors(f, d, h, p, m) } setColors(e, t, i, r, s) { const a = this.geometry.getAttribute("color"); a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, i = 1, r = 1; un.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), pn("c", t, e, un, 0, 0, -1), pn("t", t, e, un, 0, 0, 1), pn("n1", t, e, un, -i, -r, -1), pn("n2", t, e, un, i, -r, -1), pn("n3", t, e, un, -i, r, -1), pn("n4", t, e, un, i, r, -1), pn("f1", t, e, un, -i, -r, 1), pn("f2", t, e, un, i, -r, 1), pn("f3", t, e, un, -i, r, 1), pn("f4", t, e, un, i, r, 1), pn("u1", t, e, un, i * .7, r * 1.1, -1), pn("u2", t, e, un, -i * .7, r * 1.1, -1), pn("u3", t, e, un, 0, r * 2, -1), pn("cf1", t, e, un, -i, 0, 1), pn("cf2", t, e, un, i, 0, 1), pn("cf3", t, e, un, 0, -r, 1), pn("cf4", t, e, un, 0, r, 1), pn("cn1", t, e, un, -i, 0, -1), pn("cn2", t, e, un, i, 0, -1), pn("cn3", t, e, un, 0, -r, -1), pn("cn4", t, e, un, 0, r, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function pn(n, e, t, i, r, s, o) { Lp.set(r, s, o).unproject(i); const a = e[n]; if (a !== void 0) { const l = t.getAttribute("position"); for (let f = 0, d = a.length; f < d; f++)l.setXYZ(a[f], Lp.x, Lp.y, Lp.z) } } const Dp = new Xo; class xH extends Or { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new ut; s.setIndex(new It(i, 1)), s.setAttribute("position", new It(r, 3)), super(s, new ei({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Dp.setFromObject(this.object), Dp.isEmpty()) return; const t = Dp.min, i = Dp.max, r = this.geometry.attributes.position, s = r.array; s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class AH extends Or { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new ut; s.setIndex(new It(i, 1)), s.setAttribute("position", new We(r, 3)), super(s, new ei({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class _H extends Ws { constructor(e, t = 1, i = 16776960) { const r = i, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new ut; o.setAttribute("position", new We(s, 3)), o.computeBoundingSphere(), super(o, new ei({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new ut; l.setAttribute("position", new We(a, 3)), l.computeBoundingSphere(), this.add(new Tn(l, new Oi({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const AE = new I; let Ip, tv; class MH extends bt { constructor(e = new I(0, 0, 1), t = new I(0, 0, 0), i = 1, r = 16776960, s = i * .2, o = s * .2) { super(), this.type = "ArrowHelper", Ip === void 0 && (Ip = new ut, Ip.setAttribute("position", new We([0, 0, 0, 0, 1, 0], 3)), tv = new ol(0, .5, 1, 5, 1), tv.translate(0, -.5, 0)), this.position.copy(t), this.line = new Ws(Ip, new ei({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Tn(tv, new Oi({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { AE.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(AE, t) } } setLength(e, t = e * .2, i = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class wH extends Or { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], r = new ut; r.setAttribute("position", new We(t, 3)), r.setAttribute("color", new We(i, 3)); const s = new ei({ vertexColors: !0, toneMapped: !1 }); super(r, s), this.type = "AxesHelper" } setColors(e, t, i) { const r = new Le, s = this.geometry.attributes.color.array; return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class SH { constructor() { this.type = "ShapePath", this.color = new Le, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Jf, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, i, r) { return this.currentPath.quadraticCurveTo(e, t, i, r), this } bezierCurveTo(e, t, i, r, s, o) { return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(A) { const _ = []; for (let w = 0, S = A.length; w < S; w++) { const T = A[w], P = new Xa; P.curves = T.curves, _.push(P) } return _ } function i(A, _) { const w = _.length; let S = !1; for (let T = w - 1, P = 0; P < w; T = P++) { let R = _[T], E = _[P], B = E.x - R.x, L = E.y - R.y; if (Math.abs(L) > Number.EPSILON) { if (L < 0 && (R = _[P], B = -B, E = _[T], L = -L), A.y < R.y || A.y > E.y) continue; if (A.y === R.y) { if (A.x === R.x) return !0 } else { const U = L * (A.x - R.x) - B * (A.y - R.y); if (U === 0) return !0; if (U < 0) continue; S = !S } } else { if (A.y !== R.y) continue; if (E.x <= A.x && A.x <= R.x || R.x <= A.x && A.x <= E.x) return !0 } } return S } const r = es.isClockWise, s = this.subPaths; if (s.length === 0) return []; let o, a, l; const f = []; if (s.length === 1) return a = s[0], l = new Xa, l.curves = a.curves, f.push(l), f; let d = !r(s[0].getPoints()); d = e ? !d : d; const h = [], p = []; let m = [], v = 0, y; p[v] = void 0, m[v] = []; for (let A = 0, _ = s.length; A < _; A++)a = s[A], y = a.getPoints(), o = r(y), o = e ? !o : o, o ? (!d && p[v] && v++, p[v] = { s: new Xa, p: y }, p[v].s.curves = a.curves, d && v++, m[v] = []) : m[v].push({ h: a, p: y[0] }); if (!p[0]) return t(s); if (p.length > 1) { let A = !1, _ = 0; for (let w = 0, S = p.length; w < S; w++)h[w] = []; for (let w = 0, S = p.length; w < S; w++) { const T = m[w]; for (let P = 0; P < T.length; P++) { const R = T[P]; let E = !0; for (let B = 0; B < p.length; B++)i(R.p, p[B].p) && (w !== B && _++, E ? (E = !1, h[B].push(R)) : A = !0); E && h[w].push(R) } } _ > 0 && A === !1 && (m = h) } let x; for (let A = 0, _ = p.length; A < _; A++) { l = p[A].s, f.push(l), x = m[A]; for (let w = 0, S = x.length; w < S; w++)l.holes.push(x[w].h) } return f } } const Es = CH(); function CH() { const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), i = new Uint32Array(512), r = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const f = l - 127; f < -27 ? (i[l] = 0, i[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : f < -14 ? (i[l] = 1024 >> -f - 14, i[l | 256] = 1024 >> -f - 14 | 32768, r[l] = -f - 1, r[l | 256] = -f - 1) : f <= 15 ? (i[l] = f + 15 << 10, i[l | 256] = f + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : f < 128 ? (i[l] = 31744, i[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, r[l] = 13, r[l | 256] = 13) } const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let f = l << 13, d = 0; for (; !(f & 8388608);)f <<= 1, d -= 8388608; f &= -8388609, d += 947912704, s[l] = f | d } for (let l = 1024; l < 2048; ++l)s[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)o[l] = l << 23; o[31] = 1199570944, o[32] = 2147483648; for (let l = 33; l < 63; ++l)o[l] = 2147483648 + (l - 32 << 23); o[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (a[l] = 1024); return { floatView: e, uint32View: t, baseTable: i, shiftTable: r, mantissaTable: s, exponentTable: o, offsetTable: a } } function EH(n) { Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = gn(n, -65504, 65504), Es.floatView[0] = n; const e = Es.uint32View[0], t = e >> 23 & 511; return Es.baseTable[t] + ((e & 8388607) >> Es.shiftTable[t]) } function TH(n) { const e = n >> 10; return Es.uint32View[0] = Es.mantissaTable[Es.offsetTable[e] + (n & 1023)] + Es.exponentTable[e], Es.floatView[0] } var bH = Object.freeze({ __proto__: null, fromHalfFloat: TH, toHalfFloat: EH }); class PH extends Ko { constructor(e, t, i, r, s, o) { console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, i, r, s, o) } } class BH extends vd { constructor(e, t, i, r) { console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, i, r) } } class RH extends xd { constructor(e, t, i, r) { console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, i, r) } } class LH extends Ad { constructor(e, t, i, r, s, o, a) { console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, i, r, s, o, a) } } class DH extends ol { constructor(e, t, i, r, s, o, a, l) { console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, i, r, s, o, a, l) } } class IH extends _d { constructor(e, t) { console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t) } } class FH extends Md { constructor(e, t) { console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t) } } class NH extends wd { constructor(e, t) { console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t) } } class OH extends Ju { constructor(e, t, i, r) { console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, i, r) } } class kH extends Xu { constructor(e, t) { console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t) } } class UH extends Wu { constructor(e, t, i, r) { console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, i, r) } } class zH extends Xs { constructor(e, t, i, r) { console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, i, r) } } class GH extends Sd { constructor(e, t, i, r, s, o) { console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, i, r, s, o) } } class HH extends Cd { constructor(e, t) { console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t) } } class VH extends Yu { constructor(e, t, i, r, s, o, a) { console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, i, r, s, o, a) } } class WH extends Ed { constructor(e, t) { console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t) } } class jH extends Td { constructor(e, t, i, r, s) { console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, i, r, s) } } class JH extends bd { constructor(e, t, i, r, s, o) { console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, i, r, s, o) } } class XH extends Pd { constructor(e, t, i, r, s) { console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, i, r, s) } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: yg } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = yg); const o1 = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: IA, AddEquation: Ta, AddOperation: GP, AdditiveAnimationBlendMode: NA, AdditiveBlending: Mx, AlphaFormat: ZP, AlwaysDepth: IP, AlwaysStencilFunc: pB, AmbientLight: n3, AmbientLightProbe: OG, AnimationClip: Nu, AnimationLoader: EG, AnimationMixer: nH, AnimationObjectGroup: $G, AnimationUtils: MG, ArcCurve: DB, ArrayCamera: EB, ArrowHelper: MH, Audio: l3, AudioAnalyser: VG, AudioContext: y_, AudioListener: zG, AudioLoader: FG, AxesHelper: wH, BackSide: Ei, BasicDepthPacking: fB, BasicShadowMap: AP, Bone: Tg, BooleanKeyframeTrack: al, Box2: lH, Box3: Xo, Box3Helper: AH, BoxBufferGeometry: PH, BoxGeometry: Ko, BoxHelper: xH, BufferAttribute: It, BufferGeometry: ut, BufferGeometryLoader: o3, ByteType: JP, Cache: nl, Camera: hd, CameraHelper: vH, CanvasTexture: Jz, CapsuleBufferGeometry: BH, CapsuleGeometry: vd, CatmullRomCurve3: IB, CineonToneMapping: WP, CircleBufferGeometry: RH, CircleGeometry: xd, ClampToEdgeWrapping: zn, Clock: v_, Color: Le, ColorKeyframeTrack: f_, ColorManagement: Zn, CompressedArrayTexture: jz, CompressedTexture: t_, CompressedTextureLoader: TG, ConeBufferGeometry: LH, ConeGeometry: Ad, CubeCamera: WA, CubeReflectionMapping: Oo, CubeRefractionMapping: ko, CubeTexture: pd, CubeTextureLoader: bG, CubeUVReflectionMapping: Vu, CubicBezierCurve: i_, CubicBezierCurve3: FB, CubicInterpolant: qB, CullFaceBack: _x, CullFaceFront: xP, CullFaceFrontBack: ZF, CullFaceNone: vP, Curve: kr, CurvePath: OB, CustomBlending: _P, CustomToneMapping: jP, CylinderBufferGeometry: DH, CylinderGeometry: ol, Cylindrical: aH, Data3DTexture: GA, DataArrayTexture: Mg, DataTexture: xu, DataTextureLoader: PG, DataUtils: bH, DecrementStencilOp: lN, DecrementWrapStencilOp: cN, DefaultLoadingManager: lu, DepthFormat: Do, DepthStencilFormat: $a, DepthTexture: TB, DirectionalLight: g_, DirectionalLightHelper: yH, DiscreteInterpolant: $B, DodecahedronBufferGeometry: IH, DodecahedronGeometry: _d, DoubleSide: Br, DstAlphaFactor: bP, DstColorFactor: BP, DynamicCopyUsage: SN, DynamicDrawUsage: Va, DynamicReadUsage: _N, EdgesGeometry: kB, EllipseCurve: bg, EqualDepth: NP, EqualStencilFunc: pN, EquirectangularReflectionMapping: Uf, EquirectangularRefractionMapping: zf, Euler: sl, EventDispatcher: os, ExtrudeBufferGeometry: FH, ExtrudeGeometry: Md, FileLoader: Gi, Float16BufferAttribute: rO, Float32BufferAttribute: We, Float64BufferAttribute: sO, FloatType: Bs, Fog: Eg, FogExp2: Cg, FramebufferTexture: Wz, FrontSide: is, Frustum: wg, GLBufferAttribute: oH, GLSL1: EN, GLSL3: Qx, GreaterDepth: kP, GreaterEqualDepth: OP, GreaterEqualStencilFunc: vN, GreaterStencilFunc: gN, GridHelper: mH, Group: Ls, HalfFloatType: Pu, HemisphereLight: t3, HemisphereLightHelper: pH, HemisphereLightProbe: NG, IcosahedronBufferGeometry: NH, IcosahedronGeometry: wd, ImageBitmapLoader: a3, ImageLoader: Qf, ImageUtils: zA, IncrementStencilOp: aN, IncrementWrapStencilOp: uN, InstancedBufferAttribute: Du, InstancedBufferGeometry: s3, InstancedInterleavedBuffer: sH, InstancedMesh: LB, Int16BufferAttribute: nO, Int32BufferAttribute: iO, Int8BufferAttribute: $N, IntType: YP, InterleavedBuffer: md, InterleavedBufferAttribute: zo, Interpolant: Qu, InterpolateDiscrete: Bu, InterpolateLinear: el, InterpolateSmooth: am, InvertStencilOp: fN, KeepStencilOp: lm, KeyframeTrack: Ur, LOD: RB, LatheBufferGeometry: OH, LatheGeometry: Ju, Layers: Ja, LessDepth: FP, LessEqualDepth: Um, LessEqualStencilFunc: mN, LessStencilFunc: hN, Light: Qo, LightProbe: Rg, Line: Ws, Line3: uH, LineBasicMaterial: ei, LineCurve: Pg, LineCurve3: NB, LineDashedMaterial: QB, LineLoop: $A, LineSegments: Or, LinearEncoding: Vs, LinearFilter: en, LinearInterpolant: c_, LinearMipMapLinearFilter: nN, LinearMipMapNearestFilter: tN, LinearMipmapLinearFilter: rs, LinearMipmapNearestFilter: Ag, LinearSRGBColorSpace: Ru, LinearToneMapping: HP, Loader: hi, LoaderUtils: ts, LoadingManager: d_, LoopOnce: aB, LoopPingPong: uB, LoopRepeat: lB, LuminanceAlphaFormat: $P, LuminanceFormat: qP, MOUSE: _a, Material: Mn, MaterialLoader: Lg, MathUtils: UA, Matrix3: li, Matrix4: it, MaxEquation: Ex, Mesh: Tn, MeshBasicMaterial: Oi, MeshDepthMaterial: XA, MeshDistanceMaterial: YA, MeshLambertMaterial: YB, MeshMatcapMaterial: KB, MeshNormalMaterial: XB, MeshPhongMaterial: jB, MeshPhysicalMaterial: Ys, MeshStandardMaterial: Ku, MeshToonMaterial: JB, MinEquation: Cx, MirroredRepeatWrapping: bu, MixOperation: zP, MultiplyBlending: Sx, MultiplyOperation: fd, NearestFilter: fn, NearestMipMapLinearFilter: eN, NearestMipMapNearestFilter: $F, NearestMipmapLinearFilter: vu, NearestMipmapNearestFilter: Gf, NeverDepth: DP, NeverStencilFunc: dN, NoBlending: Fs, NoColorSpace: rN, NoToneMapping: Dr, NormalAnimationBlendMode: _g, NormalBlending: Ga, NotEqualDepth: UP, NotEqualStencilFunc: yN, NumberKeyframeTrack: Iu, Object3D: bt, ObjectLoader: DG, ObjectSpaceNormalMap: hB, OctahedronBufferGeometry: kH, OctahedronGeometry: Xu, OneFactor: CP, OneMinusDstAlphaFactor: PP, OneMinusDstColorFactor: RP, OneMinusSrcAlphaFactor: DA, OneMinusSrcColorFactor: TP, OrthographicCamera: Ir, PCFShadowMap: vg, PCFSoftShadowMap: ff, PMREMGenerator: qx, Path: Jf, PerspectiveCamera: Gt, Plane: go, PlaneBufferGeometry: UH, PlaneGeometry: Wu, PlaneHelper: _H, PointLight: m_, PointLightHelper: dH, Points: e_, PointsMaterial: yd, PolarGridHelper: gH, PolyhedronBufferGeometry: zH, PolyhedronGeometry: Xs, PositionalAudio: HG, PropertyBinding: Tt, PropertyMixer: u3, QuadraticBezierCurve: r_, QuadraticBezierCurve3: s_, Quaternion: Hn, QuaternionKeyframeTrack: Go, QuaternionLinearInterpolant: e3, RED_GREEN_RGTC2_Format: Yx, RED_RGTC1_Format: oB, REVISION: yg, RGBADepthPacking: dB, RGBAFormat: Ai, RGBAIntegerFormat: rB, RGBA_ASTC_10x10_Format: Wx, RGBA_ASTC_10x5_Format: Gx, RGBA_ASTC_10x6_Format: Hx, RGBA_ASTC_10x8_Format: Vx, RGBA_ASTC_12x10_Format: jx, RGBA_ASTC_12x12_Format: Jx, RGBA_ASTC_4x4_Format: Dx, RGBA_ASTC_5x4_Format: Ix, RGBA_ASTC_5x5_Format: Fx, RGBA_ASTC_6x5_Format: Nx, RGBA_ASTC_6x6_Format: Ox, RGBA_ASTC_8x5_Format: kx, RGBA_ASTC_8x6_Format: Ux, RGBA_ASTC_8x8_Format: zx, RGBA_BPTC_Format: om, RGBA_ETC2_EAC_Format: Lx, RGBA_PVRTC_2BPPV1_Format: Bx, RGBA_PVRTC_4BPPV1_Format: Px, RGBA_S3TC_DXT1_Format: im, RGBA_S3TC_DXT3_Format: rm, RGBA_S3TC_DXT5_Format: sm, RGB_ETC1_Format: sB, RGB_ETC2_Format: Rx, RGB_PVRTC_2BPPV1_Format: bx, RGB_PVRTC_4BPPV1_Format: Tx, RGB_S3TC_DXT1_Format: nm, RGFormat: nB, RGIntegerFormat: iB, RawShaderMaterial: WB, Ray: dd, Raycaster: c3, RectAreaLight: i3, RedFormat: eB, RedIntegerFormat: tB, ReinhardToneMapping: VP, RepeatWrapping: Uo, ReplaceStencilOp: oN, ReverseSubtractEquation: wP, RingBufferGeometry: GH, RingGeometry: Sd, SIGNED_RED_GREEN_RGTC2_Format: Kx, SIGNED_RED_RGTC1_Format: Xx, SRGBColorSpace: Tr, Scene: QA, ShaderChunk: pt, ShaderLib: Pr, ShaderMaterial: ss, ShadowMaterial: VB, Shape: Xa, ShapeBufferGeometry: HH, ShapeGeometry: Cd, ShapePath: SH, ShapeUtils: es, ShortType: XP, Skeleton: gd, SkeletonHelper: fH, SkinnedMesh: qA, Source: Na, Sphere: Yo, SphereBufferGeometry: VH, SphereGeometry: Yu, Spherical: s1, SphericalHarmonics3: r3, SplineCurve: o_, SpotLight: p_, SpotLightHelper: cH, Sprite: BB, SpriteMaterial: ZA, SrcAlphaFactor: LA, SrcAlphaSaturateFactor: LP, SrcColorFactor: EP, StaticCopyUsage: wN, StaticDrawUsage: Vf, StaticReadUsage: AN, StereoCamera: kG, StreamCopyUsage: CN, StreamDrawUsage: xN, StreamReadUsage: MN, StringKeyframeTrack: ll, SubtractEquation: MP, SubtractiveBlending: wx, TOUCH: Ma, TangentSpaceNormalMap: Js, TetrahedronBufferGeometry: WH, TetrahedronGeometry: Ed, Texture: Qt, TextureLoader: Bd, TorusBufferGeometry: jH, TorusGeometry: Td, TorusKnotBufferGeometry: JH, TorusKnotGeometry: bd, Triangle: ur, TriangleFanDrawMode: OA, TriangleStripDrawMode: cB, TrianglesDrawMode: iN, TubeBufferGeometry: XH, TubeGeometry: Pd, TwoPassDoubleSide: qF, UVMapping: xg, Uint16BufferAttribute: HA, Uint32BufferAttribute: VA, Uint8BufferAttribute: eO, Uint8ClampedBufferAttribute: tO, Uniform: __, UniformsGroup: rH, UniformsLib: Re, UniformsUtils: xB, UnsignedByteType: Hs, UnsignedInt248Type: Ha, UnsignedIntType: Mo, UnsignedShort4444Type: KP, UnsignedShort5551Type: QP, UnsignedShortType: FA, VSMShadowMap: Da, Vector2: pe, Vector3: I, Vector4: Nt, VectorKeyframeTrack: Fu, VideoTexture: Vz, WebGL1Renderer: bB, WebGL3DRenderTarget: VN, WebGLArrayRenderTarget: HN, WebGLCubeRenderTarget: jA, WebGLMultipleRenderTargets: WN, WebGLRenderTarget: Nr, WebGLRenderer: KA, WebGLUtils: CB, WireframeGeometry: HB, WrapAroundEnding: Hf, ZeroCurvatureEnding: Ia, ZeroFactor: SP, ZeroSlopeEnding: Fa, ZeroStencilOp: sN, _SRGBAFormat: zm, sRGBEncoding: Ct }, Symbol.toStringTag, { value: "Module" })); var wo = {}, YH = { get exports() { return wo }, set exports(n) { wo = n } }, ul = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ul.ConcurrentRoot = 1; ul.ContinuousEventPriority = 4; ul.DefaultEventPriority = 16; ul.DiscreteEventPriority = 1; ul.IdleEventPriority = 536870912; ul.LegacyRoot = 0; (function (n) { n.exports = ul })(YH); function KH(n) { let e; const t = new Set, i = (f, d) => { const h = typeof f == "function" ? f(e) : f; if (h !== e) { const p = e; e = d ? h : Object.assign({}, e, h), t.forEach(m => m(e, p)) } }, r = () => e, s = (f, d = r, h = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let p = d(e); function m() { const v = d(e); if (!h(p, v)) { const y = p; f(p = v, y) } } return t.add(m), () => t.delete(m) }, l = { setState: i, getState: r, subscribe: (f, d, h) => d || h ? s(f, d, h) : (t.add(f), () => t.delete(f)), destroy: () => t.clear() }; return e = n(i, r, l), l } const QH = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), _E = QH ? z.useEffect : z.useLayoutEffect; function d3(n) { const e = typeof n == "function" ? KH(n) : n, t = (i = e.getState, r = Object.is) => { const [, s] = z.useReducer(x => x + 1, 0), o = e.getState(), a = z.useRef(o), l = z.useRef(i), f = z.useRef(r), d = z.useRef(!1), h = z.useRef(); h.current === void 0 && (h.current = i(o)); let p, m = !1; (a.current !== o || l.current !== i || f.current !== r || d.current) && (p = i(o), m = !r(h.current, p)), _E(() => { m && (h.current = p), a.current = o, l.current = i, f.current = r, d.current = !1 }); const v = z.useRef(o); _E(() => { const x = () => { try { const _ = e.getState(), w = l.current(_); f.current(h.current, w) || (a.current = _, h.current = w, s()) } catch { d.current = !0, s() } }, A = e.subscribe(x); return e.getState() !== v.current && x(), A }, []); const y = m ? p : h.current; return z.useDebugValue(y), y }; return Object.assign(t, e), t[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const i = [t, e]; return { next() { const r = i.length <= 0; return { value: i.shift(), done: r } } } }, t } var a1 = {}, ZH = { get exports() { return a1 }, set exports(n) { a1 = n } }, Zf = {}, qH = { get exports() { return Zf }, set exports(n) { Zf = n } }, h3 = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(N, V) { var Y = N.length; N.push(V); e: for (; 0 < Y;) { var re = Y - 1 >>> 1, j = N[re]; if (0 < r(j, V)) N[re] = V, N[Y] = j, Y = re; else break e } } function t(N) { return N.length === 0 ? null : N[0] } function i(N) { if (N.length === 0) return null; var V = N[0], Y = N.pop(); if (Y !== V) { N[0] = Y; e: for (var re = 0, j = N.length, ie = j >>> 1; re < ie;) { var ve = 2 * (re + 1) - 1, Ae = N[ve], $ = ve + 1, Oe = N[$]; if (0 > r(Ae, Y)) $ < j && 0 > r(Oe, Ae) ? (N[re] = Oe, N[$] = Y, re = $) : (N[re] = Ae, N[ve] = Y, re = ve); else if ($ < j && 0 > r(Oe, Y)) N[re] = Oe, N[$] = Y, re = $; else break e } } return V } function r(N, V) { var Y = N.sortIndex - V.sortIndex; return Y !== 0 ? Y : N.id - V.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); n.unstable_now = function () { return o.now() - a } } var l = [], f = [], d = 1, h = null, p = 3, m = !1, v = !1, y = !1, x = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function w(N) { for (var V = t(f); V !== null;) { if (V.callback === null) i(f); else if (V.startTime <= N) i(f), V.sortIndex = V.expirationTime, e(l, V); else break; V = t(f) } } function S(N) { if (y = !1, w(N), !v) if (t(l) !== null) v = !0, ne(T); else { var V = t(f); V !== null && oe(S, V.startTime - N) } } function T(N, V) { v = !1, y && (y = !1, A(E), E = -1), m = !0; var Y = p; try { for (w(V), h = t(l); h !== null && (!(h.expirationTime > V) || N && !U());) { var re = h.callback; if (typeof re == "function") { h.callback = null, p = h.priorityLevel; var j = re(h.expirationTime <= V); V = n.unstable_now(), typeof j == "function" ? h.callback = j : h === t(l) && i(l), w(V) } else i(l); h = t(l) } if (h !== null) var ie = !0; else { var ve = t(f); ve !== null && oe(S, ve.startTime - V), ie = !1 } return ie } finally { h = null, p = Y, m = !1 } } var P = !1, R = null, E = -1, B = 5, L = -1; function U() { return !(n.unstable_now() - L < B) } function q() { if (R !== null) { var N = n.unstable_now(); L = N; var V = !0; try { V = R(!0, N) } finally { V ? W() : (P = !1, R = null) } } else P = !1 } var W; if (typeof _ == "function") W = function () { _(q) }; else if (typeof MessageChannel < "u") { var G = new MessageChannel, K = G.port2; G.port1.onmessage = q, W = function () { K.postMessage(null) } } else W = function () { x(q, 0) }; function ne(N) { R = N, P || (P = !0, W()) } function oe(N, V) { E = x(function () { N(n.unstable_now()) }, V) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (N) { N.callback = null }, n.unstable_continueExecution = function () { v || m || (v = !0, ne(T)) }, n.unstable_forceFrameRate = function (N) { 0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < N ? Math.floor(1e3 / N) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return p }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (N) { switch (p) { case 1: case 2: case 3: var V = 3; break; default: V = p }var Y = p; p = V; try { return N() } finally { p = Y } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (N, V) { switch (N) { case 1: case 2: case 3: case 4: case 5: break; default: N = 3 }var Y = p; p = N; try { return V() } finally { p = Y } }, n.unstable_scheduleCallback = function (N, V, Y) { var re = n.unstable_now(); switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? re + Y : re) : Y = re, N) { case 1: var j = -1; break; case 2: j = 250; break; case 5: j = 1073741823; break; case 4: j = 1e4; break; default: j = 5e3 }return j = Y + j, N = { id: d++, callback: V, priorityLevel: N, startTime: Y, expirationTime: j, sortIndex: -1 }, Y > re ? (N.sortIndex = Y, e(f, N), t(l) === null && N === t(f) && (y ? (A(E), E = -1) : y = !0, oe(S, Y - re))) : (N.sortIndex = j, e(l, N), v || m || (v = !0, ne(T))), N }, n.unstable_shouldYield = U, n.unstable_wrapCallback = function (N) { var V = p; return function () { var Y = p; p = V; try { return N.apply(this, arguments) } finally { p = Y } } } })(h3); (function (n) { n.exports = h3 })(qH);/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $H = function (e) {
	var t = {}, i = z, r = Zf, s = Object.assign; function o(u) { for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, g = 1; g < arguments.length; g++)c += "&args[]=" + encodeURIComponent(arguments[g]); return "Minified React error #" + u + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), f = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), h = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), v = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), x = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), _ = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), T = Symbol.iterator; function P(u) { return u === null || typeof u != "object" ? null : (u = T && u[T] || u["@@iterator"], typeof u == "function" ? u : null) } function R(u) { if (u == null) return null; if (typeof u == "function") return u.displayName || u.name || null; if (typeof u == "string") return u; switch (u) { case d: return "Fragment"; case f: return "Portal"; case p: return "Profiler"; case h: return "StrictMode"; case x: return "Suspense"; case A: return "SuspenseList" }if (typeof u == "object") switch (u.$$typeof) { case v: return (u.displayName || "Context") + ".Consumer"; case m: return (u._context.displayName || "Context") + ".Provider"; case y: var c = u.render; return u = u.displayName, u || (u = c.displayName || c.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u; case _: return c = u.displayName || null, c !== null ? c : R(u.type) || "Memo"; case w: c = u._payload, u = u._init; try { return R(u(c)) } catch { } }return null } function E(u) { var c = u.type; switch (u.tag) { case 24: return "Cache"; case 9: return (c.displayName || "Context") + ".Consumer"; case 10: return (c._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return u = c.render, u = u.displayName || u.name || "", c.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return c; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return R(c); case 8: return c === h ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof c == "function") return c.displayName || c.name || null; if (typeof c == "string") return c }return null } function B(u) { var c = u, g = u; if (u.alternate) for (; c.return;)c = c.return; else { u = c; do c = u, c.flags & 4098 && (g = c.return), u = c.return; while (u) } return c.tag === 3 ? g : null } function L(u) { if (B(u) !== u) throw Error(o(188)) } function U(u) { var c = u.alternate; if (!c) { if (c = B(u), c === null) throw Error(o(188)); return c !== u ? null : u } for (var g = u, M = c; ;) { var C = g.return; if (C === null) break; var b = C.alternate; if (b === null) { if (M = C.return, M !== null) { g = M; continue } break } if (C.child === b.child) { for (b = C.child; b;) { if (b === g) return L(C), u; if (b === M) return L(C), c; b = b.sibling } throw Error(o(188)) } if (g.return !== M.return) g = C, M = b; else { for (var O = !1, J = C.child; J;) { if (J === g) { O = !0, g = C, M = b; break } if (J === M) { O = !0, M = C, g = b; break } J = J.sibling } if (!O) { for (J = b.child; J;) { if (J === g) { O = !0, g = b, M = C; break } if (J === M) { O = !0, M = b, g = C; break } J = J.sibling } if (!O) throw Error(o(189)) } } if (g.alternate !== M) throw Error(o(190)) } if (g.tag !== 3) throw Error(o(188)); return g.stateNode.current === g ? u : c } function q(u) { return u = U(u), u !== null ? W(u) : null } function W(u) { if (u.tag === 5 || u.tag === 6) return u; for (u = u.child; u !== null;) { var c = W(u); if (c !== null) return c; u = u.sibling } return null } function G(u) { if (u.tag === 5 || u.tag === 6) return u; for (u = u.child; u !== null;) { if (u.tag !== 4) { var c = G(u); if (c !== null) return c } u = u.sibling } return null } var K = Array.isArray, ne = e.getPublicInstance, oe = e.getRootHostContext, N = e.getChildHostContext, V = e.prepareForCommit, Y = e.resetAfterCommit, re = e.createInstance, j = e.appendInitialChild, ie = e.finalizeInitialChildren, ve = e.prepareUpdate, Ae = e.shouldSetTextContent, $ = e.createTextInstance, Oe = e.scheduleTimeout, ke = e.cancelTimeout, He = e.noTimeout, Me = e.isPrimaryRenderer, De = e.supportsMutation, de = e.supportsPersistence, ae = e.supportsHydration, Ce = e.getInstanceFromNode, ze = e.preparePortalMount, Be = e.getCurrentEventPriority, Ze = e.detachDeletedInstance, Je = e.supportsMicrotasks, je = e.scheduleMicrotask, vt = e.supportsTestSelectors, wt = e.findFiberRoot, k = e.getBoundingRect, D = e.getTextContent, se = e.isHiddenSubtree, we = e.matchAccessibilityRole, Ee = e.setFocusIfFocusable, Pe = e.setupIntersectionObserver, tt = e.appendChild, Ie = e.appendChildToContainer, me = e.commitTextUpdate, Xe = e.commitMount, H = e.commitUpdate, le = e.insertBefore, _e = e.insertInContainerBefore, be = e.removeChild, $e = e.removeChildFromContainer, yt = e.resetTextContent, Vt = e.hideInstance, X = e.hideTextInstance, ce = e.unhideInstance, xe = e.unhideTextInstance, Ue = e.clearContainer, Ke = e.cloneInstance, Pt = e.createContainerChildSet, dn = e.appendChildToContainerChildSet, Bn = e.finalizeContainerChildren, zr = e.replaceContainerChildren, kt = e.cloneHiddenInstance, ji = e.cloneHiddenTextInstance, pi = e.canHydrateInstance, Od = e.canHydrateTextInstance, Wg = e.canHydrateSuspenseInstance, kd = e.isSuspenseInstancePending, $u = e.isSuspenseInstanceFallback, F = e.registerSuspenseInstanceRetry, ee = e.getNextHydratableSibling, he = e.getFirstHydratableChild, Z = e.getFirstHydratableChildWithinContainer, ge = e.getFirstHydratableChildWithinSuspenseInstance, qe = e.hydrateInstance, rt = e.hydrateTextInstance, ft = e.hydrateSuspenseInstance, mt = e.getNextHydratableInstanceAfterSuspenseInstance, St = e.commitHydratedContainer, At = e.commitHydratedSuspenseInstance, _t = e.clearSuspenseBoundary, on = e.clearSuspenseBoundaryFromContainer, ti = e.shouldDeleteUnhydratedTailInstances, yr = e.didNotMatchHydratedContainerTextInstance, as = e.didNotMatchHydratedTextInstance, Jt; function dt(u) {
		if (Jt === void 0) try { throw Error() } catch (g) { var c = g.stack.trim().match(/\n( *(at )?)/); Jt = c && c[1] || "" } return `
`+ Jt + u
	} var $o = !1; function an(u, c) {
		if (!u || $o) return ""; $o = !0; var g = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (c) if (c = function () { throw Error() }, Object.defineProperty(c.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(c, []) } catch (Te) { var M = Te } Reflect.construct(u, [], c) } else { try { c.call() } catch (Te) { M = Te } u.call(c.prototype) } else { try { throw Error() } catch (Te) { M = Te } u() } } catch (Te) {
			if (Te && M && typeof Te.stack == "string") {
				for (var C = Te.stack.split(`
`), b = M.stack.split(`
`), O = C.length - 1, J = b.length - 1; 1 <= O && 0 <= J && C[O] !== b[J];)J--; for (; 1 <= O && 0 <= J; O--, J--)if (C[O] !== b[J]) {
					if (O !== 1 || J !== 1) do if (O--, J--, 0 > J || C[O] !== b[J]) {
						var fe = `
`+ C[O].replace(" at new ", " at "); return u.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", u.displayName)), fe
					} while (1 <= O && 0 <= J); break
				}
			}
		} finally { $o = !1, Error.prepareStackTrace = g } return (u = u ? u.displayName || u.name : "") ? dt(u) : ""
	} var ls = Object.prototype.hasOwnProperty, dl = [], Ji = -1; function Xi(u) { return { current: u } } function ct(u) { 0 > Ji || (u.current = dl[Ji], dl[Ji] = null, Ji--) } function Et(u, c) { Ji++, dl[Ji] = u.current, u.current = c } var Yi = {}, Ft = Xi(Yi), Rn = Xi(!1), us = Yi; function cs(u, c) { var g = u.type.contextTypes; if (!g) return Yi; var M = u.stateNode; if (M && M.__reactInternalMemoizedUnmaskedChildContext === c) return M.__reactInternalMemoizedMaskedChildContext; var C = {}, b; for (b in g) C[b] = c[b]; return M && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = c, u.__reactInternalMemoizedMaskedChildContext = C), C } function mi(u) { return u = u.childContextTypes, u != null } function Ud() { ct(Rn), ct(Ft) } function rM(u, c, g) { if (Ft.current !== Yi) throw Error(o(168)); Et(Ft, c), Et(Rn, g) } function sM(u, c, g) { var M = u.stateNode; if (c = c.childContextTypes, typeof M.getChildContext != "function") return g; M = M.getChildContext(); for (var C in M) if (!(C in c)) throw Error(o(108, E(u) || "Unknown", C)); return s({}, g, M) } function zd(u) { return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || Yi, us = Ft.current, Et(Ft, u), Et(Rn, Rn.current), !0 } function oM(u, c, g) { var M = u.stateNode; if (!M) throw Error(o(169)); g ? (u = sM(u, c, us), M.__reactInternalMemoizedMergedChildContext = u, ct(Rn), ct(Ft), Et(Ft, u)) : ct(Rn), Et(Rn, g) } var vr = Math.clz32 ? Math.clz32 : hL, fL = Math.log, dL = Math.LN2; function hL(u) { return u >>>= 0, u === 0 ? 32 : 31 - (fL(u) / dL | 0) | 0 } var Gd = 64, Hd = 4194304; function ec(u) { switch (u & -u) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return u & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return u & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return u } } function Vd(u, c) { var g = u.pendingLanes; if (g === 0) return 0; var M = 0, C = u.suspendedLanes, b = u.pingedLanes, O = g & 268435455; if (O !== 0) { var J = O & ~C; J !== 0 ? M = ec(J) : (b &= O, b !== 0 && (M = ec(b))) } else O = g & ~C, O !== 0 ? M = ec(O) : b !== 0 && (M = ec(b)); if (M === 0) return 0; if (c !== 0 && c !== M && !(c & C) && (C = M & -M, b = c & -c, C >= b || C === 16 && (b & 4194240) !== 0)) return c; if (M & 4 && (M |= g & 16), c = u.entangledLanes, c !== 0) for (u = u.entanglements, c &= M; 0 < c;)g = 31 - vr(c), C = 1 << g, M |= u[g], c &= ~C; return M } function pL(u, c) { switch (u) { case 1: case 2: case 4: return c + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return c + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function mL(u, c) { for (var g = u.suspendedLanes, M = u.pingedLanes, C = u.expirationTimes, b = u.pendingLanes; 0 < b;) { var O = 31 - vr(b), J = 1 << O, fe = C[O]; fe === -1 ? (!(J & g) || J & M) && (C[O] = pL(J, c)) : fe <= c && (u.expiredLanes |= J), b &= ~J } } function jg(u) { return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0 } function Jg(u) { for (var c = [], g = 0; 31 > g; g++)c.push(u); return c } function tc(u, c, g) { u.pendingLanes |= c, c !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, c = 31 - vr(c), u[c] = g } function gL(u, c) { var g = u.pendingLanes & ~c; u.pendingLanes = c, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= c, u.mutableReadLanes &= c, u.entangledLanes &= c, c = u.entanglements; var M = u.eventTimes; for (u = u.expirationTimes; 0 < g;) { var C = 31 - vr(g), b = 1 << C; c[C] = 0, M[C] = -1, u[C] = -1, g &= ~b } } function Xg(u, c) { var g = u.entangledLanes |= c; for (u = u.entanglements; g;) { var M = 31 - vr(g), C = 1 << M; C & c | u[M] & c && (u[M] |= c), g &= ~C } } var Rt = 0; function aM(u) { return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1 } var Yg = r.unstable_scheduleCallback, lM = r.unstable_cancelCallback, yL = r.unstable_shouldYield, vL = r.unstable_requestPaint, Ln = r.unstable_now, Kg = r.unstable_ImmediatePriority, xL = r.unstable_UserBlockingPriority, Qg = r.unstable_NormalPriority, AL = r.unstable_IdlePriority, Wd = null, Gr = null; function _L(u) { if (Gr && typeof Gr.onCommitFiberRoot == "function") try { Gr.onCommitFiberRoot(Wd, u, void 0, (u.current.flags & 128) === 128) } catch { } } function ML(u, c) { return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c } var Hr = typeof Object.is == "function" ? Object.is : ML, fs = null, jd = !1, Zg = !1; function uM(u) { fs === null ? fs = [u] : fs.push(u) } function wL(u) { jd = !0, uM(u) } function Vr() { if (!Zg && fs !== null) { Zg = !0; var u = 0, c = Rt; try { var g = fs; for (Rt = 1; u < g.length; u++) { var M = g[u]; do M = M(!0); while (M !== null) } fs = null, jd = !1 } catch (C) { throw fs !== null && (fs = fs.slice(u + 1)), Yg(Kg, Vr), C } finally { Rt = c, Zg = !1 } } return null } var SL = a.ReactCurrentBatchConfig; function Jd(u, c) { if (Hr(u, c)) return !0; if (typeof u != "object" || u === null || typeof c != "object" || c === null) return !1; var g = Object.keys(u), M = Object.keys(c); if (g.length !== M.length) return !1; for (M = 0; M < g.length; M++) { var C = g[M]; if (!ls.call(c, C) || !Hr(u[C], c[C])) return !1 } return !0 } function CL(u) { switch (u.tag) { case 5: return dt(u.type); case 16: return dt("Lazy"); case 13: return dt("Suspense"); case 19: return dt("SuspenseList"); case 0: case 2: case 15: return u = an(u.type, !1), u; case 11: return u = an(u.type.render, !1), u; case 1: return u = an(u.type, !0), u; default: return "" } } function xr(u, c) { if (u && u.defaultProps) { c = s({}, c), u = u.defaultProps; for (var g in u) c[g] === void 0 && (c[g] = u[g]); return c } return c } var Xd = Xi(null), Yd = null, hl = null, qg = null; function $g() { qg = hl = Yd = null } function cM(u, c, g) { Me ? (Et(Xd, c._currentValue), c._currentValue = g) : (Et(Xd, c._currentValue2), c._currentValue2 = g) } function e0(u) { var c = Xd.current; ct(Xd), Me ? u._currentValue = c : u._currentValue2 = c } function t0(u, c, g) { for (; u !== null;) { var M = u.alternate; if ((u.childLanes & c) !== c ? (u.childLanes |= c, M !== null && (M.childLanes |= c)) : M !== null && (M.childLanes & c) !== c && (M.childLanes |= c), u === g) break; u = u.return } } function pl(u, c) { Yd = u, qg = hl = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & c && (Bi = !0), u.firstContext = null) } function Ki(u) { var c = Me ? u._currentValue : u._currentValue2; if (qg !== u) if (u = { context: u, memoizedValue: c, next: null }, hl === null) { if (Yd === null) throw Error(o(308)); hl = u, Yd.dependencies = { lanes: 0, firstContext: u } } else hl = hl.next = u; return c } var Wr = null, Ks = !1; function n0(u) { u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function fM(u, c) { u = u.updateQueue, c.updateQueue === u && (c.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects }) } function ds(u, c) { return { eventTime: u, lane: c, tag: 0, payload: null, callback: null, next: null } } function Qs(u, c) { var g = u.updateQueue; g !== null && (g = g.shared, yn !== null && u.mode & 1 && !(gt & 2) ? (u = g.interleaved, u === null ? (c.next = c, Wr === null ? Wr = [g] : Wr.push(g)) : (c.next = u.next, u.next = c), g.interleaved = c) : (u = g.pending, u === null ? c.next = c : (c.next = u.next, u.next = c), g.pending = c)) } function Kd(u, c, g) { if (c = c.updateQueue, c !== null && (c = c.shared, (g & 4194240) !== 0)) { var M = c.lanes; M &= u.pendingLanes, g |= M, c.lanes = g, Xg(u, g) } } function dM(u, c) { var g = u.updateQueue, M = u.alternate; if (M !== null && (M = M.updateQueue, g === M)) { var C = null, b = null; if (g = g.firstBaseUpdate, g !== null) { do { var O = { eventTime: g.eventTime, lane: g.lane, tag: g.tag, payload: g.payload, callback: g.callback, next: null }; b === null ? C = b = O : b = b.next = O, g = g.next } while (g !== null); b === null ? C = b = c : b = b.next = c } else C = b = c; g = { baseState: M.baseState, firstBaseUpdate: C, lastBaseUpdate: b, shared: M.shared, effects: M.effects }, u.updateQueue = g; return } u = g.lastBaseUpdate, u === null ? g.firstBaseUpdate = c : u.next = c, g.lastBaseUpdate = c } function Qd(u, c, g, M) { var C = u.updateQueue; Ks = !1; var b = C.firstBaseUpdate, O = C.lastBaseUpdate, J = C.shared.pending; if (J !== null) { C.shared.pending = null; var fe = J, Te = fe.next; fe.next = null, O === null ? b = Te : O.next = Te, O = fe; var Ve = u.alternate; Ve !== null && (Ve = Ve.updateQueue, J = Ve.lastBaseUpdate, J !== O && (J === null ? Ve.firstBaseUpdate = Te : J.next = Te, Ve.lastBaseUpdate = fe)) } if (b !== null) { var ot = C.baseState; O = 0, Ve = Te = fe = null, J = b; do { var et = J.lane, Ut = J.eventTime; if ((M & et) === et) { Ve !== null && (Ve = Ve.next = { eventTime: Ut, lane: 0, tag: J.tag, payload: J.payload, callback: J.callback, next: null }); e: { var Qe = u, Xn = J; switch (et = c, Ut = g, Xn.tag) { case 1: if (Qe = Xn.payload, typeof Qe == "function") { ot = Qe.call(Ut, ot, et); break e } ot = Qe; break e; case 3: Qe.flags = Qe.flags & -65537 | 128; case 0: if (Qe = Xn.payload, et = typeof Qe == "function" ? Qe.call(Ut, ot, et) : Qe, et == null) break e; ot = s({}, ot, et); break e; case 2: Ks = !0 } } J.callback !== null && J.lane !== 0 && (u.flags |= 64, et = C.effects, et === null ? C.effects = [J] : et.push(J)) } else Ut = { eventTime: Ut, lane: et, tag: J.tag, payload: J.payload, callback: J.callback, next: null }, Ve === null ? (Te = Ve = Ut, fe = ot) : Ve = Ve.next = Ut, O |= et; if (J = J.next, J === null) { if (J = C.shared.pending, J === null) break; et = J, J = et.next, et.next = null, C.lastBaseUpdate = et, C.shared.pending = null } } while (1); if (Ve === null && (fe = ot), C.baseState = fe, C.firstBaseUpdate = Te, C.lastBaseUpdate = Ve, c = C.shared.interleaved, c !== null) { C = c; do O |= C.lane, C = C.next; while (C !== c) } else b === null && (C.shared.lanes = 0); wl |= O, u.lanes = O, u.memoizedState = ot } } function hM(u, c, g) { if (u = c.effects, c.effects = null, u !== null) for (c = 0; c < u.length; c++) { var M = u[c], C = M.callback; if (C !== null) { if (M.callback = null, M = g, typeof C != "function") throw Error(o(191, C)); C.call(M) } } } var pM = new i.Component().refs; function i0(u, c, g, M) { c = u.memoizedState, g = g(M, c), g = g == null ? c : s({}, c, g), u.memoizedState = g, u.lanes === 0 && (u.updateQueue.baseState = g) } var Zd = { isMounted: function (u) { return (u = u._reactInternals) ? B(u) === u : !1 }, enqueueSetState: function (u, c, g) { u = u._reactInternals; var M = ii(), C = $s(u), b = ds(M, C); b.payload = c, g != null && (b.callback = g), Qs(u, b), c = er(u, C, M), c !== null && Kd(c, u, C) }, enqueueReplaceState: function (u, c, g) { u = u._reactInternals; var M = ii(), C = $s(u), b = ds(M, C); b.tag = 1, b.payload = c, g != null && (b.callback = g), Qs(u, b), c = er(u, C, M), c !== null && Kd(c, u, C) }, enqueueForceUpdate: function (u, c) { u = u._reactInternals; var g = ii(), M = $s(u), C = ds(g, M); C.tag = 2, c != null && (C.callback = c), Qs(u, C), c = er(u, M, g), c !== null && Kd(c, u, M) } }; function mM(u, c, g, M, C, b, O) { return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(M, b, O) : c.prototype && c.prototype.isPureReactComponent ? !Jd(g, M) || !Jd(C, b) : !0 } function gM(u, c, g) { var M = !1, C = Yi, b = c.contextType; return typeof b == "object" && b !== null ? b = Ki(b) : (C = mi(c) ? us : Ft.current, M = c.contextTypes, b = (M = M != null) ? cs(u, C) : Yi), c = new c(g, b), u.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, c.updater = Zd, u.stateNode = c, c._reactInternals = u, M && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = C, u.__reactInternalMemoizedMaskedChildContext = b), c } function yM(u, c, g, M) { u = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(g, M), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(g, M), c.state !== u && Zd.enqueueReplaceState(c, c.state, null) } function r0(u, c, g, M) { var C = u.stateNode; C.props = g, C.state = u.memoizedState, C.refs = pM, n0(u); var b = c.contextType; typeof b == "object" && b !== null ? C.context = Ki(b) : (b = mi(c) ? us : Ft.current, C.context = cs(u, b)), C.state = u.memoizedState, b = c.getDerivedStateFromProps, typeof b == "function" && (i0(u, c, b, g), C.state = u.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (c = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), c !== C.state && Zd.enqueueReplaceState(C, C.state, null), Qd(u, g, C, M), C.state = u.memoizedState), typeof C.componentDidMount == "function" && (u.flags |= 4194308) } var ml = [], gl = 0, qd = null, $d = 0, Qi = [], Zi = 0, ea = null, hs = 1, ps = ""; function ta(u, c) { ml[gl++] = $d, ml[gl++] = qd, qd = u, $d = c } function vM(u, c, g) { Qi[Zi++] = hs, Qi[Zi++] = ps, Qi[Zi++] = ea, ea = u; var M = hs; u = ps; var C = 32 - vr(M) - 1; M &= ~(1 << C), g += 1; var b = 32 - vr(c) + C; if (30 < b) { var O = C - C % 5; b = (M & (1 << O) - 1).toString(32), M >>= O, C -= O, hs = 1 << 32 - vr(c) + C | g << C | M, ps = b + u } else hs = 1 << b | g << C | M, ps = u } function s0(u) { u.return !== null && (ta(u, 1), vM(u, 1, 0)) } function o0(u) { for (; u === qd;)qd = ml[--gl], ml[gl] = null, $d = ml[--gl], ml[gl] = null; for (; u === ea;)ea = Qi[--Zi], Qi[Zi] = null, ps = Qi[--Zi], Qi[Zi] = null, hs = Qi[--Zi], Qi[Zi] = null } var bi = null, Pi = null, Xt = !1, nc = !1, Ar = null; function xM(u, c) { var g = tr(5, null, null, 0); g.elementType = "DELETED", g.stateNode = c, g.return = u, c = u.deletions, c === null ? (u.deletions = [g], u.flags |= 16) : c.push(g) } function AM(u, c) { switch (u.tag) { case 5: return c = pi(c, u.type, u.pendingProps), c !== null ? (u.stateNode = c, bi = u, Pi = he(c), !0) : !1; case 6: return c = Od(c, u.pendingProps), c !== null ? (u.stateNode = c, bi = u, Pi = null, !0) : !1; case 13: if (c = Wg(c), c !== null) { var g = ea !== null ? { id: hs, overflow: ps } : null; return u.memoizedState = { dehydrated: c, treeContext: g, retryLane: 1073741824 }, g = tr(18, null, null, 0), g.stateNode = c, g.return = u, u.child = g, bi = u, Pi = null, !0 } return !1; default: return !1 } } function a0(u) { return (u.mode & 1) !== 0 && (u.flags & 128) === 0 } function l0(u) { if (Xt) { var c = Pi; if (c) { var g = c; if (!AM(u, c)) { if (a0(u)) throw Error(o(418)); c = ee(g); var M = bi; c && AM(u, c) ? xM(M, g) : (u.flags = u.flags & -4097 | 2, Xt = !1, bi = u) } } else { if (a0(u)) throw Error(o(418)); u.flags = u.flags & -4097 | 2, Xt = !1, bi = u } } } function _M(u) { for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13;)u = u.return; bi = u } function ic(u) { if (!ae || u !== bi) return !1; if (!Xt) return _M(u), Xt = !0, !1; if (u.tag !== 3 && (u.tag !== 5 || ti(u.type) && !Ae(u.type, u.memoizedProps))) { var c = Pi; if (c) { if (a0(u)) { for (u = Pi; u;)u = ee(u); throw Error(o(418)) } for (; c;)xM(u, c), c = ee(c) } } if (_M(u), u.tag === 13) { if (!ae) throw Error(o(316)); if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317)); Pi = mt(u) } else Pi = bi ? ee(u.stateNode) : null; return !0 } function yl() { ae && (Pi = bi = null, nc = Xt = !1) } function u0(u) { Ar === null ? Ar = [u] : Ar.push(u) } function rc(u, c, g) { if (u = g.ref, u !== null && typeof u != "function" && typeof u != "object") { if (g._owner) { if (g = g._owner, g) { if (g.tag !== 1) throw Error(o(309)); var M = g.stateNode } if (!M) throw Error(o(147, u)); var C = M, b = "" + u; return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === b ? c.ref : (c = function (O) { var J = C.refs; J === pM && (J = C.refs = {}), O === null ? delete J[b] : J[b] = O }, c._stringRef = b, c) } if (typeof u != "string") throw Error(o(284)); if (!g._owner) throw Error(o(290, u)) } return u } function eh(u, c) { throw u = Object.prototype.toString.call(c), Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : u)) } function MM(u) { var c = u._init; return c(u._payload) } function wM(u) { function c(te, Q) { if (u) { var ue = te.deletions; ue === null ? (te.deletions = [Q], te.flags |= 16) : ue.push(Q) } } function g(te, Q) { if (!u) return null; for (; Q !== null;)c(te, Q), Q = Q.sibling; return null } function M(te, Q) { for (te = new Map; Q !== null;)Q.key !== null ? te.set(Q.key, Q) : te.set(Q.index, Q), Q = Q.sibling; return te } function C(te, Q) { return te = to(te, Q), te.index = 0, te.sibling = null, te } function b(te, Q, ue) { return te.index = ue, u ? (ue = te.alternate, ue !== null ? (ue = ue.index, ue < Q ? (te.flags |= 2, Q) : ue) : (te.flags |= 2, Q)) : (te.flags |= 1048576, Q) } function O(te) { return u && te.alternate === null && (te.flags |= 2), te } function J(te, Q, ue, Ne) { return Q === null || Q.tag !== 6 ? (Q = J0(ue, te.mode, Ne), Q.return = te, Q) : (Q = C(Q, ue), Q.return = te, Q) } function fe(te, Q, ue, Ne) { var Ye = ue.type; return Ye === d ? Ve(te, Q, ue.props.children, Ne, ue.key) : Q !== null && (Q.elementType === Ye || typeof Ye == "object" && Ye !== null && Ye.$$typeof === w && MM(Ye) === Q.type) ? (Ne = C(Q, ue.props), Ne.ref = rc(te, Q, ue), Ne.return = te, Ne) : (Ne = Rh(ue.type, ue.key, ue.props, null, te.mode, Ne), Ne.ref = rc(te, Q, ue), Ne.return = te, Ne) } function Te(te, Q, ue, Ne) { return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== ue.containerInfo || Q.stateNode.implementation !== ue.implementation ? (Q = X0(ue, te.mode, Ne), Q.return = te, Q) : (Q = C(Q, ue.children || []), Q.return = te, Q) } function Ve(te, Q, ue, Ne, Ye) { return Q === null || Q.tag !== 7 ? (Q = la(ue, te.mode, Ne, Ye), Q.return = te, Q) : (Q = C(Q, ue), Q.return = te, Q) } function ot(te, Q, ue) { if (typeof Q == "string" && Q !== "" || typeof Q == "number") return Q = J0("" + Q, te.mode, ue), Q.return = te, Q; if (typeof Q == "object" && Q !== null) { switch (Q.$$typeof) { case l: return ue = Rh(Q.type, Q.key, Q.props, null, te.mode, ue), ue.ref = rc(te, null, Q), ue.return = te, ue; case f: return Q = X0(Q, te.mode, ue), Q.return = te, Q; case w: var Ne = Q._init; return ot(te, Ne(Q._payload), ue) }if (K(Q) || P(Q)) return Q = la(Q, te.mode, ue, null), Q.return = te, Q; eh(te, Q) } return null } function et(te, Q, ue, Ne) { var Ye = Q !== null ? Q.key : null; if (typeof ue == "string" && ue !== "" || typeof ue == "number") return Ye !== null ? null : J(te, Q, "" + ue, Ne); if (typeof ue == "object" && ue !== null) { switch (ue.$$typeof) { case l: return ue.key === Ye ? fe(te, Q, ue, Ne) : null; case f: return ue.key === Ye ? Te(te, Q, ue, Ne) : null; case w: return Ye = ue._init, et(te, Q, Ye(ue._payload), Ne) }if (K(ue) || P(ue)) return Ye !== null ? null : Ve(te, Q, ue, Ne, null); eh(te, ue) } return null } function Ut(te, Q, ue, Ne, Ye) { if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number") return te = te.get(ue) || null, J(Q, te, "" + Ne, Ye); if (typeof Ne == "object" && Ne !== null) { switch (Ne.$$typeof) { case l: return te = te.get(Ne.key === null ? ue : Ne.key) || null, fe(Q, te, Ne, Ye); case f: return te = te.get(Ne.key === null ? ue : Ne.key) || null, Te(Q, te, Ne, Ye); case w: var ht = Ne._init; return Ut(te, Q, ue, ht(Ne._payload), Ye) }if (K(Ne) || P(Ne)) return te = te.get(ue) || null, Ve(Q, te, Ne, Ye, null); eh(Q, Ne) } return null } function Qe(te, Q, ue, Ne) { for (var Ye = null, ht = null, at = Q, Lt = Q = 0, In = null; at !== null && Lt < ue.length; Lt++) { at.index > Lt ? (In = at, at = null) : In = at.sibling; var Dt = et(te, at, ue[Lt], Ne); if (Dt === null) { at === null && (at = In); break } u && at && Dt.alternate === null && c(te, at), Q = b(Dt, Q, Lt), ht === null ? Ye = Dt : ht.sibling = Dt, ht = Dt, at = In } if (Lt === ue.length) return g(te, at), Xt && ta(te, Lt), Ye; if (at === null) { for (; Lt < ue.length; Lt++)at = ot(te, ue[Lt], Ne), at !== null && (Q = b(at, Q, Lt), ht === null ? Ye = at : ht.sibling = at, ht = at); return Xt && ta(te, Lt), Ye } for (at = M(te, at); Lt < ue.length; Lt++)In = Ut(at, te, Lt, ue[Lt], Ne), In !== null && (u && In.alternate !== null && at.delete(In.key === null ? Lt : In.key), Q = b(In, Q, Lt), ht === null ? Ye = In : ht.sibling = In, ht = In); return u && at.forEach(function (no) { return c(te, no) }), Xt && ta(te, Lt), Ye } function Xn(te, Q, ue, Ne) { var Ye = P(ue); if (typeof Ye != "function") throw Error(o(150)); if (ue = Ye.call(ue), ue == null) throw Error(o(151)); for (var ht = Ye = null, at = Q, Lt = Q = 0, In = null, Dt = ue.next(); at !== null && !Dt.done; Lt++, Dt = ue.next()) { at.index > Lt ? (In = at, at = null) : In = at.sibling; var no = et(te, at, Dt.value, Ne); if (no === null) { at === null && (at = In); break } u && at && no.alternate === null && c(te, at), Q = b(no, Q, Lt), ht === null ? Ye = no : ht.sibling = no, ht = no, at = In } if (Dt.done) return g(te, at), Xt && ta(te, Lt), Ye; if (at === null) { for (; !Dt.done; Lt++, Dt = ue.next())Dt = ot(te, Dt.value, Ne), Dt !== null && (Q = b(Dt, Q, Lt), ht === null ? Ye = Dt : ht.sibling = Dt, ht = Dt); return Xt && ta(te, Lt), Ye } for (at = M(te, at); !Dt.done; Lt++, Dt = ue.next())Dt = Ut(at, te, Lt, Dt.value, Ne), Dt !== null && (u && Dt.alternate !== null && at.delete(Dt.key === null ? Lt : Dt.key), Q = b(Dt, Q, Lt), ht === null ? Ye = Dt : ht.sibling = Dt, ht = Dt); return u && at.forEach(function (tD) { return c(te, tD) }), Xt && ta(te, Lt), Ye } function nr(te, Q, ue, Ne) { if (typeof ue == "object" && ue !== null && ue.type === d && ue.key === null && (ue = ue.props.children), typeof ue == "object" && ue !== null) { switch (ue.$$typeof) { case l: e: { for (var Ye = ue.key, ht = Q; ht !== null;) { if (ht.key === Ye) { if (Ye = ue.type, Ye === d) { if (ht.tag === 7) { g(te, ht.sibling), Q = C(ht, ue.props.children), Q.return = te, te = Q; break e } } else if (ht.elementType === Ye || typeof Ye == "object" && Ye !== null && Ye.$$typeof === w && MM(Ye) === ht.type) { g(te, ht.sibling), Q = C(ht, ue.props), Q.ref = rc(te, ht, ue), Q.return = te, te = Q; break e } g(te, ht); break } else c(te, ht); ht = ht.sibling } ue.type === d ? (Q = la(ue.props.children, te.mode, Ne, ue.key), Q.return = te, te = Q) : (Ne = Rh(ue.type, ue.key, ue.props, null, te.mode, Ne), Ne.ref = rc(te, Q, ue), Ne.return = te, te = Ne) } return O(te); case f: e: { for (ht = ue.key; Q !== null;) { if (Q.key === ht) if (Q.tag === 4 && Q.stateNode.containerInfo === ue.containerInfo && Q.stateNode.implementation === ue.implementation) { g(te, Q.sibling), Q = C(Q, ue.children || []), Q.return = te, te = Q; break e } else { g(te, Q); break } else c(te, Q); Q = Q.sibling } Q = X0(ue, te.mode, Ne), Q.return = te, te = Q } return O(te); case w: return ht = ue._init, nr(te, Q, ht(ue._payload), Ne) }if (K(ue)) return Qe(te, Q, ue, Ne); if (P(ue)) return Xn(te, Q, ue, Ne); eh(te, ue) } return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue, Q !== null && Q.tag === 6 ? (g(te, Q.sibling), Q = C(Q, ue), Q.return = te, te = Q) : (g(te, Q), Q = J0(ue, te.mode, Ne), Q.return = te, te = Q), O(te)) : g(te, Q) } return nr } var vl = wM(!0), SM = wM(!1), sc = {}, qi = Xi(sc), oc = Xi(sc), xl = Xi(sc); function jr(u) { if (u === sc) throw Error(o(174)); return u } function c0(u, c) { Et(xl, c), Et(oc, u), Et(qi, sc), u = oe(c), ct(qi), Et(qi, u) } function Al() { ct(qi), ct(oc), ct(xl) } function CM(u) { var c = jr(xl.current), g = jr(qi.current); c = N(g, u.type, c), g !== c && (Et(oc, u), Et(qi, c)) } function f0(u) { oc.current === u && (ct(qi), ct(oc)) } var Zt = Xi(0); function th(u) { for (var c = u; c !== null;) { if (c.tag === 13) { var g = c.memoizedState; if (g !== null && (g = g.dehydrated, g === null || kd(g) || $u(g))) return c } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) { if (c.flags & 128) return c } else if (c.child !== null) { c.child.return = c, c = c.child; continue } if (c === u) break; for (; c.sibling === null;) { if (c.return === null || c.return === u) return null; c = c.return } c.sibling.return = c.return, c = c.sibling } return null } var d0 = []; function h0() { for (var u = 0; u < d0.length; u++) { var c = d0[u]; Me ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null } d0.length = 0 } var nh = a.ReactCurrentDispatcher, $i = a.ReactCurrentBatchConfig, _l = 0, ln = null, Wn = null, Dn = null, ih = !1, ac = !1, lc = 0, EL = 0; function jn() { throw Error(o(321)) } function p0(u, c) { if (c === null) return !1; for (var g = 0; g < c.length && g < u.length; g++)if (!Hr(u[g], c[g])) return !1; return !0 } function m0(u, c, g, M, C, b) { if (_l = b, ln = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, nh.current = u === null || u.memoizedState === null ? BL : RL, u = g(M, C), ac) { b = 0; do { if (ac = !1, lc = 0, 25 <= b) throw Error(o(301)); b += 1, Dn = Wn = null, c.updateQueue = null, nh.current = LL, u = g(M, C) } while (ac) } if (nh.current = lh, c = Wn !== null && Wn.next !== null, _l = 0, Dn = Wn = ln = null, ih = !1, c) throw Error(o(300)); return u } function g0() { var u = lc !== 0; return lc = 0, u } function ms() { var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Dn === null ? ln.memoizedState = Dn = u : Dn = Dn.next = u, Dn } function Jr() { if (Wn === null) { var u = ln.alternate; u = u !== null ? u.memoizedState : null } else u = Wn.next; var c = Dn === null ? ln.memoizedState : Dn.next; if (c !== null) Dn = c, Wn = u; else { if (u === null) throw Error(o(310)); Wn = u, u = { memoizedState: Wn.memoizedState, baseState: Wn.baseState, baseQueue: Wn.baseQueue, queue: Wn.queue, next: null }, Dn === null ? ln.memoizedState = Dn = u : Dn = Dn.next = u } return Dn } function na(u, c) { return typeof c == "function" ? c(u) : c } function rh(u) { var c = Jr(), g = c.queue; if (g === null) throw Error(o(311)); g.lastRenderedReducer = u; var M = Wn, C = M.baseQueue, b = g.pending; if (b !== null) { if (C !== null) { var O = C.next; C.next = b.next, b.next = O } M.baseQueue = C = b, g.pending = null } if (C !== null) { b = C.next, M = M.baseState; var J = O = null, fe = null, Te = b; do { var Ve = Te.lane; if ((_l & Ve) === Ve) fe !== null && (fe = fe.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), M = Te.hasEagerState ? Te.eagerState : u(M, Te.action); else { var ot = { lane: Ve, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }; fe === null ? (J = fe = ot, O = M) : fe = fe.next = ot, ln.lanes |= Ve, wl |= Ve } Te = Te.next } while (Te !== null && Te !== b); fe === null ? O = M : fe.next = J, Hr(M, c.memoizedState) || (Bi = !0), c.memoizedState = M, c.baseState = O, c.baseQueue = fe, g.lastRenderedState = M } if (u = g.interleaved, u !== null) { C = u; do b = C.lane, ln.lanes |= b, wl |= b, C = C.next; while (C !== u) } else C === null && (g.lanes = 0); return [c.memoizedState, g.dispatch] } function sh(u) { var c = Jr(), g = c.queue; if (g === null) throw Error(o(311)); g.lastRenderedReducer = u; var M = g.dispatch, C = g.pending, b = c.memoizedState; if (C !== null) { g.pending = null; var O = C = C.next; do b = u(b, O.action), O = O.next; while (O !== C); Hr(b, c.memoizedState) || (Bi = !0), c.memoizedState = b, c.baseQueue === null && (c.baseState = b), g.lastRenderedState = b } return [b, M] } function EM() { } function TM(u, c) { var g = ln, M = Jr(), C = c(), b = !Hr(M.memoizedState, C); if (b && (M.memoizedState = C, Bi = !0), M = M.queue, cc(BM.bind(null, g, M, u), [u]), M.getSnapshot !== c || b || Dn !== null && Dn.memoizedState.tag & 1) { if (g.flags |= 2048, uc(9, PM.bind(null, g, M, C, c), void 0, null), yn === null) throw Error(o(349)); _l & 30 || bM(g, c, C) } return C } function bM(u, c, g) { u.flags |= 16384, u = { getSnapshot: c, value: g }, c = ln.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, ln.updateQueue = c, c.stores = [u]) : (g = c.stores, g === null ? c.stores = [u] : g.push(u)) } function PM(u, c, g, M) { c.value = g, c.getSnapshot = M, RM(c) && er(u, 1, -1) } function BM(u, c, g) { return g(function () { RM(c) && er(u, 1, -1) }) } function RM(u) { var c = u.getSnapshot; u = u.value; try { var g = c(); return !Hr(u, g) } catch { return !0 } } function y0(u) { var c = ms(); return typeof u == "function" && (u = u()), c.memoizedState = c.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: na, lastRenderedState: u }, c.queue = u, u = u.dispatch = PL.bind(null, ln, u), [c.memoizedState, u] } function uc(u, c, g, M) { return u = { tag: u, create: c, destroy: g, deps: M, next: null }, c = ln.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, ln.updateQueue = c, c.lastEffect = u.next = u) : (g = c.lastEffect, g === null ? c.lastEffect = u.next = u : (M = g.next, g.next = u, u.next = M, c.lastEffect = u)), u } function LM() { return Jr().memoizedState } function oh(u, c, g, M) { var C = ms(); ln.flags |= u, C.memoizedState = uc(1 | c, g, void 0, M === void 0 ? null : M) } function ah(u, c, g, M) { var C = Jr(); M = M === void 0 ? null : M; var b = void 0; if (Wn !== null) { var O = Wn.memoizedState; if (b = O.destroy, M !== null && p0(M, O.deps)) { C.memoizedState = uc(c, g, b, M); return } } ln.flags |= u, C.memoizedState = uc(1 | c, g, b, M) } function v0(u, c) { return oh(8390656, 8, u, c) } function cc(u, c) { return ah(2048, 8, u, c) } function DM(u, c) { return ah(4, 2, u, c) } function IM(u, c) { return ah(4, 4, u, c) } function FM(u, c) { if (typeof c == "function") return u = u(), c(u), function () { c(null) }; if (c != null) return u = u(), c.current = u, function () { c.current = null } } function NM(u, c, g) { return g = g != null ? g.concat([u]) : null, ah(4, 4, FM.bind(null, c, u), g) } function x0() { } function OM(u, c) { var g = Jr(); c = c === void 0 ? null : c; var M = g.memoizedState; return M !== null && c !== null && p0(c, M[1]) ? M[0] : (g.memoizedState = [u, c], u) } function kM(u, c) { var g = Jr(); c = c === void 0 ? null : c; var M = g.memoizedState; return M !== null && c !== null && p0(c, M[1]) ? M[0] : (u = u(), g.memoizedState = [u, c], u) } function TL(u, c) { var g = Rt; Rt = g !== 0 && 4 > g ? g : 4, u(!0); var M = $i.transition; $i.transition = {}; try { u(!1), c() } finally { Rt = g, $i.transition = M } } function UM() { return Jr().memoizedState } function bL(u, c, g) { var M = $s(u); g = { lane: M, action: g, hasEagerState: !1, eagerState: null, next: null }, zM(u) ? GM(c, g) : (HM(u, c, g), g = ii(), u = er(u, M, g), u !== null && VM(u, c, M)) } function PL(u, c, g) { var M = $s(u), C = { lane: M, action: g, hasEagerState: !1, eagerState: null, next: null }; if (zM(u)) GM(c, C); else { HM(u, c, C); var b = u.alternate; if (u.lanes === 0 && (b === null || b.lanes === 0) && (b = c.lastRenderedReducer, b !== null)) try { var O = c.lastRenderedState, J = b(O, g); if (C.hasEagerState = !0, C.eagerState = J, Hr(J, O)) return } catch { } finally { } g = ii(), u = er(u, M, g), u !== null && VM(u, c, M) } } function zM(u) { var c = u.alternate; return u === ln || c !== null && c === ln } function GM(u, c) { ac = ih = !0; var g = u.pending; g === null ? c.next = c : (c.next = g.next, g.next = c), u.pending = c } function HM(u, c, g) { yn !== null && u.mode & 1 && !(gt & 2) ? (u = c.interleaved, u === null ? (g.next = g, Wr === null ? Wr = [c] : Wr.push(c)) : (g.next = u.next, u.next = g), c.interleaved = g) : (u = c.pending, u === null ? g.next = g : (g.next = u.next, u.next = g), c.pending = g) } function VM(u, c, g) { if (g & 4194240) { var M = c.lanes; M &= u.pendingLanes, g |= M, c.lanes = g, Xg(u, g) } } var lh = { readContext: Ki, useCallback: jn, useContext: jn, useEffect: jn, useImperativeHandle: jn, useInsertionEffect: jn, useLayoutEffect: jn, useMemo: jn, useReducer: jn, useRef: jn, useState: jn, useDebugValue: jn, useDeferredValue: jn, useTransition: jn, useMutableSource: jn, useSyncExternalStore: jn, useId: jn, unstable_isNewReconciler: !1 }, BL = { readContext: Ki, useCallback: function (u, c) { return ms().memoizedState = [u, c === void 0 ? null : c], u }, useContext: Ki, useEffect: v0, useImperativeHandle: function (u, c, g) { return g = g != null ? g.concat([u]) : null, oh(4194308, 4, FM.bind(null, c, u), g) }, useLayoutEffect: function (u, c) { return oh(4194308, 4, u, c) }, useInsertionEffect: function (u, c) { return oh(4, 2, u, c) }, useMemo: function (u, c) { var g = ms(); return c = c === void 0 ? null : c, u = u(), g.memoizedState = [u, c], u }, useReducer: function (u, c, g) { var M = ms(); return c = g !== void 0 ? g(c) : c, M.memoizedState = M.baseState = c, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: c }, M.queue = u, u = u.dispatch = bL.bind(null, ln, u), [M.memoizedState, u] }, useRef: function (u) { var c = ms(); return u = { current: u }, c.memoizedState = u }, useState: y0, useDebugValue: x0, useDeferredValue: function (u) { var c = y0(u), g = c[0], M = c[1]; return v0(function () { var C = $i.transition; $i.transition = {}; try { M(u) } finally { $i.transition = C } }, [u]), g }, useTransition: function () { var u = y0(!1), c = u[0]; return u = TL.bind(null, u[1]), ms().memoizedState = u, [c, u] }, useMutableSource: function () { }, useSyncExternalStore: function (u, c, g) { var M = ln, C = ms(); if (Xt) { if (g === void 0) throw Error(o(407)); g = g() } else { if (g = c(), yn === null) throw Error(o(349)); _l & 30 || bM(M, c, g) } C.memoizedState = g; var b = { value: g, getSnapshot: c }; return C.queue = b, v0(BM.bind(null, M, b, u), [u]), M.flags |= 2048, uc(9, PM.bind(null, M, b, g, c), void 0, null), g }, useId: function () { var u = ms(), c = yn.identifierPrefix; if (Xt) { var g = ps, M = hs; g = (M & ~(1 << 32 - vr(M) - 1)).toString(32) + g, c = ":" + c + "R" + g, g = lc++, 0 < g && (c += "H" + g.toString(32)), c += ":" } else g = EL++, c = ":" + c + "r" + g.toString(32) + ":"; return u.memoizedState = c }, unstable_isNewReconciler: !1 }, RL = { readContext: Ki, useCallback: OM, useContext: Ki, useEffect: cc, useImperativeHandle: NM, useInsertionEffect: DM, useLayoutEffect: IM, useMemo: kM, useReducer: rh, useRef: LM, useState: function () { return rh(na) }, useDebugValue: x0, useDeferredValue: function (u) { var c = rh(na), g = c[0], M = c[1]; return cc(function () { var C = $i.transition; $i.transition = {}; try { M(u) } finally { $i.transition = C } }, [u]), g }, useTransition: function () { var u = rh(na)[0], c = Jr().memoizedState; return [u, c] }, useMutableSource: EM, useSyncExternalStore: TM, useId: UM, unstable_isNewReconciler: !1 }, LL = { readContext: Ki, useCallback: OM, useContext: Ki, useEffect: cc, useImperativeHandle: NM, useInsertionEffect: DM, useLayoutEffect: IM, useMemo: kM, useReducer: sh, useRef: LM, useState: function () { return sh(na) }, useDebugValue: x0, useDeferredValue: function (u) { var c = sh(na), g = c[0], M = c[1]; return cc(function () { var C = $i.transition; $i.transition = {}; try { M(u) } finally { $i.transition = C } }, [u]), g }, useTransition: function () { var u = sh(na)[0], c = Jr().memoizedState; return [u, c] }, useMutableSource: EM, useSyncExternalStore: TM, useId: UM, unstable_isNewReconciler: !1 }; function A0(u, c) {
		try { var g = "", M = c; do g += CL(M), M = M.return; while (M); var C = g } catch (b) {
			C = `
Error generating stack: `+ b.message + `
`+ b.stack
		} return { value: u, source: c, stack: C }
	} function _0(u, c) { try { console.error(c.value) } catch (g) { setTimeout(function () { throw g }) } } var DL = typeof WeakMap == "function" ? WeakMap : Map; function WM(u, c, g) { g = ds(-1, g), g.tag = 3, g.payload = { element: null }; var M = c.value; return g.callback = function () { Sh || (Sh = !0, U0 = M), _0(u, c) }, g } function jM(u, c, g) { g = ds(-1, g), g.tag = 3; var M = u.type.getDerivedStateFromError; if (typeof M == "function") { var C = c.value; g.payload = function () { return M(C) }, g.callback = function () { _0(u, c) } } var b = u.stateNode; return b !== null && typeof b.componentDidCatch == "function" && (g.callback = function () { _0(u, c), typeof M != "function" && (Zs === null ? Zs = new Set([this]) : Zs.add(this)); var O = c.stack; this.componentDidCatch(c.value, { componentStack: O !== null ? O : "" }) }), g } function JM(u, c, g) { var M = u.pingCache; if (M === null) { M = u.pingCache = new DL; var C = new Set; M.set(c, C) } else C = M.get(c), C === void 0 && (C = new Set, M.set(c, C)); C.has(g) || (C.add(g), u = XL.bind(null, u, c, g), c.then(u, u)) } function XM(u) { do { var c; if ((c = u.tag === 13) && (c = u.memoizedState, c = c !== null ? c.dehydrated !== null : !0), c) return u; u = u.return } while (u !== null); return null } function YM(u, c, g, M, C) { return u.mode & 1 ? (u.flags |= 65536, u.lanes = C, u) : (u === c ? u.flags |= 65536 : (u.flags |= 128, g.flags |= 131072, g.flags &= -52805, g.tag === 1 && (g.alternate === null ? g.tag = 17 : (c = ds(-1, 1), c.tag = 2, Qs(g, c))), g.lanes |= 1), u) } function Xr(u) { u.flags |= 4 } function KM(u, c) { if (u !== null && u.child === c.child) return !0; if (c.flags & 16) return !1; for (u = c.child; u !== null;) { if (u.flags & 12854 || u.subtreeFlags & 12854) return !1; u = u.sibling } return !0 } var fc, dc, uh, ch; if (De) fc = function (u, c) { for (var g = c.child; g !== null;) { if (g.tag === 5 || g.tag === 6) j(u, g.stateNode); else if (g.tag !== 4 && g.child !== null) { g.child.return = g, g = g.child; continue } if (g === c) break; for (; g.sibling === null;) { if (g.return === null || g.return === c) return; g = g.return } g.sibling.return = g.return, g = g.sibling } }, dc = function () { }, uh = function (u, c, g, M, C) { if (u = u.memoizedProps, u !== M) { var b = c.stateNode, O = jr(qi.current); g = ve(b, g, u, M, C, O), (c.updateQueue = g) && Xr(c) } }, ch = function (u, c, g, M) { g !== M && Xr(c) }; else if (de) { fc = function (u, c, g, M) { for (var C = c.child; C !== null;) { if (C.tag === 5) { var b = C.stateNode; g && M && (b = kt(b, C.type, C.memoizedProps, C)), j(u, b) } else if (C.tag === 6) b = C.stateNode, g && M && (b = ji(b, C.memoizedProps, C)), j(u, b); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) b = C.child, b !== null && (b.return = C), fc(u, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === c) break; for (; C.sibling === null;) { if (C.return === null || C.return === c) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; var QM = function (u, c, g, M) { for (var C = c.child; C !== null;) { if (C.tag === 5) { var b = C.stateNode; g && M && (b = kt(b, C.type, C.memoizedProps, C)), dn(u, b) } else if (C.tag === 6) b = C.stateNode, g && M && (b = ji(b, C.memoizedProps, C)), dn(u, b); else if (C.tag !== 4) { if (C.tag === 22 && C.memoizedState !== null) b = C.child, b !== null && (b.return = C), QM(u, C, !0, !0); else if (C.child !== null) { C.child.return = C, C = C.child; continue } } if (C === c) break; for (; C.sibling === null;) { if (C.return === null || C.return === c) return; C = C.return } C.sibling.return = C.return, C = C.sibling } }; dc = function (u, c) { var g = c.stateNode; if (!KM(u, c)) { u = g.containerInfo; var M = Pt(u); QM(M, c, !1, !1), g.pendingChildren = M, Xr(c), Bn(u, M) } }, uh = function (u, c, g, M, C) { var b = u.stateNode, O = u.memoizedProps; if ((u = KM(u, c)) && O === M) c.stateNode = b; else { var J = c.stateNode, fe = jr(qi.current), Te = null; O !== M && (Te = ve(J, g, O, M, C, fe)), u && Te === null ? c.stateNode = b : (b = Ke(b, Te, g, O, M, c, u, J), ie(b, g, M, C, fe) && Xr(c), c.stateNode = b, u ? Xr(c) : fc(b, c, !1, !1)) } }, ch = function (u, c, g, M) { g !== M ? (u = jr(xl.current), g = jr(qi.current), c.stateNode = $(M, u, g, c), Xr(c)) : c.stateNode = u.stateNode } } else dc = function () { }, uh = function () { }, ch = function () { }; function hc(u, c) { if (!Xt) switch (u.tailMode) { case "hidden": c = u.tail; for (var g = null; c !== null;)c.alternate !== null && (g = c), c = c.sibling; g === null ? u.tail = null : g.sibling = null; break; case "collapsed": g = u.tail; for (var M = null; g !== null;)g.alternate !== null && (M = g), g = g.sibling; M === null ? c || u.tail === null ? u.tail = null : u.tail.sibling = null : M.sibling = null } } function Jn(u) { var c = u.alternate !== null && u.alternate.child === u.child, g = 0, M = 0; if (c) for (var C = u.child; C !== null;)g |= C.lanes | C.childLanes, M |= C.subtreeFlags & 14680064, M |= C.flags & 14680064, C.return = u, C = C.sibling; else for (C = u.child; C !== null;)g |= C.lanes | C.childLanes, M |= C.subtreeFlags, M |= C.flags, C.return = u, C = C.sibling; return u.subtreeFlags |= M, u.childLanes = g, c } function IL(u, c, g) { var M = c.pendingProps; switch (o0(c), c.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Jn(c), null; case 1: return mi(c.type) && Ud(), Jn(c), null; case 3: return M = c.stateNode, Al(), ct(Rn), ct(Ft), h0(), M.pendingContext && (M.context = M.pendingContext, M.pendingContext = null), (u === null || u.child === null) && (ic(c) ? Xr(c) : u === null || u.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024, Ar !== null && (H0(Ar), Ar = null))), dc(u, c), Jn(c), null; case 5: f0(c), g = jr(xl.current); var C = c.type; if (u !== null && c.stateNode != null) uh(u, c, C, M, g), u.ref !== c.ref && (c.flags |= 512, c.flags |= 2097152); else { if (!M) { if (c.stateNode === null) throw Error(o(166)); return Jn(c), null } if (u = jr(qi.current), ic(c)) { if (!ae) throw Error(o(175)); u = qe(c.stateNode, c.type, c.memoizedProps, g, u, c, !nc), c.updateQueue = u, u !== null && Xr(c) } else { var b = re(C, M, g, u, c); fc(b, c, !1, !1), c.stateNode = b, ie(b, C, M, g, u) && Xr(c) } c.ref !== null && (c.flags |= 512, c.flags |= 2097152) } return Jn(c), null; case 6: if (u && c.stateNode != null) ch(u, c, u.memoizedProps, M); else { if (typeof M != "string" && c.stateNode === null) throw Error(o(166)); if (u = jr(xl.current), g = jr(qi.current), ic(c)) { if (!ae) throw Error(o(176)); if (u = c.stateNode, M = c.memoizedProps, (g = rt(u, M, c, !nc)) && (C = bi, C !== null)) switch (b = (C.mode & 1) !== 0, C.tag) { case 3: yr(C.stateNode.containerInfo, u, M, b); break; case 5: as(C.type, C.memoizedProps, C.stateNode, u, M, b) }g && Xr(c) } else c.stateNode = $(M, u, g, c) } return Jn(c), null; case 13: if (ct(Zt), M = c.memoizedState, Xt && Pi !== null && c.mode & 1 && !(c.flags & 128)) { for (u = Pi; u;)u = ee(u); return yl(), c.flags |= 98560, c } if (M !== null && M.dehydrated !== null) { if (M = ic(c), u === null) { if (!M) throw Error(o(318)); if (!ae) throw Error(o(344)); if (u = c.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317)); ft(u, c) } else yl(), !(c.flags & 128) && (c.memoizedState = null), c.flags |= 4; return Jn(c), null } return Ar !== null && (H0(Ar), Ar = null), c.flags & 128 ? (c.lanes = g, c) : (M = M !== null, g = !1, u === null ? ic(c) : g = u.memoizedState !== null, M && !g && (c.child.flags |= 8192, c.mode & 1 && (u === null || Zt.current & 1 ? wn === 0 && (wn = 3) : W0())), c.updateQueue !== null && (c.flags |= 4), Jn(c), null); case 4: return Al(), dc(u, c), u === null && ze(c.stateNode.containerInfo), Jn(c), null; case 10: return e0(c.type._context), Jn(c), null; case 17: return mi(c.type) && Ud(), Jn(c), null; case 19: if (ct(Zt), C = c.memoizedState, C === null) return Jn(c), null; if (M = (c.flags & 128) !== 0, b = C.rendering, b === null) if (M) hc(C, !1); else { if (wn !== 0 || u !== null && u.flags & 128) for (u = c.child; u !== null;) { if (b = th(u), b !== null) { for (c.flags |= 128, hc(C, !1), u = b.updateQueue, u !== null && (c.updateQueue = u, c.flags |= 4), c.subtreeFlags = 0, u = g, M = c.child; M !== null;)g = M, C = u, g.flags &= 14680066, b = g.alternate, b === null ? (g.childLanes = 0, g.lanes = C, g.child = null, g.subtreeFlags = 0, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null) : (g.childLanes = b.childLanes, g.lanes = b.lanes, g.child = b.child, g.subtreeFlags = 0, g.deletions = null, g.memoizedProps = b.memoizedProps, g.memoizedState = b.memoizedState, g.updateQueue = b.updateQueue, g.type = b.type, C = b.dependencies, g.dependencies = C === null ? null : { lanes: C.lanes, firstContext: C.firstContext }), M = M.sibling; return Et(Zt, Zt.current & 1 | 2), c.child } u = u.sibling } C.tail !== null && Ln() > k0 && (c.flags |= 128, M = !0, hc(C, !1), c.lanes = 4194304) } else { if (!M) if (u = th(b), u !== null) { if (c.flags |= 128, M = !0, u = u.updateQueue, u !== null && (c.updateQueue = u, c.flags |= 4), hc(C, !0), C.tail === null && C.tailMode === "hidden" && !b.alternate && !Xt) return Jn(c), null } else 2 * Ln() - C.renderingStartTime > k0 && g !== 1073741824 && (c.flags |= 128, M = !0, hc(C, !1), c.lanes = 4194304); C.isBackwards ? (b.sibling = c.child, c.child = b) : (u = C.last, u !== null ? u.sibling = b : c.child = b, C.last = b) } return C.tail !== null ? (c = C.tail, C.rendering = c, C.tail = c.sibling, C.renderingStartTime = Ln(), c.sibling = null, u = Zt.current, Et(Zt, M ? u & 1 | 2 : u & 1), c) : (Jn(c), null); case 22: case 23: return V0(), M = c.memoizedState !== null, u !== null && u.memoizedState !== null !== M && (c.flags |= 8192), M && c.mode & 1 ? Ri & 1073741824 && (Jn(c), De && c.subtreeFlags & 6 && (c.flags |= 8192)) : Jn(c), null; case 24: return null; case 25: return null }throw Error(o(156, c.tag)) } var FL = a.ReactCurrentOwner, Bi = !1; function ni(u, c, g, M) { c.child = u === null ? SM(c, null, g, M) : vl(c, u.child, g, M) } function ZM(u, c, g, M, C) { g = g.render; var b = c.ref; return pl(c, C), M = m0(u, c, g, M, b, C), g = g0(), u !== null && !Bi ? (c.updateQueue = u.updateQueue, c.flags &= -2053, u.lanes &= ~C, gs(u, c, C)) : (Xt && g && s0(c), c.flags |= 1, ni(u, c, M, C), c.child) } function qM(u, c, g, M, C) { if (u === null) { var b = g.type; return typeof b == "function" && !j0(b) && b.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (c.tag = 15, c.type = b, $M(u, c, b, M, C)) : (u = Rh(g.type, null, M, c, c.mode, C), u.ref = c.ref, u.return = c, c.child = u) } if (b = u.child, !(u.lanes & C)) { var O = b.memoizedProps; if (g = g.compare, g = g !== null ? g : Jd, g(O, M) && u.ref === c.ref) return gs(u, c, C) } return c.flags |= 1, u = to(b, M), u.ref = c.ref, u.return = c, c.child = u } function $M(u, c, g, M, C) { if (u !== null && Jd(u.memoizedProps, M) && u.ref === c.ref) if (Bi = !1, (u.lanes & C) !== 0) u.flags & 131072 && (Bi = !0); else return c.lanes = u.lanes, gs(u, c, C); return M0(u, c, g, M, C) } function ew(u, c, g) { var M = c.pendingProps, C = M.children, b = u !== null ? u.memoizedState : null; if (M.mode === "hidden") if (!(c.mode & 1)) c.memoizedState = { baseLanes: 0, cachePool: null }, Et(Ml, Ri), Ri |= g; else if (g & 1073741824) c.memoizedState = { baseLanes: 0, cachePool: null }, M = b !== null ? b.baseLanes : g, Et(Ml, Ri), Ri |= M; else return u = b !== null ? b.baseLanes | g : g, c.lanes = c.childLanes = 1073741824, c.memoizedState = { baseLanes: u, cachePool: null }, c.updateQueue = null, Et(Ml, Ri), Ri |= u, null; else b !== null ? (M = b.baseLanes | g, c.memoizedState = null) : M = g, Et(Ml, Ri), Ri |= M; return ni(u, c, C, g), c.child } function tw(u, c) { var g = c.ref; (u === null && g !== null || u !== null && u.ref !== g) && (c.flags |= 512, c.flags |= 2097152) } function M0(u, c, g, M, C) { var b = mi(g) ? us : Ft.current; return b = cs(c, b), pl(c, C), g = m0(u, c, g, M, b, C), M = g0(), u !== null && !Bi ? (c.updateQueue = u.updateQueue, c.flags &= -2053, u.lanes &= ~C, gs(u, c, C)) : (Xt && M && s0(c), c.flags |= 1, ni(u, c, g, C), c.child) } function nw(u, c, g, M, C) { if (mi(g)) { var b = !0; zd(c) } else b = !1; if (pl(c, C), c.stateNode === null) u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), gM(c, g, M), r0(c, g, M, C), M = !0; else if (u === null) { var O = c.stateNode, J = c.memoizedProps; O.props = J; var fe = O.context, Te = g.contextType; typeof Te == "object" && Te !== null ? Te = Ki(Te) : (Te = mi(g) ? us : Ft.current, Te = cs(c, Te)); var Ve = g.getDerivedStateFromProps, ot = typeof Ve == "function" || typeof O.getSnapshotBeforeUpdate == "function"; ot || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (J !== M || fe !== Te) && yM(c, O, M, Te), Ks = !1; var et = c.memoizedState; O.state = et, Qd(c, M, O, C), fe = c.memoizedState, J !== M || et !== fe || Rn.current || Ks ? (typeof Ve == "function" && (i0(c, g, Ve, M), fe = c.memoizedState), (J = Ks || mM(c, g, J, M, et, fe, Te)) ? (ot || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount()), typeof O.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof O.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = M, c.memoizedState = fe), O.props = M, O.state = fe, O.context = Te, M = J) : (typeof O.componentDidMount == "function" && (c.flags |= 4194308), M = !1) } else { O = c.stateNode, fM(u, c), J = c.memoizedProps, Te = c.type === c.elementType ? J : xr(c.type, J), O.props = Te, ot = c.pendingProps, et = O.context, fe = g.contextType, typeof fe == "object" && fe !== null ? fe = Ki(fe) : (fe = mi(g) ? us : Ft.current, fe = cs(c, fe)); var Ut = g.getDerivedStateFromProps; (Ve = typeof Ut == "function" || typeof O.getSnapshotBeforeUpdate == "function") || typeof O.UNSAFE_componentWillReceiveProps != "function" && typeof O.componentWillReceiveProps != "function" || (J !== ot || et !== fe) && yM(c, O, M, fe), Ks = !1, et = c.memoizedState, O.state = et, Qd(c, M, O, C); var Qe = c.memoizedState; J !== ot || et !== Qe || Rn.current || Ks ? (typeof Ut == "function" && (i0(c, g, Ut, M), Qe = c.memoizedState), (Te = Ks || mM(c, g, Te, M, et, Qe, fe) || !1) ? (Ve || typeof O.UNSAFE_componentWillUpdate != "function" && typeof O.componentWillUpdate != "function" || (typeof O.componentWillUpdate == "function" && O.componentWillUpdate(M, Qe, fe), typeof O.UNSAFE_componentWillUpdate == "function" && O.UNSAFE_componentWillUpdate(M, Qe, fe)), typeof O.componentDidUpdate == "function" && (c.flags |= 4), typeof O.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof O.componentDidUpdate != "function" || J === u.memoizedProps && et === u.memoizedState || (c.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || J === u.memoizedProps && et === u.memoizedState || (c.flags |= 1024), c.memoizedProps = M, c.memoizedState = Qe), O.props = M, O.state = Qe, O.context = fe, M = Te) : (typeof O.componentDidUpdate != "function" || J === u.memoizedProps && et === u.memoizedState || (c.flags |= 4), typeof O.getSnapshotBeforeUpdate != "function" || J === u.memoizedProps && et === u.memoizedState || (c.flags |= 1024), M = !1) } return w0(u, c, g, M, b, C) } function w0(u, c, g, M, C, b) { tw(u, c); var O = (c.flags & 128) !== 0; if (!M && !O) return C && oM(c, g, !1), gs(u, c, b); M = c.stateNode, FL.current = c; var J = O && typeof g.getDerivedStateFromError != "function" ? null : M.render(); return c.flags |= 1, u !== null && O ? (c.child = vl(c, u.child, null, b), c.child = vl(c, null, J, b)) : ni(u, c, J, b), c.memoizedState = M.state, C && oM(c, g, !0), c.child } function iw(u) { var c = u.stateNode; c.pendingContext ? rM(u, c.pendingContext, c.pendingContext !== c.context) : c.context && rM(u, c.context, !1), c0(u, c.containerInfo) } function rw(u, c, g, M, C) { return yl(), u0(C), c.flags |= 256, ni(u, c, g, M), c.child } var fh = { dehydrated: null, treeContext: null, retryLane: 0 }; function dh(u) { return { baseLanes: u, cachePool: null } } function sw(u, c, g) { var M = c.pendingProps, C = Zt.current, b = !1, O = (c.flags & 128) !== 0, J; if ((J = O) || (J = u !== null && u.memoizedState === null ? !1 : (C & 2) !== 0), J ? (b = !0, c.flags &= -129) : (u === null || u.memoizedState !== null) && (C |= 1), Et(Zt, C & 1), u === null) return l0(c), u = c.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (c.mode & 1 ? $u(u) ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1, null) : (C = M.children, u = M.fallback, b ? (M = c.mode, b = c.child, C = { mode: "hidden", children: C }, !(M & 1) && b !== null ? (b.childLanes = 0, b.pendingProps = C) : b = Lh(C, M, 0, null), u = la(u, M, g, null), b.return = c, u.return = c, b.sibling = u, c.child = b, c.child.memoizedState = dh(g), c.memoizedState = fh, u) : S0(c, C)); if (C = u.memoizedState, C !== null) { if (J = C.dehydrated, J !== null) { if (O) return c.flags & 256 ? (c.flags &= -257, hh(u, c, g, Error(o(422)))) : c.memoizedState !== null ? (c.child = u.child, c.flags |= 128, null) : (b = M.fallback, C = c.mode, M = Lh({ mode: "visible", children: M.children }, C, 0, null), b = la(b, C, g, null), b.flags |= 2, M.return = c, b.return = c, M.sibling = b, c.child = M, c.mode & 1 && vl(c, u.child, null, g), c.child.memoizedState = dh(g), c.memoizedState = fh, b); if (!(c.mode & 1)) c = hh(u, c, g, null); else if ($u(J)) c = hh(u, c, g, Error(o(419))); else if (M = (g & u.childLanes) !== 0, Bi || M) { if (M = yn, M !== null) { switch (g & -g) { case 4: b = 2; break; case 16: b = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: b = 32; break; case 536870912: b = 268435456; break; default: b = 0 }M = b & (M.suspendedLanes | g) ? 0 : b, M !== 0 && M !== C.retryLane && (C.retryLane = M, er(u, M, -1)) } W0(), c = hh(u, c, g, Error(o(421))) } else kd(J) ? (c.flags |= 128, c.child = u.child, c = YL.bind(null, u), F(J, c), c = null) : (g = C.treeContext, ae && (Pi = ge(J), bi = c, Xt = !0, Ar = null, nc = !1, g !== null && (Qi[Zi++] = hs, Qi[Zi++] = ps, Qi[Zi++] = ea, hs = g.id, ps = g.overflow, ea = c)), c = S0(c, c.pendingProps.children), c.flags |= 4096); return c } return b ? (M = aw(u, c, M.children, M.fallback, g), b = c.child, C = u.child.memoizedState, b.memoizedState = C === null ? dh(g) : { baseLanes: C.baseLanes | g, cachePool: null }, b.childLanes = u.childLanes & ~g, c.memoizedState = fh, M) : (g = ow(u, c, M.children, g), c.memoizedState = null, g) } return b ? (M = aw(u, c, M.children, M.fallback, g), b = c.child, C = u.child.memoizedState, b.memoizedState = C === null ? dh(g) : { baseLanes: C.baseLanes | g, cachePool: null }, b.childLanes = u.childLanes & ~g, c.memoizedState = fh, M) : (g = ow(u, c, M.children, g), c.memoizedState = null, g) } function S0(u, c) { return c = Lh({ mode: "visible", children: c }, u.mode, 0, null), c.return = u, u.child = c } function ow(u, c, g, M) { var C = u.child; return u = C.sibling, g = to(C, { mode: "visible", children: g }), !(c.mode & 1) && (g.lanes = M), g.return = c, g.sibling = null, u !== null && (M = c.deletions, M === null ? (c.deletions = [u], c.flags |= 16) : M.push(u)), c.child = g } function aw(u, c, g, M, C) { var b = c.mode; u = u.child; var O = u.sibling, J = { mode: "hidden", children: g }; return !(b & 1) && c.child !== u ? (g = c.child, g.childLanes = 0, g.pendingProps = J, c.deletions = null) : (g = to(u, J), g.subtreeFlags = u.subtreeFlags & 14680064), O !== null ? M = to(O, M) : (M = la(M, b, C, null), M.flags |= 2), M.return = c, g.return = c, g.sibling = M, c.child = g, M } function hh(u, c, g, M) { return M !== null && u0(M), vl(c, u.child, null, g), u = S0(c, c.pendingProps.children), u.flags |= 2, c.memoizedState = null, u } function lw(u, c, g) { u.lanes |= c; var M = u.alternate; M !== null && (M.lanes |= c), t0(u.return, c, g) } function C0(u, c, g, M, C) { var b = u.memoizedState; b === null ? u.memoizedState = { isBackwards: c, rendering: null, renderingStartTime: 0, last: M, tail: g, tailMode: C } : (b.isBackwards = c, b.rendering = null, b.renderingStartTime = 0, b.last = M, b.tail = g, b.tailMode = C) } function uw(u, c, g) { var M = c.pendingProps, C = M.revealOrder, b = M.tail; if (ni(u, c, M.children, g), M = Zt.current, M & 2) M = M & 1 | 2, c.flags |= 128; else { if (u !== null && u.flags & 128) e: for (u = c.child; u !== null;) { if (u.tag === 13) u.memoizedState !== null && lw(u, g, c); else if (u.tag === 19) lw(u, g, c); else if (u.child !== null) { u.child.return = u, u = u.child; continue } if (u === c) break e; for (; u.sibling === null;) { if (u.return === null || u.return === c) break e; u = u.return } u.sibling.return = u.return, u = u.sibling } M &= 1 } if (Et(Zt, M), !(c.mode & 1)) c.memoizedState = null; else switch (C) { case "forwards": for (g = c.child, C = null; g !== null;)u = g.alternate, u !== null && th(u) === null && (C = g), g = g.sibling; g = C, g === null ? (C = c.child, c.child = null) : (C = g.sibling, g.sibling = null), C0(c, !1, C, g, b); break; case "backwards": for (g = null, C = c.child, c.child = null; C !== null;) { if (u = C.alternate, u !== null && th(u) === null) { c.child = C; break } u = C.sibling, C.sibling = g, g = C, C = u } C0(c, !0, g, null, b); break; case "together": C0(c, !1, null, null, void 0); break; default: c.memoizedState = null }return c.child } function gs(u, c, g) { if (u !== null && (c.dependencies = u.dependencies), wl |= c.lanes, !(g & c.childLanes)) return null; if (u !== null && c.child !== u.child) throw Error(o(153)); if (c.child !== null) { for (u = c.child, g = to(u, u.pendingProps), c.child = g, g.return = c; u.sibling !== null;)u = u.sibling, g = g.sibling = to(u, u.pendingProps), g.return = c; g.sibling = null } return c.child } function NL(u, c, g) { switch (c.tag) { case 3: iw(c), yl(); break; case 5: CM(c); break; case 1: mi(c.type) && zd(c); break; case 4: c0(c, c.stateNode.containerInfo); break; case 10: cM(c, c.type._context, c.memoizedProps.value); break; case 13: var M = c.memoizedState; if (M !== null) return M.dehydrated !== null ? (Et(Zt, Zt.current & 1), c.flags |= 128, null) : g & c.child.childLanes ? sw(u, c, g) : (Et(Zt, Zt.current & 1), u = gs(u, c, g), u !== null ? u.sibling : null); Et(Zt, Zt.current & 1); break; case 19: if (M = (g & c.childLanes) !== 0, u.flags & 128) { if (M) return uw(u, c, g); c.flags |= 128 } var C = c.memoizedState; if (C !== null && (C.rendering = null, C.tail = null, C.lastEffect = null), Et(Zt, Zt.current), M) break; return null; case 22: case 23: return c.lanes = 0, ew(u, c, g) }return gs(u, c, g) } function OL(u, c) { switch (o0(c), c.tag) { case 1: return mi(c.type) && Ud(), u = c.flags, u & 65536 ? (c.flags = u & -65537 | 128, c) : null; case 3: return Al(), ct(Rn), ct(Ft), h0(), u = c.flags, u & 65536 && !(u & 128) ? (c.flags = u & -65537 | 128, c) : null; case 5: return f0(c), null; case 13: if (ct(Zt), u = c.memoizedState, u !== null && u.dehydrated !== null) { if (c.alternate === null) throw Error(o(340)); yl() } return u = c.flags, u & 65536 ? (c.flags = u & -65537 | 128, c) : null; case 19: return ct(Zt), null; case 4: return Al(), null; case 10: return e0(c.type._context), null; case 22: case 23: return V0(), null; case 24: return null; default: return null } } var ph = !1, ia = !1, kL = typeof WeakSet == "function" ? WeakSet : Set, Fe = null; function mh(u, c) { var g = u.ref; if (g !== null) if (typeof g == "function") try { g(null) } catch (M) { vi(u, c, M) } else g.current = null } function E0(u, c, g) { try { g() } catch (M) { vi(u, c, M) } } var cw = !1; function UL(u, c) { for (V(u.containerInfo), Fe = c; Fe !== null;)if (u = Fe, c = u.child, (u.subtreeFlags & 1028) !== 0 && c !== null) c.return = u, Fe = c; else for (; Fe !== null;) { u = Fe; try { var g = u.alternate; if (u.flags & 1024) switch (u.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var M = g.memoizedProps, C = g.memoizedState, b = u.stateNode, O = b.getSnapshotBeforeUpdate(u.elementType === u.type ? M : xr(u.type, M), C); b.__reactInternalSnapshotBeforeUpdate = O } break; case 3: De && Ue(u.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(o(163)) } } catch (J) { vi(u, u.return, J) } if (c = u.sibling, c !== null) { c.return = u.return, Fe = c; break } Fe = u.return } return g = cw, cw = !1, g } function ra(u, c, g) { var M = c.updateQueue; if (M = M !== null ? M.lastEffect : null, M !== null) { var C = M = M.next; do { if ((C.tag & u) === u) { var b = C.destroy; C.destroy = void 0, b !== void 0 && E0(c, g, b) } C = C.next } while (C !== M) } } function pc(u, c) { if (c = c.updateQueue, c = c !== null ? c.lastEffect : null, c !== null) { var g = c = c.next; do { if ((g.tag & u) === u) { var M = g.create; g.destroy = M() } g = g.next } while (g !== c) } } function T0(u) { var c = u.ref; if (c !== null) { var g = u.stateNode; switch (u.tag) { case 5: u = ne(g); break; default: u = g }typeof c == "function" ? c(u) : c.current = u } } function fw(u, c, g) { if (Gr && typeof Gr.onCommitFiberUnmount == "function") try { Gr.onCommitFiberUnmount(Wd, c) } catch { } switch (c.tag) { case 0: case 11: case 14: case 15: if (u = c.updateQueue, u !== null && (u = u.lastEffect, u !== null)) { var M = u = u.next; do { var C = M, b = C.destroy; C = C.tag, b !== void 0 && (C & 2 || C & 4) && E0(c, g, b), M = M.next } while (M !== u) } break; case 1: if (mh(c, g), u = c.stateNode, typeof u.componentWillUnmount == "function") try { u.props = c.memoizedProps, u.state = c.memoizedState, u.componentWillUnmount() } catch (O) { vi(c, g, O) } break; case 5: mh(c, g); break; case 4: De ? yw(u, c, g) : de && de && (c = c.stateNode.containerInfo, g = Pt(c), zr(c, g)) } } function dw(u, c, g) { for (var M = c; ;)if (fw(u, M, g), M.child === null || De && M.tag === 4) { if (M === c) break; for (; M.sibling === null;) { if (M.return === null || M.return === c) return; M = M.return } M.sibling.return = M.return, M = M.sibling } else M.child.return = M, M = M.child } function hw(u) { var c = u.alternate; c !== null && (u.alternate = null, hw(c)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (c = u.stateNode, c !== null && Ze(c)), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null } function pw(u) { return u.tag === 5 || u.tag === 3 || u.tag === 4 } function mw(u) { e: for (; ;) { for (; u.sibling === null;) { if (u.return === null || pw(u.return)) return null; u = u.return } for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18;) { if (u.flags & 2 || u.child === null || u.tag === 4) continue e; u.child.return = u, u = u.child } if (!(u.flags & 2)) return u.stateNode } } function gw(u) { if (De) { e: { for (var c = u.return; c !== null;) { if (pw(c)) break e; c = c.return } throw Error(o(160)) } var g = c; switch (g.tag) { case 5: c = g.stateNode, g.flags & 32 && (yt(c), g.flags &= -33), g = mw(u), P0(u, g, c); break; case 3: case 4: c = g.stateNode.containerInfo, g = mw(u), b0(u, g, c); break; default: throw Error(o(161)) } } } function b0(u, c, g) { var M = u.tag; if (M === 5 || M === 6) u = u.stateNode, c ? _e(g, u, c) : Ie(g, u); else if (M !== 4 && (u = u.child, u !== null)) for (b0(u, c, g), u = u.sibling; u !== null;)b0(u, c, g), u = u.sibling } function P0(u, c, g) { var M = u.tag; if (M === 5 || M === 6) u = u.stateNode, c ? le(g, u, c) : tt(g, u); else if (M !== 4 && (u = u.child, u !== null)) for (P0(u, c, g), u = u.sibling; u !== null;)P0(u, c, g), u = u.sibling } function yw(u, c, g) { for (var M = c, C = !1, b, O; ;) { if (!C) { C = M.return; e: for (; ;) { if (C === null) throw Error(o(160)); switch (b = C.stateNode, C.tag) { case 5: O = !1; break e; case 3: b = b.containerInfo, O = !0; break e; case 4: b = b.containerInfo, O = !0; break e }C = C.return } C = !0 } if (M.tag === 5 || M.tag === 6) dw(u, M, g), O ? $e(b, M.stateNode) : be(b, M.stateNode); else if (M.tag === 18) O ? on(b, M.stateNode) : _t(b, M.stateNode); else if (M.tag === 4) { if (M.child !== null) { b = M.stateNode.containerInfo, O = !0, M.child.return = M, M = M.child; continue } } else if (fw(u, M, g), M.child !== null) { M.child.return = M, M = M.child; continue } if (M === c) break; for (; M.sibling === null;) { if (M.return === null || M.return === c) return; M = M.return, M.tag === 4 && (C = !1) } M.sibling.return = M.return, M = M.sibling } } function B0(u, c) { if (De) { switch (c.tag) { case 0: case 11: case 14: case 15: ra(3, c, c.return), pc(3, c), ra(5, c, c.return); return; case 1: return; case 5: var g = c.stateNode; if (g != null) { var M = c.memoizedProps; u = u !== null ? u.memoizedProps : M; var C = c.type, b = c.updateQueue; c.updateQueue = null, b !== null && H(g, b, C, u, M, c) } return; case 6: if (c.stateNode === null) throw Error(o(162)); g = c.memoizedProps, me(c.stateNode, u !== null ? u.memoizedProps : g, g); return; case 3: ae && u !== null && u.memoizedState.isDehydrated && St(c.stateNode.containerInfo); return; case 12: return; case 13: gh(c); return; case 19: gh(c); return; case 17: return }throw Error(o(163)) } switch (c.tag) { case 0: case 11: case 14: case 15: ra(3, c, c.return), pc(3, c), ra(5, c, c.return); return; case 12: return; case 13: gh(c); return; case 19: gh(c); return; case 3: ae && u !== null && u.memoizedState.isDehydrated && St(c.stateNode.containerInfo); break; case 22: case 23: return }e: if (de) { switch (c.tag) { case 1: case 5: case 6: break e; case 3: case 4: c = c.stateNode, zr(c.containerInfo, c.pendingChildren); break e }throw Error(o(163)) } } function gh(u) { var c = u.updateQueue; if (c !== null) { u.updateQueue = null; var g = u.stateNode; g === null && (g = u.stateNode = new kL), c.forEach(function (M) { var C = KL.bind(null, u, M); g.has(M) || (g.add(M), M.then(C, C)) }) } } function zL(u, c) { for (Fe = c; Fe !== null;) { c = Fe; var g = c.deletions; if (g !== null) for (var M = 0; M < g.length; M++) { var C = g[M]; try { var b = u; De ? yw(b, C, c) : dw(b, C, c); var O = C.alternate; O !== null && (O.return = null), C.return = null } catch (Ye) { vi(C, c, Ye) } } if (g = c.child, c.subtreeFlags & 12854 && g !== null) g.return = c, Fe = g; else for (; Fe !== null;) { c = Fe; try { var J = c.flags; if (J & 32 && De && yt(c.stateNode), J & 512) { var fe = c.alternate; if (fe !== null) { var Te = fe.ref; Te !== null && (typeof Te == "function" ? Te(null) : Te.current = null) } } if (J & 8192) switch (c.tag) { case 13: if (c.memoizedState !== null) { var Ve = c.alternate; (Ve === null || Ve.memoizedState === null) && (O0 = Ln()) } break; case 22: var ot = c.memoizedState !== null, et = c.alternate, Ut = et !== null && et.memoizedState !== null; if (g = c, De) { e: if (M = g, C = ot, b = null, De) for (var Qe = M; ;) { if (Qe.tag === 5) { if (b === null) { b = Qe; var Xn = Qe.stateNode; C ? Vt(Xn) : ce(Qe.stateNode, Qe.memoizedProps) } } else if (Qe.tag === 6) { if (b === null) { var nr = Qe.stateNode; C ? X(nr) : xe(nr, Qe.memoizedProps) } } else if ((Qe.tag !== 22 && Qe.tag !== 23 || Qe.memoizedState === null || Qe === M) && Qe.child !== null) { Qe.child.return = Qe, Qe = Qe.child; continue } if (Qe === M) break; for (; Qe.sibling === null;) { if (Qe.return === null || Qe.return === M) break e; b === Qe && (b = null), Qe = Qe.return } b === Qe && (b = null), Qe.sibling.return = Qe.return, Qe = Qe.sibling } } if (ot && !Ut && g.mode & 1) { Fe = g; for (var te = g.child; te !== null;) { for (g = Fe = te; Fe !== null;) { M = Fe; var Q = M.child; switch (M.tag) { case 0: case 11: case 14: case 15: ra(4, M, M.return); break; case 1: mh(M, M.return); var ue = M.stateNode; if (typeof ue.componentWillUnmount == "function") { var Ne = M.return; try { ue.props = M.memoizedProps, ue.state = M.memoizedState, ue.componentWillUnmount() } catch (Ye) { vi(M, Ne, Ye) } } break; case 5: mh(M, M.return); break; case 22: if (M.memoizedState !== null) { Aw(g); continue } }Q !== null ? (Q.return = M, Fe = Q) : Aw(g) } te = te.sibling } } }switch (J & 4102) { case 2: gw(c), c.flags &= -3; break; case 6: gw(c), c.flags &= -3, B0(c.alternate, c); break; case 4096: c.flags &= -4097; break; case 4100: c.flags &= -4097, B0(c.alternate, c); break; case 4: B0(c.alternate, c) } } catch (Ye) { vi(c, c.return, Ye) } if (g = c.sibling, g !== null) { g.return = c.return, Fe = g; break } Fe = c.return } } } function GL(u, c, g) { Fe = u, vw(u) } function vw(u, c, g) { for (var M = (u.mode & 1) !== 0; Fe !== null;) { var C = Fe, b = C.child; if (C.tag === 22 && M) { var O = C.memoizedState !== null || ph; if (!O) { var J = C.alternate, fe = J !== null && J.memoizedState !== null || ia; J = ph; var Te = ia; if (ph = O, (ia = fe) && !Te) for (Fe = C; Fe !== null;)O = Fe, fe = O.child, O.tag === 22 && O.memoizedState !== null ? _w(C) : fe !== null ? (fe.return = O, Fe = fe) : _w(C); for (; b !== null;)Fe = b, vw(b), b = b.sibling; Fe = C, ph = J, ia = Te } xw(u) } else C.subtreeFlags & 8772 && b !== null ? (b.return = C, Fe = b) : xw(u) } } function xw(u) { for (; Fe !== null;) { var c = Fe; if (c.flags & 8772) { var g = c.alternate; try { if (c.flags & 8772) switch (c.tag) { case 0: case 11: case 15: ia || pc(5, c); break; case 1: var M = c.stateNode; if (c.flags & 4 && !ia) if (g === null) M.componentDidMount(); else { var C = c.elementType === c.type ? g.memoizedProps : xr(c.type, g.memoizedProps); M.componentDidUpdate(C, g.memoizedState, M.__reactInternalSnapshotBeforeUpdate) } var b = c.updateQueue; b !== null && hM(c, b, M); break; case 3: var O = c.updateQueue; if (O !== null) { if (g = null, c.child !== null) switch (c.child.tag) { case 5: g = ne(c.child.stateNode); break; case 1: g = c.child.stateNode }hM(c, O, g) } break; case 5: var J = c.stateNode; g === null && c.flags & 4 && Xe(J, c.type, c.memoizedProps, c); break; case 6: break; case 4: break; case 12: break; case 13: if (ae && c.memoizedState === null) { var fe = c.alternate; if (fe !== null) { var Te = fe.memoizedState; if (Te !== null) { var Ve = Te.dehydrated; Ve !== null && At(Ve) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(o(163)) }ia || c.flags & 512 && T0(c) } catch (ot) { vi(c, c.return, ot) } } if (c === u) { Fe = null; break } if (g = c.sibling, g !== null) { g.return = c.return, Fe = g; break } Fe = c.return } } function Aw(u) { for (; Fe !== null;) { var c = Fe; if (c === u) { Fe = null; break } var g = c.sibling; if (g !== null) { g.return = c.return, Fe = g; break } Fe = c.return } } function _w(u) { for (; Fe !== null;) { var c = Fe; try { switch (c.tag) { case 0: case 11: case 15: var g = c.return; try { pc(4, c) } catch (fe) { vi(c, g, fe) } break; case 1: var M = c.stateNode; if (typeof M.componentDidMount == "function") { var C = c.return; try { M.componentDidMount() } catch (fe) { vi(c, C, fe) } } var b = c.return; try { T0(c) } catch (fe) { vi(c, b, fe) } break; case 5: var O = c.return; try { T0(c) } catch (fe) { vi(c, O, fe) } } } catch (fe) { vi(c, c.return, fe) } if (c === u) { Fe = null; break } var J = c.sibling; if (J !== null) { J.return = c.return, Fe = J; break } Fe = c.return } } var yh = 0, vh = 1, xh = 2, Ah = 3, _h = 4; if (typeof Symbol == "function" && Symbol.for) { var mc = Symbol.for; yh = mc("selector.component"), vh = mc("selector.has_pseudo_class"), xh = mc("selector.role"), Ah = mc("selector.test_id"), _h = mc("selector.text") } function R0(u) { var c = Ce(u); if (c != null) { if (typeof c.memoizedProps["data-testname"] != "string") throw Error(o(364)); return c } if (u = wt(u), u === null) throw Error(o(362)); return u.stateNode.current } function L0(u, c) { switch (c.$$typeof) { case yh: if (u.type === c.value) return !0; break; case vh: e: { c = c.value, u = [u, 0]; for (var g = 0; g < u.length;) { var M = u[g++], C = u[g++], b = c[C]; if (M.tag !== 5 || !se(M)) { for (; b != null && L0(M, b);)C++, b = c[C]; if (C === c.length) { c = !0; break e } else for (M = M.child; M !== null;)u.push(M, C), M = M.sibling } } c = !1 } return c; case xh: if (u.tag === 5 && we(u.stateNode, c.value)) return !0; break; case _h: if ((u.tag === 5 || u.tag === 6) && (u = D(u), u !== null && 0 <= u.indexOf(c.value))) return !0; break; case Ah: if (u.tag === 5 && (u = u.memoizedProps["data-testname"], typeof u == "string" && u.toLowerCase() === c.value.toLowerCase())) return !0; break; default: throw Error(o(365)) }return !1 } function D0(u) { switch (u.$$typeof) { case yh: return "<" + (R(u.value) || "Unknown") + ">"; case vh: return ":has(" + (D0(u) || "") + ")"; case xh: return '[role="' + u.value + '"]'; case _h: return '"' + u.value + '"'; case Ah: return '[data-testname="' + u.value + '"]'; default: throw Error(o(365)) } } function Mw(u, c) { var g = []; u = [u, 0]; for (var M = 0; M < u.length;) { var C = u[M++], b = u[M++], O = c[b]; if (C.tag !== 5 || !se(C)) { for (; O != null && L0(C, O);)b++, O = c[b]; if (b === c.length) g.push(C); else for (C = C.child; C !== null;)u.push(C, b), C = C.sibling } } return g } function I0(u, c) { if (!vt) throw Error(o(363)); u = R0(u), u = Mw(u, c), c = [], u = Array.from(u); for (var g = 0; g < u.length;) { var M = u[g++]; if (M.tag === 5) se(M) || c.push(M.stateNode); else for (M = M.child; M !== null;)u.push(M), M = M.sibling } return c } var HL = Math.ceil, Mh = a.ReactCurrentDispatcher, F0 = a.ReactCurrentOwner, hn = a.ReactCurrentBatchConfig, gt = 0, yn = null, vn = null, kn = 0, Ri = 0, Ml = Xi(0), wn = 0, gc = null, wl = 0, wh = 0, N0 = 0, yc = null, gi = null, O0 = 0, k0 = 1 / 0; function Sl() { k0 = Ln() + 500 } var Sh = !1, U0 = null, Zs = null, Ch = !1, qs = null, Eh = 0, vc = 0, z0 = null, Th = -1, bh = 0; function ii() { return gt & 6 ? Ln() : Th !== -1 ? Th : Th = Ln() } function $s(u) { return u.mode & 1 ? gt & 2 && kn !== 0 ? kn & -kn : SL.transition !== null ? (bh === 0 && (u = Gd, Gd <<= 1, !(Gd & 4194240) && (Gd = 64), bh = u), bh) : (u = Rt, u !== 0 ? u : Be()) : 1 } function er(u, c, g) { if (50 < vc) throw vc = 0, z0 = null, Error(o(185)); var M = Ph(u, c); return M === null ? null : (tc(M, c, g), (!(gt & 2) || M !== yn) && (M === yn && (!(gt & 2) && (wh |= c), wn === 4 && eo(M, kn)), yi(M, g), c === 1 && gt === 0 && !(u.mode & 1) && (Sl(), jd && Vr())), M) } function Ph(u, c) { u.lanes |= c; var g = u.alternate; for (g !== null && (g.lanes |= c), g = u, u = u.return; u !== null;)u.childLanes |= c, g = u.alternate, g !== null && (g.childLanes |= c), g = u, u = u.return; return g.tag === 3 ? g.stateNode : null } function yi(u, c) { var g = u.callbackNode; mL(u, c); var M = Vd(u, u === yn ? kn : 0); if (M === 0) g !== null && lM(g), u.callbackNode = null, u.callbackPriority = 0; else if (c = M & -M, u.callbackPriority !== c) { if (g != null && lM(g), c === 1) u.tag === 0 ? wL(Sw.bind(null, u)) : uM(Sw.bind(null, u)), Je ? je(function () { gt === 0 && Vr() }) : Yg(Kg, Vr), g = null; else { switch (aM(M)) { case 1: g = Kg; break; case 4: g = xL; break; case 16: g = Qg; break; case 536870912: g = AL; break; default: g = Qg }g = Dw(g, ww.bind(null, u)) } u.callbackPriority = c, u.callbackNode = g } } function ww(u, c) { if (Th = -1, bh = 0, gt & 6) throw Error(o(327)); var g = u.callbackNode; if (aa() && u.callbackNode !== g) return null; var M = Vd(u, u === yn ? kn : 0); if (M === 0) return null; if (M & 30 || M & u.expiredLanes || c) c = Bh(u, M); else { c = M; var C = gt; gt |= 2; var b = Tw(); (yn !== u || kn !== c) && (Sl(), sa(u, c)); do try { jL(); break } catch (J) { Ew(u, J) } while (1); $g(), Mh.current = b, gt = C, vn !== null ? c = 0 : (yn = null, kn = 0, c = wn) } if (c !== 0) { if (c === 2 && (C = jg(u), C !== 0 && (M = C, c = G0(u, C))), c === 1) throw g = gc, sa(u, 0), eo(u, M), yi(u, Ln()), g; if (c === 6) eo(u, M); else { if (C = u.current.alternate, !(M & 30) && !VL(C) && (c = Bh(u, M), c === 2 && (b = jg(u), b !== 0 && (M = b, c = G0(u, b))), c === 1)) throw g = gc, sa(u, 0), eo(u, M), yi(u, Ln()), g; switch (u.finishedWork = C, u.finishedLanes = M, c) { case 0: case 1: throw Error(o(345)); case 2: oa(u, gi); break; case 3: if (eo(u, M), (M & 130023424) === M && (c = O0 + 500 - Ln(), 10 < c)) { if (Vd(u, 0) !== 0) break; if (C = u.suspendedLanes, (C & M) !== M) { ii(), u.pingedLanes |= u.suspendedLanes & C; break } u.timeoutHandle = Oe(oa.bind(null, u, gi), c); break } oa(u, gi); break; case 4: if (eo(u, M), (M & 4194240) === M) break; for (c = u.eventTimes, C = -1; 0 < M;) { var O = 31 - vr(M); b = 1 << O, O = c[O], O > C && (C = O), M &= ~b } if (M = C, M = Ln() - M, M = (120 > M ? 120 : 480 > M ? 480 : 1080 > M ? 1080 : 1920 > M ? 1920 : 3e3 > M ? 3e3 : 4320 > M ? 4320 : 1960 * HL(M / 1960)) - M, 10 < M) { u.timeoutHandle = Oe(oa.bind(null, u, gi), M); break } oa(u, gi); break; case 5: oa(u, gi); break; default: throw Error(o(329)) } } } return yi(u, Ln()), u.callbackNode === g ? ww.bind(null, u) : null } function G0(u, c) { var g = yc; return u.current.memoizedState.isDehydrated && (sa(u, c).flags |= 256), u = Bh(u, c), u !== 2 && (c = gi, gi = g, c !== null && H0(c)), u } function H0(u) { gi === null ? gi = u : gi.push.apply(gi, u) } function VL(u) { for (var c = u; ;) { if (c.flags & 16384) { var g = c.updateQueue; if (g !== null && (g = g.stores, g !== null)) for (var M = 0; M < g.length; M++) { var C = g[M], b = C.getSnapshot; C = C.value; try { if (!Hr(b(), C)) return !1 } catch { return !1 } } } if (g = c.child, c.subtreeFlags & 16384 && g !== null) g.return = c, c = g; else { if (c === u) break; for (; c.sibling === null;) { if (c.return === null || c.return === u) return !0; c = c.return } c.sibling.return = c.return, c = c.sibling } } return !0 } function eo(u, c) { for (c &= ~N0, c &= ~wh, u.suspendedLanes |= c, u.pingedLanes &= ~c, u = u.expirationTimes; 0 < c;) { var g = 31 - vr(c), M = 1 << g; u[g] = -1, c &= ~M } } function Sw(u) { if (gt & 6) throw Error(o(327)); aa(); var c = Vd(u, 0); if (!(c & 1)) return yi(u, Ln()), null; var g = Bh(u, c); if (u.tag !== 0 && g === 2) { var M = jg(u); M !== 0 && (c = M, g = G0(u, M)) } if (g === 1) throw g = gc, sa(u, 0), eo(u, c), yi(u, Ln()), g; if (g === 6) throw Error(o(345)); return u.finishedWork = u.current.alternate, u.finishedLanes = c, oa(u, gi), yi(u, Ln()), null } function Cw(u) { qs !== null && qs.tag === 0 && !(gt & 6) && aa(); var c = gt; gt |= 1; var g = hn.transition, M = Rt; try { if (hn.transition = null, Rt = 1, u) return u() } finally { Rt = M, hn.transition = g, gt = c, !(gt & 6) && Vr() } } function V0() { Ri = Ml.current, ct(Ml) } function sa(u, c) { u.finishedWork = null, u.finishedLanes = 0; var g = u.timeoutHandle; if (g !== He && (u.timeoutHandle = He, ke(g)), vn !== null) for (g = vn.return; g !== null;) { var M = g; switch (o0(M), M.tag) { case 1: M = M.type.childContextTypes, M != null && Ud(); break; case 3: Al(), ct(Rn), ct(Ft), h0(); break; case 5: f0(M); break; case 4: Al(); break; case 13: ct(Zt); break; case 19: ct(Zt); break; case 10: e0(M.type._context); break; case 22: case 23: V0() }g = g.return } if (yn = u, vn = u = to(u.current, null), kn = Ri = c, wn = 0, gc = null, N0 = wh = wl = 0, gi = yc = null, Wr !== null) { for (c = 0; c < Wr.length; c++)if (g = Wr[c], M = g.interleaved, M !== null) { g.interleaved = null; var C = M.next, b = g.pending; if (b !== null) { var O = b.next; b.next = C, M.next = O } g.pending = M } Wr = null } return u } function Ew(u, c) { do { var g = vn; try { if ($g(), nh.current = lh, ih) { for (var M = ln.memoizedState; M !== null;) { var C = M.queue; C !== null && (C.pending = null), M = M.next } ih = !1 } if (_l = 0, Dn = Wn = ln = null, ac = !1, lc = 0, F0.current = null, g === null || g.return === null) { wn = 1, gc = c, vn = null; break } e: { var b = u, O = g.return, J = g, fe = c; if (c = kn, J.flags |= 32768, fe !== null && typeof fe == "object" && typeof fe.then == "function") { var Te = fe, Ve = J, ot = Ve.tag; if (!(Ve.mode & 1) && (ot === 0 || ot === 11 || ot === 15)) { var et = Ve.alternate; et ? (Ve.updateQueue = et.updateQueue, Ve.memoizedState = et.memoizedState, Ve.lanes = et.lanes) : (Ve.updateQueue = null, Ve.memoizedState = null) } var Ut = XM(O); if (Ut !== null) { Ut.flags &= -257, YM(Ut, O, J, b, c), Ut.mode & 1 && JM(b, Te, c), c = Ut, fe = Te; var Qe = c.updateQueue; if (Qe === null) { var Xn = new Set; Xn.add(fe), c.updateQueue = Xn } else Qe.add(fe); break e } else { if (!(c & 1)) { JM(b, Te, c), W0(); break e } fe = Error(o(426)) } } else if (Xt && J.mode & 1) { var nr = XM(O); if (nr !== null) { !(nr.flags & 65536) && (nr.flags |= 256), YM(nr, O, J, b, c), u0(fe); break e } } b = fe, wn !== 4 && (wn = 2), yc === null ? yc = [b] : yc.push(b), fe = A0(fe, J), J = O; do { switch (J.tag) { case 3: J.flags |= 65536, c &= -c, J.lanes |= c; var te = WM(J, fe, c); dM(J, te); break e; case 1: b = fe; var Q = J.type, ue = J.stateNode; if (!(J.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (Zs === null || !Zs.has(ue)))) { J.flags |= 65536, c &= -c, J.lanes |= c; var Ne = jM(J, b, c); dM(J, Ne); break e } }J = J.return } while (J !== null) } Pw(g) } catch (Ye) { c = Ye, vn === g && g !== null && (vn = g = g.return); continue } break } while (1) } function Tw() { var u = Mh.current; return Mh.current = lh, u === null ? lh : u } function W0() { (wn === 0 || wn === 3 || wn === 2) && (wn = 4), yn === null || !(wl & 268435455) && !(wh & 268435455) || eo(yn, kn) } function Bh(u, c) { var g = gt; gt |= 2; var M = Tw(); yn === u && kn === c || sa(u, c); do try { WL(); break } catch (C) { Ew(u, C) } while (1); if ($g(), gt = g, Mh.current = M, vn !== null) throw Error(o(261)); return yn = null, kn = 0, wn } function WL() { for (; vn !== null;)bw(vn) } function jL() { for (; vn !== null && !yL();)bw(vn) } function bw(u) { var c = Lw(u.alternate, u, Ri); u.memoizedProps = u.pendingProps, c === null ? Pw(u) : vn = c, F0.current = null } function Pw(u) { var c = u; do { var g = c.alternate; if (u = c.return, c.flags & 32768) { if (g = OL(g, c), g !== null) { g.flags &= 32767, vn = g; return } if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null; else { wn = 6, vn = null; return } } else if (g = IL(g, c, Ri), g !== null) { vn = g; return } if (c = c.sibling, c !== null) { vn = c; return } vn = c = u } while (c !== null); wn === 0 && (wn = 5) } function oa(u, c) { var g = Rt, M = hn.transition; try { hn.transition = null, Rt = 1, JL(u, c, g) } finally { hn.transition = M, Rt = g } return null } function JL(u, c, g) { do aa(); while (qs !== null); if (gt & 6) throw Error(o(327)); var M = u.finishedWork, C = u.finishedLanes; if (M === null) return null; if (u.finishedWork = null, u.finishedLanes = 0, M === u.current) throw Error(o(177)); u.callbackNode = null, u.callbackPriority = 0; var b = M.lanes | M.childLanes; if (gL(u, b), u === yn && (vn = yn = null, kn = 0), !(M.subtreeFlags & 2064) && !(M.flags & 2064) || Ch || (Ch = !0, Dw(Qg, function () { return aa(), null })), b = (M.flags & 15990) !== 0, M.subtreeFlags & 15990 || b) { b = hn.transition, hn.transition = null; var O = Rt; Rt = 1; var J = gt; gt |= 4, F0.current = null, UL(u, M), zL(u, M), Y(u.containerInfo), u.current = M, GL(M), vL(), gt = J, Rt = O, hn.transition = b } else u.current = M; if (Ch && (Ch = !1, qs = u, Eh = C), b = u.pendingLanes, b === 0 && (Zs = null), _L(M.stateNode), yi(u, Ln()), c !== null) for (g = u.onRecoverableError, M = 0; M < c.length; M++)g(c[M]); if (Sh) throw Sh = !1, u = U0, U0 = null, u; return Eh & 1 && u.tag !== 0 && aa(), b = u.pendingLanes, b & 1 ? u === z0 ? vc++ : (vc = 0, z0 = u) : vc = 0, Vr(), null } function aa() { if (qs !== null) { var u = aM(Eh), c = hn.transition, g = Rt; try { if (hn.transition = null, Rt = 16 > u ? 16 : u, qs === null) var M = !1; else { if (u = qs, qs = null, Eh = 0, gt & 6) throw Error(o(331)); var C = gt; for (gt |= 4, Fe = u.current; Fe !== null;) { var b = Fe, O = b.child; if (Fe.flags & 16) { var J = b.deletions; if (J !== null) { for (var fe = 0; fe < J.length; fe++) { var Te = J[fe]; for (Fe = Te; Fe !== null;) { var Ve = Fe; switch (Ve.tag) { case 0: case 11: case 15: ra(8, Ve, b) }var ot = Ve.child; if (ot !== null) ot.return = Ve, Fe = ot; else for (; Fe !== null;) { Ve = Fe; var et = Ve.sibling, Ut = Ve.return; if (hw(Ve), Ve === Te) { Fe = null; break } if (et !== null) { et.return = Ut, Fe = et; break } Fe = Ut } } } var Qe = b.alternate; if (Qe !== null) { var Xn = Qe.child; if (Xn !== null) { Qe.child = null; do { var nr = Xn.sibling; Xn.sibling = null, Xn = nr } while (Xn !== null) } } Fe = b } } if (b.subtreeFlags & 2064 && O !== null) O.return = b, Fe = O; else e: for (; Fe !== null;) { if (b = Fe, b.flags & 2048) switch (b.tag) { case 0: case 11: case 15: ra(9, b, b.return) }var te = b.sibling; if (te !== null) { te.return = b.return, Fe = te; break e } Fe = b.return } } var Q = u.current; for (Fe = Q; Fe !== null;) { O = Fe; var ue = O.child; if (O.subtreeFlags & 2064 && ue !== null) ue.return = O, Fe = ue; else e: for (O = Q; Fe !== null;) { if (J = Fe, J.flags & 2048) try { switch (J.tag) { case 0: case 11: case 15: pc(9, J) } } catch (Ye) { vi(J, J.return, Ye) } if (J === O) { Fe = null; break e } var Ne = J.sibling; if (Ne !== null) { Ne.return = J.return, Fe = Ne; break e } Fe = J.return } } if (gt = C, Vr(), Gr && typeof Gr.onPostCommitFiberRoot == "function") try { Gr.onPostCommitFiberRoot(Wd, u) } catch { } M = !0 } return M } finally { Rt = g, hn.transition = c } } return !1 } function Bw(u, c, g) { c = A0(g, c), c = WM(u, c, 1), Qs(u, c), c = ii(), u = Ph(u, 1), u !== null && (tc(u, 1, c), yi(u, c)) } function vi(u, c, g) { if (u.tag === 3) Bw(u, u, g); else for (; c !== null;) { if (c.tag === 3) { Bw(c, u, g); break } else if (c.tag === 1) { var M = c.stateNode; if (typeof c.type.getDerivedStateFromError == "function" || typeof M.componentDidCatch == "function" && (Zs === null || !Zs.has(M))) { u = A0(g, u), u = jM(c, u, 1), Qs(c, u), u = ii(), c = Ph(c, 1), c !== null && (tc(c, 1, u), yi(c, u)); break } } c = c.return } } function XL(u, c, g) { var M = u.pingCache; M !== null && M.delete(c), c = ii(), u.pingedLanes |= u.suspendedLanes & g, yn === u && (kn & g) === g && (wn === 4 || wn === 3 && (kn & 130023424) === kn && 500 > Ln() - O0 ? sa(u, 0) : N0 |= g), yi(u, c) } function Rw(u, c) { c === 0 && (u.mode & 1 ? (c = Hd, Hd <<= 1, !(Hd & 130023424) && (Hd = 4194304)) : c = 1); var g = ii(); u = Ph(u, c), u !== null && (tc(u, c, g), yi(u, g)) } function YL(u) { var c = u.memoizedState, g = 0; c !== null && (g = c.retryLane), Rw(u, g) } function KL(u, c) { var g = 0; switch (u.tag) { case 13: var M = u.stateNode, C = u.memoizedState; C !== null && (g = C.retryLane); break; case 19: M = u.stateNode; break; default: throw Error(o(314)) }M !== null && M.delete(c), Rw(u, g) } var Lw; Lw = function (u, c, g) { if (u !== null) if (u.memoizedProps !== c.pendingProps || Rn.current) Bi = !0; else { if (!(u.lanes & g) && !(c.flags & 128)) return Bi = !1, NL(u, c, g); Bi = !!(u.flags & 131072) } else Bi = !1, Xt && c.flags & 1048576 && vM(c, $d, c.index); switch (c.lanes = 0, c.tag) { case 2: var M = c.type; u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), u = c.pendingProps; var C = cs(c, Ft.current); pl(c, g), C = m0(null, c, M, u, C, g); var b = g0(); return c.flags |= 1, typeof C == "object" && C !== null && typeof C.render == "function" && C.$$typeof === void 0 ? (c.tag = 1, c.memoizedState = null, c.updateQueue = null, mi(M) ? (b = !0, zd(c)) : b = !1, c.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, n0(c), C.updater = Zd, c.stateNode = C, C._reactInternals = c, r0(c, M, u, g), c = w0(null, c, M, !0, b, g)) : (c.tag = 0, Xt && b && s0(c), ni(null, c, C, g), c = c.child), c; case 16: M = c.elementType; e: { switch (u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), u = c.pendingProps, C = M._init, M = C(M._payload), c.type = M, C = c.tag = ZL(M), u = xr(M, u), C) { case 0: c = M0(null, c, M, u, g); break e; case 1: c = nw(null, c, M, u, g); break e; case 11: c = ZM(null, c, M, u, g); break e; case 14: c = qM(null, c, M, xr(M.type, u), g); break e }throw Error(o(306, M, "")) } return c; case 0: return M = c.type, C = c.pendingProps, C = c.elementType === M ? C : xr(M, C), M0(u, c, M, C, g); case 1: return M = c.type, C = c.pendingProps, C = c.elementType === M ? C : xr(M, C), nw(u, c, M, C, g); case 3: e: { if (iw(c), u === null) throw Error(o(387)); M = c.pendingProps, b = c.memoizedState, C = b.element, fM(u, c), Qd(c, M, null, g); var O = c.memoizedState; if (M = O.element, ae && b.isDehydrated) if (b = { element: M, isDehydrated: !1, cache: O.cache, transitions: O.transitions }, c.updateQueue.baseState = b, c.memoizedState = b, c.flags & 256) { C = Error(o(423)), c = rw(u, c, M, g, C); break e } else if (M !== C) { C = Error(o(424)), c = rw(u, c, M, g, C); break e } else for (ae && (Pi = Z(c.stateNode.containerInfo), bi = c, Xt = !0, Ar = null, nc = !1), g = SM(c, null, M, g), c.child = g; g;)g.flags = g.flags & -3 | 4096, g = g.sibling; else { if (yl(), M === C) { c = gs(u, c, g); break e } ni(u, c, M, g) } c = c.child } return c; case 5: return CM(c), u === null && l0(c), M = c.type, C = c.pendingProps, b = u !== null ? u.memoizedProps : null, O = C.children, Ae(M, C) ? O = null : b !== null && Ae(M, b) && (c.flags |= 32), tw(u, c), ni(u, c, O, g), c.child; case 6: return u === null && l0(c), null; case 13: return sw(u, c, g); case 4: return c0(c, c.stateNode.containerInfo), M = c.pendingProps, u === null ? c.child = vl(c, null, M, g) : ni(u, c, M, g), c.child; case 11: return M = c.type, C = c.pendingProps, C = c.elementType === M ? C : xr(M, C), ZM(u, c, M, C, g); case 7: return ni(u, c, c.pendingProps, g), c.child; case 8: return ni(u, c, c.pendingProps.children, g), c.child; case 12: return ni(u, c, c.pendingProps.children, g), c.child; case 10: e: { if (M = c.type._context, C = c.pendingProps, b = c.memoizedProps, O = C.value, cM(c, M, O), b !== null) if (Hr(b.value, O)) { if (b.children === C.children && !Rn.current) { c = gs(u, c, g); break e } } else for (b = c.child, b !== null && (b.return = c); b !== null;) { var J = b.dependencies; if (J !== null) { O = b.child; for (var fe = J.firstContext; fe !== null;) { if (fe.context === M) { if (b.tag === 1) { fe = ds(-1, g & -g), fe.tag = 2; var Te = b.updateQueue; if (Te !== null) { Te = Te.shared; var Ve = Te.pending; Ve === null ? fe.next = fe : (fe.next = Ve.next, Ve.next = fe), Te.pending = fe } } b.lanes |= g, fe = b.alternate, fe !== null && (fe.lanes |= g), t0(b.return, g, c), J.lanes |= g; break } fe = fe.next } } else if (b.tag === 10) O = b.type === c.type ? null : b.child; else if (b.tag === 18) { if (O = b.return, O === null) throw Error(o(341)); O.lanes |= g, J = O.alternate, J !== null && (J.lanes |= g), t0(O, g, c), O = b.sibling } else O = b.child; if (O !== null) O.return = b; else for (O = b; O !== null;) { if (O === c) { O = null; break } if (b = O.sibling, b !== null) { b.return = O.return, O = b; break } O = O.return } b = O } ni(u, c, C.children, g), c = c.child } return c; case 9: return C = c.type, M = c.pendingProps.children, pl(c, g), C = Ki(C), M = M(C), c.flags |= 1, ni(u, c, M, g), c.child; case 14: return M = c.type, C = xr(M, c.pendingProps), C = xr(M.type, C), qM(u, c, M, C, g); case 15: return $M(u, c, c.type, c.pendingProps, g); case 17: return M = c.type, C = c.pendingProps, C = c.elementType === M ? C : xr(M, C), u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), c.tag = 1, mi(M) ? (u = !0, zd(c)) : u = !1, pl(c, g), gM(c, M, C), r0(c, M, C, g), w0(null, c, M, !0, u, g); case 19: return uw(u, c, g); case 22: return ew(u, c, g) }throw Error(o(156, c.tag)) }; function Dw(u, c) { return Yg(u, c) } function QL(u, c, g, M) { this.tag = u, this.key = g, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = M, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function tr(u, c, g, M) { return new QL(u, c, g, M) } function j0(u) { return u = u.prototype, !(!u || !u.isReactComponent) } function ZL(u) { if (typeof u == "function") return j0(u) ? 1 : 0; if (u != null) { if (u = u.$$typeof, u === y) return 11; if (u === _) return 14 } return 2 } function to(u, c) { var g = u.alternate; return g === null ? (g = tr(u.tag, c, u.key, u.mode), g.elementType = u.elementType, g.type = u.type, g.stateNode = u.stateNode, g.alternate = u, u.alternate = g) : (g.pendingProps = c, g.type = u.type, g.flags = 0, g.subtreeFlags = 0, g.deletions = null), g.flags = u.flags & 14680064, g.childLanes = u.childLanes, g.lanes = u.lanes, g.child = u.child, g.memoizedProps = u.memoizedProps, g.memoizedState = u.memoizedState, g.updateQueue = u.updateQueue, c = u.dependencies, g.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }, g.sibling = u.sibling, g.index = u.index, g.ref = u.ref, g } function Rh(u, c, g, M, C, b) { var O = 2; if (M = u, typeof u == "function") j0(u) && (O = 1); else if (typeof u == "string") O = 5; else e: switch (u) { case d: return la(g.children, C, b, c); case h: O = 8, C |= 8; break; case p: return u = tr(12, g, c, C | 2), u.elementType = p, u.lanes = b, u; case x: return u = tr(13, g, c, C), u.elementType = x, u.lanes = b, u; case A: return u = tr(19, g, c, C), u.elementType = A, u.lanes = b, u; case S: return Lh(g, C, b, c); default: if (typeof u == "object" && u !== null) switch (u.$$typeof) { case m: O = 10; break e; case v: O = 9; break e; case y: O = 11; break e; case _: O = 14; break e; case w: O = 16, M = null; break e }throw Error(o(130, u == null ? u : typeof u, "")) }return c = tr(O, g, c, C), c.elementType = u, c.type = M, c.lanes = b, c } function la(u, c, g, M) { return u = tr(7, u, M, c), u.lanes = g, u } function Lh(u, c, g, M) { return u = tr(22, u, M, c), u.elementType = S, u.lanes = g, u.stateNode = {}, u } function J0(u, c, g) { return u = tr(6, u, null, c), u.lanes = g, u } function X0(u, c, g) { return c = tr(4, u.children !== null ? u.children : [], u.key, c), c.lanes = g, c.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, c } function qL(u, c, g, M, C) { this.tag = c, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = He, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Jg(0), this.expirationTimes = Jg(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Jg(0), this.identifierPrefix = M, this.onRecoverableError = C, ae && (this.mutableSourceEagerHydrationData = null) } function Iw(u, c, g, M, C, b, O, J, fe) { return u = new qL(u, c, g, J, fe), c === 1 ? (c = 1, b === !0 && (c |= 8)) : c = 0, b = tr(3, null, null, c), u.current = b, b.stateNode = u, b.memoizedState = { element: M, isDehydrated: g, cache: null, transitions: null }, n0(b), u } function Fw(u) { if (!u) return Yi; u = u._reactInternals; e: { if (B(u) !== u || u.tag !== 1) throw Error(o(170)); var c = u; do { switch (c.tag) { case 3: c = c.stateNode.context; break e; case 1: if (mi(c.type)) { c = c.stateNode.__reactInternalMemoizedMergedChildContext; break e } }c = c.return } while (c !== null); throw Error(o(171)) } if (u.tag === 1) { var g = u.type; if (mi(g)) return sM(u, g, c) } return c } function Nw(u) { var c = u._reactInternals; if (c === void 0) throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","), Error(o(268, u))); return u = q(c), u === null ? null : u.stateNode } function Ow(u, c) { if (u = u.memoizedState, u !== null && u.dehydrated !== null) { var g = u.retryLane; u.retryLane = g !== 0 && g < c ? g : c } } function Y0(u, c) { Ow(u, c), (u = u.alternate) && Ow(u, c) } function $L(u) { return u = q(u), u === null ? null : u.stateNode } function eD() { return null } return t.attemptContinuousHydration = function (u) { if (u.tag === 13) { var c = ii(); er(u, 134217728, c), Y0(u, 134217728) } }, t.attemptHydrationAtCurrentPriority = function (u) { if (u.tag === 13) { var c = ii(), g = $s(u); er(u, g, c), Y0(u, g) } }, t.attemptSynchronousHydration = function (u) { switch (u.tag) { case 3: var c = u.stateNode; if (c.current.memoizedState.isDehydrated) { var g = ec(c.pendingLanes); g !== 0 && (Xg(c, g | 1), yi(c, Ln()), !(gt & 6) && (Sl(), Vr())) } break; case 13: var M = ii(); Cw(function () { return er(u, 1, M) }), Y0(u, 1) } }, t.batchedUpdates = function (u, c) { var g = gt; gt |= 1; try { return u(c) } finally { gt = g, gt === 0 && (Sl(), jd && Vr()) } }, t.createComponentSelector = function (u) { return { $$typeof: yh, value: u } }, t.createContainer = function (u, c, g, M, C, b, O) { return Iw(u, c, !1, null, g, M, C, b, O) }, t.createHasPseudoClassSelector = function (u) { return { $$typeof: vh, value: u } }, t.createHydrationContainer = function (u, c, g, M, C, b, O, J, fe) { return u = Iw(g, M, !0, u, C, b, O, J, fe), u.context = Fw(null), g = u.current, M = ii(), C = $s(g), b = ds(M, C), b.callback = c ?? null, Qs(g, b), u.current.lanes = C, tc(u, C, M), yi(u, M), u }, t.createPortal = function (u, c, g) { var M = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: f, key: M == null ? null : "" + M, children: u, containerInfo: c, implementation: g } }, t.createRoleSelector = function (u) { return { $$typeof: xh, value: u } }, t.createTestNameSelector = function (u) { return { $$typeof: Ah, value: u } }, t.createTextSelector = function (u) { return { $$typeof: _h, value: u } }, t.deferredUpdates = function (u) { var c = Rt, g = hn.transition; try { return hn.transition = null, Rt = 16, u() } finally { Rt = c, hn.transition = g } }, t.discreteUpdates = function (u, c, g, M, C) { var b = Rt, O = hn.transition; try { return hn.transition = null, Rt = 1, u(c, g, M, C) } finally { Rt = b, hn.transition = O, gt === 0 && Sl() } }, t.findAllNodes = I0, t.findBoundingRects = function (u, c) { if (!vt) throw Error(o(363)); c = I0(u, c), u = []; for (var g = 0; g < c.length; g++)u.push(k(c[g])); for (c = u.length - 1; 0 < c; c--) { g = u[c]; for (var M = g.x, C = M + g.width, b = g.y, O = b + g.height, J = c - 1; 0 <= J; J--)if (c !== J) { var fe = u[J], Te = fe.x, Ve = Te + fe.width, ot = fe.y, et = ot + fe.height; if (M >= Te && b >= ot && C <= Ve && O <= et) { u.splice(c, 1); break } else if (M !== Te || g.width !== fe.width || et < b || ot > O) { if (!(b !== ot || g.height !== fe.height || Ve < M || Te > C)) { Te > M && (fe.width += Te - M, fe.x = M), Ve < C && (fe.width = C - Te), u.splice(c, 1); break } } else { ot > b && (fe.height += ot - b, fe.y = b), et < O && (fe.height = O - ot), u.splice(c, 1); break } } } return u }, t.findHostInstance = Nw, t.findHostInstanceWithNoPortals = function (u) { return u = U(u), u = u !== null ? G(u) : null, u === null ? null : u.stateNode }, t.findHostInstanceWithWarning = function (u) { return Nw(u) }, t.flushControlled = function (u) { var c = gt; gt |= 1; var g = hn.transition, M = Rt; try { hn.transition = null, Rt = 1, u() } finally { Rt = M, hn.transition = g, gt = c, gt === 0 && (Sl(), Vr()) } }, t.flushPassiveEffects = aa, t.flushSync = Cw, t.focusWithin = function (u, c) { if (!vt) throw Error(o(363)); for (u = R0(u), c = Mw(u, c), c = Array.from(c), u = 0; u < c.length;) { var g = c[u++]; if (!se(g)) { if (g.tag === 5 && Ee(g.stateNode)) return !0; for (g = g.child; g !== null;)c.push(g), g = g.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return Rt }, t.getFindAllNodesFailureDescription = function (u, c) {
		if (!vt) throw Error(o(363)); var g = 0, M = []; u = [R0(u), 0]; for (var C = 0; C < u.length;) { var b = u[C++], O = u[C++], J = c[O]; if ((b.tag !== 5 || !se(b)) && (L0(b, J) && (M.push(D0(J)), O++, O > g && (g = O)), O < c.length)) for (b = b.child; b !== null;)u.push(b, O), b = b.sibling } if (g < c.length) {
			for (u = []; g < c.length; g++)u.push(D0(c[g])); return `findAllNodes was able to match part of the selector:
  `+ (M.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ")
		} return null
	}, t.getPublicRootInstance = function (u) { if (u = u.current, !u.child) return null; switch (u.child.tag) { case 5: return ne(u.child.stateNode); default: return u.child.stateNode } }, t.injectIntoDevTools = function (u) { if (u = { bundleType: u.bundleType, version: u.version, rendererPackageName: u.rendererPackageName, rendererConfig: u.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: $L, findFiberByHostInstance: u.findFiberByHostInstance || eD, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") u = !1; else { var c = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (c.isDisabled || !c.supportsFiber) u = !0; else { try { Wd = c.inject(u), Gr = c } catch { } u = !!c.checkDCE } } return u }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (u, c, g, M) { if (!vt) throw Error(o(363)); u = I0(u, c); var C = Pe(u, g, M).disconnect; return { disconnect: function () { C() } } }, t.registerMutableSourceForHydration = function (u, c) { var g = c._getVersion; g = g(c._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [c, g] : u.mutableSourceEagerHydrationData.push(c, g) }, t.runWithPriority = function (u, c) { var g = Rt; try { return Rt = u, c() } finally { Rt = g } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (u, c, g, M) { var C = c.current, b = ii(), O = $s(C); return g = Fw(g), c.context === null ? c.context = g : c.pendingContext = g, c = ds(b, O), c.payload = { element: u }, M = M === void 0 ? null : M, M !== null && (c.callback = M), Qs(C, c), u = er(C, O, b), u !== null && Kd(u, C, O), O }, t
}; (function (n) { n.exports = $H })(ZH); const e5 = rb(a1); function p3(n, e, t = (i, r) => i === r) { if (n === e) return !0; if (!n || !e) return !1; const i = n.length; if (e.length !== i) return !1; for (let r = 0; r < i; r++)if (!t(n[r], e[r])) return !1; return !0 } const Ts = []; function m3(n, e, t = !1, i = {}) { for (const s of Ts) if (p3(e, s.keys, s.equal)) { if (t) return; if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error; if (Object.prototype.hasOwnProperty.call(s, "response")) return s.response; if (!t) throw s.promise } const r = { keys: e, equal: i.equal, promise: n(...e).then(s => r.response = s).then(() => { i.lifespan && i.lifespan > 0 && setTimeout(() => { const s = Ts.indexOf(r); s !== -1 && Ts.splice(s, 1) }, i.lifespan) }).catch(s => r.error = s) }; if (Ts.push(r), !t) throw r.promise } const t5 = (n, e, t) => m3(n, e, !1, t), n5 = (n, e, t) => void m3(n, e, !0, t), i5 = n => { if (n === void 0 || n.length === 0) Ts.splice(0, Ts.length); else { const e = Ts.find(t => p3(n, t.keys, t.equal)); if (e) { const t = Ts.indexOf(e); t !== -1 && Ts.splice(t, 1) } } }; var ME, wE; const r5 = (n, ...e) => e.reduce((t, i) => t == null ? void 0 : t[i], n), Wl = "ColorManagement" in o1 && r5(o1, "ColorManagement") || null, g3 = n => n && n.isOrthographicCamera, s5 = n => n && n.hasOwnProperty("current"), Rd = typeof window < "u" && ((ME = window.document) != null && ME.createElement || ((wE = window.navigator) == null ? void 0 : wE.product) === "ReactNative") ? z.useLayoutEffect : z.useEffect; function y3(n) { const e = z.useRef(n); return Rd(() => void (e.current = n), [n]), e } function o5({ set: n }) { return Rd(() => (n(new Promise(() => null)), () => n(!1)), [n]), null } class v3 extends z.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } v3.getDerivedStateFromError = () => ({ error: !0 }); const x3 = "__default", SE = new Map, a5 = n => n && !!n.memoized && !!n.changes; function A3(n) { const e = typeof window < "u" ? window.devicePixelRatio : 1; return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n } const Uc = n => { var e; return (e = n.__r3f) == null ? void 0 : e.root.getState() }, qt = { obj: n => n === Object(n) && !qt.arr(n) && typeof n != "function", fun: n => typeof n == "function", str: n => typeof n == "string", num: n => typeof n == "number", boo: n => typeof n == "boolean", und: n => n === void 0, arr: n => Array.isArray(n), equ(n, e, { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}) { if (typeof n != typeof e || !!n != !!e) return !1; if (qt.str(n) || qt.num(n)) return n === e; const s = qt.obj(n); if (s && i === "reference") return n === e; const o = qt.arr(n); if (o && t === "reference") return n === e; if ((o || s) && n === e) return !0; let a; for (a in n) if (!(a in e)) return !1; for (a in r ? e : n) if (n[a] !== e[a]) return !1; if (qt.und(a)) { if (o && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0; if (n !== e) return !1 } return !0 } }; function l5(n) { const e = { nodes: {}, materials: {} }; return n && n.traverse(t => { t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material) }), e } function u5(n) { n.dispose && n.type !== "Scene" && n.dispose(); for (const e in n) e.dispose == null || e.dispose(), delete n[e] } function jl(n, e) { const t = n; return (e != null && e.primitive || !t.__r3f) && (t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }), n } function l1(n, e) { let t = n; if (e.includes("-")) { const i = e.split("-"), r = i.pop(); return t = i.reduce((s, o) => s[o], n), { target: t, key: r } } else return { target: t, key: e } } const CE = /-\d+$/; function nv(n, e, t) { if (qt.str(t)) { if (CE.test(t)) { const s = t.replace(CE, ""), { target: o, key: a } = l1(n, s); Array.isArray(o[a]) || (o[a] = []) } const { target: i, key: r } = l1(n, t); e.__r3f.previousAttach = i[r], i[r] = e } else e.__r3f.previousAttach = t(n, e) } function EE(n, e, t) { var i, r; if (qt.str(t)) { const { target: s, key: o } = l1(n, t), a = e.__r3f.previousAttach; a === void 0 ? delete s[o] : s[o] = a } else (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e); (r = e.__r3f) == null || delete r.previousAttach } function _3(n, { children: e, key: t, ref: i, ...r }, { children: s, key: o, ref: a, ...l } = {}, f = !1) { var d; const h = (d = n == null ? void 0 : n.__r3f) != null ? d : {}, p = Object.entries(r), m = []; if (f) { const y = Object.keys(l); for (let x = 0; x < y.length; x++)r.hasOwnProperty(y[x]) || p.unshift([y[x], x3 + "remove"]) } p.forEach(([y, x]) => { var A; if ((A = n.__r3f) != null && A.primitive && y === "object" || qt.equ(x, l[y])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(y)) return m.push([y, x, !0, []]); let _ = []; y.includes("-") && (_ = y.split("-")), m.push([y, x, !1, _]); for (const w in r) { const S = r[w]; w.startsWith(`${y}-`) && m.push([w, S, !1, w.split("-")]) } }); const v = { ...r }; return h.memoizedProps && h.memoizedProps.args && (v.args = h.memoizedProps.args), h.memoizedProps && h.memoizedProps.attach && (v.attach = h.memoizedProps.attach), { memoized: v, changes: m } } function iv(n, e) { var t, i, r; const s = (t = n.__r3f) != null ? t : {}, o = s.root, a = (i = o == null || o.getState == null ? void 0 : o.getState()) != null ? i : {}, { memoized: l, changes: f } = a5(e) ? e : _3(n, e), d = s.eventCount; n.__r3f && (n.__r3f.memoizedProps = l); for (let p = 0; p < f.length; p++) { let [m, v, y, x] = f[p], A = n, _ = A[m]; if (x.length && (_ = x.reduce((w, S) => w[S], n), !(_ && _.set))) { const [w, ...S] = x.reverse(); A = S.reverse().reduce((T, P) => T[P], n), m = w } if (v === x3 + "remove") if (A.constructor) { let w = SE.get(A.constructor); w || (w = new A.constructor, SE.set(A.constructor, w)), v = w[m] } else v = 0; if (y) v ? s.handlers[m] = v : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length; else if (_ && _.set && (_.copy || _ instanceof Ja)) { if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v); else if (_.copy && v && v.constructor && _.constructor === v.constructor) _.copy(v); else if (v !== void 0) { const w = _ instanceof Le; !w && _.setScalar ? _.setScalar(v) : _ instanceof Ja && v instanceof Ja ? _.mask = v.mask : _.set(v), !Wl && !a.linear && w && _.convertSRGBToLinear() } } else A[m] = v, !a.linear && A[m] instanceof Qt && A[m].format === Ai && A[m].type === Hs && (A[m].encoding = Ct); Jl(n) } if (s.parent && a.internal && n.raycast && d !== s.eventCount) { const p = a.internal.interaction.indexOf(n); p > -1 && a.internal.interaction.splice(p, 1), s.eventCount && a.internal.interaction.push(n) } return !(f.length === 1 && f[0][0] === "onUpdate") && f.length && (r = n.__r3f) != null && r.parent && u1(n), n } function Jl(n) { var e, t; const i = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState(); i && i.internal.frames === 0 && i.invalidate() } function u1(n) { n.onUpdate == null || n.onUpdate(n) } function c5(n, e) { n.manual || (g3(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld()) } function Fp(n) { return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId } function f5() { var n; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return wo.DefaultEventPriority; switch ((n = e.event) == null ? void 0 : n.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return wo.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return wo.ContinuousEventPriority; default: return wo.DefaultEventPriority } } function M3(n, e, t, i) { const r = t.get(e); r && (t.delete(e), t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i))) } function d5(n, e) { const { internal: t } = n.getState(); t.interaction = t.interaction.filter(i => i !== e), t.initialHits = t.initialHits.filter(i => i !== e), t.hovered.forEach((i, r) => { (i.eventObject === e || i.object === e) && t.hovered.delete(r) }), t.capturedMap.forEach((i, r) => { M3(t.capturedMap, e, i, r) }) } function h5(n) { function e(l) { const { internal: f } = n.getState(), d = l.offsetX - f.initialClick[0], h = l.offsetY - f.initialClick[1]; return Math.round(Math.sqrt(d * d + h * h)) } function t(l) { return l.filter(f => ["Move", "Over", "Enter", "Out", "Leave"].some(d => { var h; return (h = f.__r3f) == null ? void 0 : h.handlers["onPointer" + d] })) } function i(l, f) { const d = n.getState(), h = new Set, p = [], m = f ? f(d.internal.interaction) : d.internal.interaction; for (let A = 0; A < m.length; A++) { const _ = Uc(m[A]); _ && (_.raycaster.camera = void 0) } d.previousRoot || d.events.compute == null || d.events.compute(l, d); function v(A) { const _ = Uc(A); if (!_ || !_.events.enabled || _.raycaster.camera === null) return []; if (_.raycaster.camera === void 0) { var w; _.events.compute == null || _.events.compute(l, _, (w = _.previousRoot) == null ? void 0 : w.getState()), _.raycaster.camera === void 0 && (_.raycaster.camera = null) } return _.raycaster.camera ? _.raycaster.intersectObject(A, !0) : [] } let y = m.flatMap(v).sort((A, _) => { const w = Uc(A.object), S = Uc(_.object); return !w || !S ? A.distance - _.distance : S.events.priority - w.events.priority || A.distance - _.distance }).filter(A => { const _ = Fp(A); return h.has(_) ? !1 : (h.add(_), !0) }); d.events.filter && (y = d.events.filter(y, d)); for (const A of y) { let _ = A.object; for (; _;) { var x; (x = _.__r3f) != null && x.eventCount && p.push({ ...A, eventObject: _ }), _ = _.parent } } if ("pointerId" in l && d.internal.capturedMap.has(l.pointerId)) for (let A of d.internal.capturedMap.get(l.pointerId).values()) h.has(Fp(A.intersection)) || p.push(A.intersection); return p } function r(l, f, d, h) { const p = n.getState(); if (l.length) { const m = { stopped: !1 }; for (const v of l) { const y = Uc(v.object) || p, { raycaster: x, pointer: A, camera: _, internal: w } = y, S = new I(A.x, A.y, 0).unproject(_), T = L => { var U, q; return (U = (q = w.capturedMap.get(L)) == null ? void 0 : q.has(v.eventObject)) != null ? U : !1 }, P = L => { const U = { intersection: v, target: f.target }; w.capturedMap.has(L) ? w.capturedMap.get(L).set(v.eventObject, U) : w.capturedMap.set(L, new Map([[v.eventObject, U]])), f.target.setPointerCapture(L) }, R = L => { const U = w.capturedMap.get(L); U && M3(w.capturedMap, v.eventObject, U, L) }; let E = {}; for (let L in f) { let U = f[L]; typeof U != "function" && (E[L] = U) } let B = { ...v, ...E, pointer: A, intersections: l, stopped: m.stopped, delta: d, unprojectedPoint: S, ray: x.ray, camera: _, stopPropagation() { const L = "pointerId" in f && w.capturedMap.get(f.pointerId); if ((!L || L.has(v.eventObject)) && (B.stopped = m.stopped = !0, w.hovered.size && Array.from(w.hovered.values()).find(U => U.eventObject === v.eventObject))) { const U = l.slice(0, l.indexOf(v)); s([...U, v]) } }, target: { hasPointerCapture: T, setPointerCapture: P, releasePointerCapture: R }, currentTarget: { hasPointerCapture: T, setPointerCapture: P, releasePointerCapture: R }, nativeEvent: f }; if (h(B), m.stopped === !0) break } } return l } function s(l) { const { internal: f } = n.getState(); for (const d of f.hovered.values()) if (!l.length || !l.find(h => h.object === d.object && h.index === d.index && h.instanceId === d.instanceId)) { const p = d.eventObject.__r3f, m = p == null ? void 0 : p.handlers; if (f.hovered.delete(Fp(d)), p != null && p.eventCount) { const v = { ...d, intersections: l }; m.onPointerOut == null || m.onPointerOut(v), m.onPointerLeave == null || m.onPointerLeave(v) } } } function o(l, f) { for (let d = 0; d < f.length; d++) { const h = f[d].__r3f; h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l) } } function a(l) { switch (l) { case "onPointerLeave": case "onPointerCancel": return () => s([]); case "onLostPointerCapture": return f => { const { internal: d } = n.getState(); "pointerId" in f && d.capturedMap.has(f.pointerId) && (d.capturedMap.delete(f.pointerId), s([])) } }return function (d) { const { onPointerMissed: h, internal: p } = n.getState(); p.lastEvent.current = d; const m = l === "onPointerMove", v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", x = i(d, m ? t : void 0), A = v ? e(d) : 0; l === "onPointerDown" && (p.initialClick = [d.offsetX, d.offsetY], p.initialHits = x.map(w => w.eventObject)), v && !x.length && A <= 2 && (o(d, p.interaction), h && h(d)), m && s(x); function _(w) { const S = w.eventObject, T = S.__r3f, P = T == null ? void 0 : T.handlers; if (T != null && T.eventCount) if (m) { if (P.onPointerOver || P.onPointerEnter || P.onPointerOut || P.onPointerLeave) { const R = Fp(w), E = p.hovered.get(R); E ? E.stopped && w.stopPropagation() : (p.hovered.set(R, w), P.onPointerOver == null || P.onPointerOver(w), P.onPointerEnter == null || P.onPointerEnter(w)) } P.onPointerMove == null || P.onPointerMove(w) } else { const R = P[l]; R ? (!v || p.initialHits.includes(S)) && (o(d, p.interaction.filter(E => !p.initialHits.includes(E))), R(w)) : v && p.initialHits.includes(S) && o(d, p.interaction.filter(E => !p.initialHits.includes(E))) } } r(x, d, A, _) } } return { handlePointer: a } } let c1 = {}, p5 = n => void (c1 = { ...c1, ...n }); function m5(n, e) { function t(d, { args: h = [], attach: p, ...m }, v) { let y = `${d[0].toUpperCase()}${d.slice(1)}`, x; if (d === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const A = m.object; x = jl(A, { type: d, root: v, attach: p, primitive: !0 }) } else { const A = c1[y]; if (!A) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(h)) throw new Error("R3F: The args prop must be an array!"); x = jl(new A(...h), { type: d, root: v, attach: p, memoizedProps: { args: h } }) } return x.__r3f.attach === void 0 && (x instanceof ut ? x.__r3f.attach = "geometry" : x instanceof Mn && (x.__r3f.attach = "material")), y !== "inject" && iv(x, m), x } function i(d, h) { let p = !1; if (h) { var m, v; (m = h.__r3f) != null && m.attach ? nv(d, h, h.__r3f.attach) : h.isObject3D && d.isObject3D && (d.add(h), p = !0), p || (v = d.__r3f) == null || v.objects.push(h), h.__r3f || jl(h, {}), h.__r3f.parent = d, u1(h), Jl(h) } } function r(d, h, p) { let m = !1; if (h) { var v, y; if ((v = h.__r3f) != null && v.attach) nv(d, h, h.__r3f.attach); else if (h.isObject3D && d.isObject3D) { h.parent = d, h.dispatchEvent({ type: "added" }); const x = d.children.filter(_ => _ !== h), A = x.indexOf(p); d.children = [...x.slice(0, A), h, ...x.slice(A)], m = !0 } m || (y = d.__r3f) == null || y.objects.push(h), h.__r3f || jl(h, {}), h.__r3f.parent = d, u1(h), Jl(h) } } function s(d, h, p = !1) { d && [...d].forEach(m => o(h, m, p)) } function o(d, h, p) { if (h) { var m, v, y; if (h.__r3f && (h.__r3f.parent = null), (m = d.__r3f) != null && m.objects && (d.__r3f.objects = d.__r3f.objects.filter(S => S !== h)), (v = h.__r3f) != null && v.attach) EE(d, h, h.__r3f.attach); else if (h.isObject3D && d.isObject3D) { var x; d.remove(h), (x = h.__r3f) != null && x.root && d5(h.__r3f.root, h) } const _ = (y = h.__r3f) == null ? void 0 : y.primitive, w = p === void 0 ? h.dispose !== null && !_ : p; if (!_) { var A; s((A = h.__r3f) == null ? void 0 : A.objects, h, w), s(h.children, h, w) } h.__r3f && (delete h.__r3f.root, delete h.__r3f.objects, delete h.__r3f.handlers, delete h.__r3f.memoizedProps, _ || delete h.__r3f), w && h.dispose && h.type !== "Scene" && Zf.unstable_scheduleCallback(Zf.unstable_IdlePriority, () => { try { h.dispose() } catch { } }), Jl(d) } } function a(d, h, p, m) { var v; const y = (v = d.__r3f) == null ? void 0 : v.parent; if (!y) return; const x = t(h, p, d.__r3f.root); if (d.children) { for (const A of d.children) A.__r3f && i(x, A); d.children = d.children.filter(A => !A.__r3f) } d.__r3f.objects.forEach(A => i(x, A)), d.__r3f.objects = [], d.__r3f.autoRemovedBeforeAppend || o(y, d), x.parent && (x.__r3f.autoRemovedBeforeAppend = !0), i(y, x), x.raycast && x.__r3f.eventCount && x.__r3f.root.getState().internal.interaction.push(x), [m, m.alternate].forEach(A => { A !== null && (A.stateNode = x, A.ref && (typeof A.ref == "function" ? A.ref(x) : A.ref.current = x)) }) } const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."); return { reconciler: e5({ createInstance: t, removeChild: o, appendChild: i, appendInitialChild: i, insertBefore: r, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (d, h) => { if (!h) return; const p = d.getState().scene; p.__r3f && (p.__r3f.root = d, i(p, h)) }, removeChildFromContainer: (d, h) => { h && o(d.getState().scene, h) }, insertInContainerBefore: (d, h, p) => { if (!h || !p) return; const m = d.getState().scene; m.__r3f && r(m, h, p) }, getRootHostContext: () => null, getChildHostContext: d => d, finalizeInitialChildren(d) { var h; const p = (h = d == null ? void 0 : d.__r3f) != null ? h : {}; return Boolean(p.handlers) }, prepareUpdate(d, h, p, m) { if (d.__r3f.primitive && m.object && m.object !== d) return [!0]; { const { args: v = [], children: y, ...x } = m, { args: A = [], children: _, ...w } = p; if (!Array.isArray(v)) throw new Error("R3F: the args prop must be an array!"); if (v.some((T, P) => T !== A[P])) return [!0]; const S = _3(d, x, w, !0); return S.changes.length ? [!1, S] : null } }, commitUpdate(d, [h, p], m, v, y, x) { h ? a(d, m, y, x) : iv(d, p) }, commitMount(d, h, p, m) { var v; const y = (v = d.__r3f) != null ? v : {}; d.raycast && y.handlers && y.eventCount && d.__r3f.root.getState().internal.interaction.push(d) }, getPublicInstance: d => d, prepareForCommit: () => null, preparePortalMount: d => jl(d.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(d) { var h; const { attach: p, parent: m } = (h = d.__r3f) != null ? h : {}; p && m && EE(m, d, p), d.isObject3D && (d.visible = !1), Jl(d) }, unhideInstance(d, h) { var p; const { attach: m, parent: v } = (p = d.__r3f) != null ? p : {}; m && v && nv(v, d, m), (d.isObject3D && h.visible == null || h.visible) && (d.visible = !0), Jl(d) }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : wo.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && qt.fun(performance.now) ? performance.now : qt.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: qt.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: qt.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: iv } } const w3 = n => !!(n != null && n.render), S3 = z.createContext(null), g5 = (n, e) => { const t = d3((a, l) => { const f = new I, d = new I, h = new I; function p(A = l().camera, _ = d, w = l().size) { const { width: S, height: T, top: P, left: R } = w, E = S / T; _ instanceof I ? h.copy(_) : h.set(..._); const B = A.getWorldPosition(f).distanceTo(h); if (g3(A)) return { width: S / A.zoom, height: T / A.zoom, top: P, left: R, factor: 1, distance: B, aspect: E }; { const L = A.fov * Math.PI / 180, U = 2 * Math.tan(L / 2) * B, q = U * (S / T); return { width: q, height: U, top: P, left: R, factor: S / q, distance: B, aspect: E } } } let m; const v = A => a(_ => ({ performance: { ..._.performance, current: A } })), y = new pe; return { set: a, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, invalidate: (A = 1) => n(l(), A), advance: (A, _) => e(A, _, l()), legacy: !1, linear: !1, flat: !1, scene: jl(new QA), controls: null, clock: new v_, pointer: y, mouse: y, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const A = l(); m && clearTimeout(m), A.performance.current !== A.performance.min && v(A.performance.min), m = setTimeout(() => v(l().performance.max), A.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: A => a(_ => ({ ..._, events: { ..._.events, ...A } })), setSize: (A, _, w, S, T) => { const P = l().camera, R = { width: A, height: _, top: S || 0, left: T || 0, updateStyle: w }; a(E => ({ size: R, viewport: { ...E.viewport, ...p(P, d, R) } })) }, setDpr: A => a(_ => { const w = A3(A); return { viewport: { ..._.viewport, dpr: w, initialDpr: _.viewport.initialDpr || w } } }), setFrameloop: (A = "always") => { const _ = l().clock; _.stop(), _.elapsedTime = 0, A !== "never" && (_.start(), _.elapsedTime = 0), a(() => ({ frameloop: A })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: z.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (A, _, w) => { const S = l().internal; return S.priority = S.priority + (_ > 0 ? 1 : 0), S.subscribers.push({ ref: A, priority: _, store: w }), S.subscribers = S.subscribers.sort((T, P) => T.priority - P.priority), () => { const T = l().internal; T != null && T.subscribers && (T.priority = T.priority - (_ > 0 ? 1 : 0), T.subscribers = T.subscribers.filter(P => P.ref !== A)) } } } } }), i = t.getState(); let r = i.size, s = i.viewport.dpr, o = i.camera; return t.subscribe(() => { const { camera: a, size: l, viewport: f, gl: d, set: h } = t.getState(); if (l !== r || f.dpr !== s) { var p; r = l, s = f.dpr, c5(a, l), d.setPixelRatio(f.dpr); const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && d.domElement instanceof HTMLCanvasElement; d.setSize(l.width, l.height, m) } a !== o && (o = a, h(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) } }))) }), t.subscribe(a => n(a)), t }; let Np, y5 = new Set, v5 = new Set, x5 = new Set; function rv(n, e) { if (n.size) for (const { callback: t } of n.values()) t(e) } function zc(n, e) { switch (n) { case "before": return rv(y5, e); case "after": return rv(v5, e); case "tail": return rv(x5, e) } } let sv, ov; function av(n, e, t) { let i = e.clock.getDelta(); for (e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), sv = e.internal.subscribers, Np = 0; Np < sv.length; Np++)ov = sv[Np], ov.ref.current(ov.store.getState(), i, t); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function A5(n) { let e = !1, t, i, r; function s(l) { i = requestAnimationFrame(s), e = !0, t = 0, zc("before", l); for (const d of n.values()) { var f; r = d.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((f = r.gl.xr) != null && f.isPresenting) && (t += av(l, r)) } if (zc("after", l), t === 0) return zc("tail", l), e = !1, cancelAnimationFrame(i) } function o(l, f = 1) { var d; if (!l) return n.forEach(h => o(h.store.getState()), f); (d = l.gl.xr) != null && d.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + f), e || (e = !0, requestAnimationFrame(s))) } function a(l, f = !0, d, h) { if (f && zc("before", l), d) av(l, d, h); else for (const p of n.values()) av(l, p.store.getState()); f && zc("after", l) } return { loop: s, invalidate: o, advance: a } } function C3() { const n = z.useContext(S3); if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return n } function Fi(n = t => t, e) { return C3()(n, e) } function Zu(n, e = 0) { const t = C3(), i = t.getState().internal.subscribe, r = y3(n); return Rd(() => i(r, e, t), [e, i, t]), null } function E3(n, e) { return function (t, ...i) { const r = new t; return n && n(r), Promise.all(i.map(s => new Promise((o, a) => r.load(s, l => { l.scene && Object.assign(l, l5(l.scene)), o(l) }, e, l => a(new Error(`Could not load ${s}: ${l.message})`)))))) } } function Zo(n, e, t, i) { const r = Array.isArray(e) ? e : [e], s = t5(E3(t, i), [n, ...r], { equal: qt.equ }); return Array.isArray(e) ? s : s[0] } Zo.preload = function (n, e, t) { const i = Array.isArray(e) ? e : [e]; return n5(E3(t), [n, ...i]) }; Zo.clear = function (n, e) { const t = Array.isArray(e) ? e : [e]; return i5([n, ...t]) }; const Ou = new Map, { invalidate: TE, advance: bE } = A5(Ou), { reconciler: Hm, applyProps: So } = m5(Ou, f5), Gc = { objects: "shallow", strict: !1 }, _5 = (n, e) => { const t = typeof n == "function" ? n(e) : n; return w3(t) ? t : new KA({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...n }) }; function M5(n, e) { if (e) return e; if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) { const { width: t, height: i, top: r, left: s } = n.parentElement.getBoundingClientRect(); return { width: t, height: i, top: r, left: s } } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return { width: n.width, height: n.height, top: 0, left: 0 }; return { width: 0, height: 0, top: 0, left: 0 } } function w5(n) { const e = Ou.get(n), t = e == null ? void 0 : e.fiber, i = e == null ? void 0 : e.store; e && console.warn("R3F.createRoot should only be called once!"); const r = typeof reportError == "function" ? reportError : console.error, s = i || g5(TE, bE), o = t || Hm.createContainer(s, wo.ConcurrentRoot, null, !1, null, "", r, null); e || Ou.set(n, { fiber: o, store: s }); let a, l = !1; return { configure(f = {}) { let { gl: d, size: h, events: p, onCreated: m, shadows: v = !1, linear: y = !1, flat: x = !1, legacy: A = !1, orthographic: _ = !1, frameloop: w = "always", dpr: S = [1, 2], performance: T, raycaster: P, camera: R, onPointerMissed: E } = f, B = s.getState(), L = B.gl; B.gl || B.set({ gl: L = _5(d, n) }); let U = B.raycaster; U || B.set({ raycaster: U = new c3 }); const { params: q, ...W } = P || {}; if (qt.equ(W, U, Gc) || So(U, { ...W }), qt.equ(q, U.params, Gc) || So(U, { params: { ...U.params, ...q } }), !B.camera) { const N = R instanceof hd, V = N ? R : _ ? new Ir(0, 0, 0, 0, .1, 1e3) : new Gt(75, 0, .1, 1e3); N || (V.position.z = 5, R && So(V, R), R != null && R.rotation || V.lookAt(0, 0, 0)), B.set({ camera: V }) } if (!B.xr) { const N = (re, j) => { const ie = s.getState(); ie.frameloop !== "never" && bE(re, !0, ie, j) }, V = () => { const re = s.getState(); re.gl.xr.enabled = re.gl.xr.isPresenting, re.gl.xr.setAnimationLoop(re.gl.xr.isPresenting ? N : null), re.gl.xr.isPresenting || TE(re) }, Y = { connect() { const re = s.getState().gl; re.xr.addEventListener("sessionstart", V), re.xr.addEventListener("sessionend", V) }, disconnect() { const re = s.getState().gl; re.xr.removeEventListener("sessionstart", V), re.xr.removeEventListener("sessionend", V) } }; L.xr && Y.connect(), B.set({ xr: Y }) } if (L.shadowMap) { const N = L.shadowMap.enabled, V = L.shadowMap.type; if (L.shadowMap.enabled = !!v, qt.boo(v)) L.shadowMap.type = ff; else if (qt.str(v)) { var G; const Y = { basic: AP, percentage: vg, soft: ff, variance: Da }; L.shadowMap.type = (G = Y[v]) != null ? G : ff } else qt.obj(v) && Object.assign(L.shadowMap, v); (N !== L.shadowMap.enabled || V !== L.shadowMap.type) && (L.shadowMap.needsUpdate = !0) } Wl && ("enabled" in Wl ? Wl.enabled = !A : "legacyMode" in Wl && (Wl.legacyMode = A)); const K = y ? Vs : Ct, ne = x ? Dr : IA; L.outputEncoding !== K && (L.outputEncoding = K), L.toneMapping !== ne && (L.toneMapping = ne), B.legacy !== A && B.set(() => ({ legacy: A })), B.linear !== y && B.set(() => ({ linear: y })), B.flat !== x && B.set(() => ({ flat: x })), d && !qt.fun(d) && !w3(d) && !qt.equ(d, L, Gc) && So(L, d), p && !B.events.handlers && B.set({ events: p(s) }); const oe = M5(n, h); return qt.equ(oe, B.size, Gc) || B.setSize(oe.width, oe.height, oe.updateStyle, oe.top, oe.left), S && B.viewport.dpr !== A3(S) && B.setDpr(S), B.frameloop !== w && B.setFrameloop(w), B.onPointerMissed || B.set({ onPointerMissed: E }), T && !qt.equ(T, B.performance, Gc) && B.set(N => ({ performance: { ...N.performance, ...T } })), a = m, l = !0, this }, render(f) { return l || this.configure(), Hm.updateContainer(z.createElement(S5, { store: s, children: f, onCreated: a, rootElement: n }), o, null, () => { }), s }, unmount() { T3(n) } } } function S5({ store: n, children: e, onCreated: t, rootElement: i }) { return Rd(() => { const r = n.getState(); r.set(s => ({ internal: { ...s.internal, active: !0 } })), t && t(r), n.getState().events.connected || r.events.connect == null || r.events.connect(i) }, []), z.createElement(S3.Provider, { value: n }, e) } function T3(n, e) { const t = Ou.get(n), i = t == null ? void 0 : t.fiber; if (i) { const r = t == null ? void 0 : t.store.getState(); r && (r.internal.active = !1), Hm.updateContainer(null, i, null, () => { r && setTimeout(() => { try { var s, o, a, l; r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = r.gl) != null && l.xr && r.xr.disconnect(), u5(r), Ou.delete(n), e && e(n) } catch { } }, 500) }) } } Hm.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: z.version }); function mr() { return mr = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, mr.apply(this, arguments) } function f1(n, e, t) { var i, r, s, o, a; e == null && (e = 100); function l() { var d = Date.now() - o; d < e && d >= 0 ? i = setTimeout(l, e - d) : (i = null, t || (a = n.apply(s, r), s = r = null)) } var f = function () { s = this, r = arguments, o = Date.now(); var d = t && !i; return i || (i = setTimeout(l, e)), d && (a = n.apply(s, r), s = r = null), a }; return f.clear = function () { i && (clearTimeout(i), i = null) }, f.flush = function () { i && (a = n.apply(s, r), s = r = null, clearTimeout(i), i = null) }, f } f1.debounce = f1; var PE = f1; function C5(n) { let { debounce: e, scroll: t, polyfill: i, offsetSize: r } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n; const s = i || (typeof window > "u" ? class { } : window.ResizeObserver); if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [o, a] = z.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = z.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: o }), f = e ? typeof e == "number" ? e : e.scroll : null, d = e ? typeof e == "number" ? e : e.resize : null, h = z.useRef(!1); z.useEffect(() => (h.current = !0, () => void (h.current = !1))); const [p, m, v] = z.useMemo(() => { const _ = () => { if (!l.current.element) return; const { left: w, top: S, width: T, height: P, bottom: R, right: E, x: B, y: L } = l.current.element.getBoundingClientRect(), U = { left: w, top: S, width: T, height: P, bottom: R, right: E, x: B, y: L }; l.current.element instanceof HTMLElement && r && (U.height = l.current.element.offsetHeight, U.width = l.current.element.offsetWidth), Object.freeze(U), h.current && !P5(l.current.lastBounds, U) && a(l.current.lastBounds = U) }; return [_, d ? PE(_, d) : _, f ? PE(_, f) : _] }, [a, r, f, d]); function y() { l.current.scrollContainers && (l.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", v, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null) } function x() { l.current.element && (l.current.resizeObserver = new s(v), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(_ => _.addEventListener("scroll", v, { capture: !0, passive: !0 }))) } const A = _ => { !_ || _ === l.current.element || (y(), l.current.element = _, l.current.scrollContainers = b3(_), x()) }; return T5(v, Boolean(t)), E5(m), z.useEffect(() => { y(), x() }, [t, v, m]), z.useEffect(() => y, []), [A, o, p] } function E5(n) { z.useEffect(() => { const e = n; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [n]) } function T5(n, e) { z.useEffect(() => { if (e) { const t = n; return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0) } }, [n, e]) } function b3(n) { const e = []; if (!n || n === document.body) return e; const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n); return [t, i, r].some(s => s === "auto" || s === "scroll") && e.push(n), [...e, ...b3(n.parentElement)] } const b5 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], P5 = (n, e) => b5.every(t => n[t] === e[t]); var B5 = Object.defineProperty, R5 = Object.defineProperties, L5 = Object.getOwnPropertyDescriptors, BE = Object.getOwnPropertySymbols, D5 = Object.prototype.hasOwnProperty, I5 = Object.prototype.propertyIsEnumerable, RE = (n, e, t) => e in n ? B5(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, LE = (n, e) => { for (var t in e || (e = {})) D5.call(e, t) && RE(n, t, e[t]); if (BE) for (var t of BE(e)) I5.call(e, t) && RE(n, t, e[t]); return n }, F5 = (n, e) => R5(n, L5(e)); function P3(n, e, t) { if (!n) return; if (t(n) === !0) return n; let i = e ? n.return : n.child; for (; i;) { const r = P3(i, e, t); if (r) return r; i = e ? null : i.sibling } } function B3(n) { try { return Object.defineProperties(n, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return n } } const M_ = B3(z.createContext(null)); class R3 extends z.Component { render() { return z.createElement(M_.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: N5, ReactCurrentDispatcher: O5 } = z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; function k5() { const n = z.useContext(M_); if (!n) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const e = z.useId(); return z.useMemo(() => { var i; return (i = N5.current) != null ? i : P3(n, !1, r => { let s = r.memoizedState; for (; s;) { if (s.memoizedState === e) return !0; s = s.next } }) }, [n, e]) } function U5() { var n, e; const t = k5(), [i] = z.useState(() => new Map); i.clear(); let r = t; for (; r;) { const s = (n = r.type) == null ? void 0 : n._context; s && s !== M_ && !i.has(s) && i.set(s, (e = O5.current) == null ? void 0 : e.readContext(B3(s))), r = r.return } return z.useMemo(() => Array.from(i.keys()).reduce((s, o) => a => z.createElement(s, null, z.createElement(o.Provider, F5(LE({}, a), { value: i.get(o) }))), s => z.createElement(R3, LE({}, s))), [i]) } const lv = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function z5(n) { const { handlePointer: e } = h5(n); return { priority: 1, enabled: !0, compute(t, i, r) { i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera) }, connected: void 0, handlers: Object.keys(lv).reduce((t, i) => ({ ...t, [i]: e(i) }), {}), update: () => { var t; const { events: i, internal: r } = n.getState(); (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current) }, connect: t => { var i; const { set: r, events: s } = n.getState(); s.disconnect == null || s.disconnect(), r(o => ({ events: { ...o.events, connected: t } })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => { const [l, f] = lv[o]; t.addEventListener(l, a, { passive: f }) }) }, disconnect: () => { const { set: t, events: i } = n.getState(); if (i.connected) { var r; Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => { if (i && i.connected instanceof HTMLElement) { const [a] = lv[s]; i.connected.removeEventListener(a, o) } }), t(s => ({ events: { ...s.events, connected: void 0 } })) } } } } const G5 = z.forwardRef(function ({ children: e, fallback: t, resize: i, style: r, gl: s, events: o = z5, eventSource: a, eventPrefix: l, shadows: f, linear: d, flat: h, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: x, raycaster: A, camera: _, onPointerMissed: w, onCreated: S, ...T }, P) { z.useMemo(() => p5(o1), []); const R = U5(), [E, B] = C5({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }), L = z.useRef(null), U = z.useRef(null), [q, W] = z.useState(null); z.useImperativeHandle(P, () => L.current); const G = y3(w), [K, ne] = z.useState(!1), [oe, N] = z.useState(!1); if (K) throw K; if (oe) throw oe; const V = z.useRef(null); B.width > 0 && B.height > 0 && q && (V.current || (V.current = w5(q)), V.current.configure({ gl: s, events: o, shadows: f, linear: d, flat: h, legacy: p, orthographic: m, frameloop: v, dpr: y, performance: x, raycaster: A, camera: _, size: B, onPointerMissed: (...re) => G.current == null ? void 0 : G.current(...re), onCreated: re => { re.events.connect == null || re.events.connect(a ? s5(a) ? a.current : a : U.current), l && re.setEvents({ compute: (j, ie) => { const ve = j[l + "X"], Ae = j[l + "Y"]; ie.pointer.set(ve / ie.size.width * 2 - 1, -(Ae / ie.size.height) * 2 + 1), ie.raycaster.setFromCamera(ie.pointer, ie.camera) } }), S == null || S(re) } }), V.current.render(z.createElement(R, null, z.createElement(v3, { set: N }, z.createElement(z.Suspense, { fallback: z.createElement(o5, { set: ne }) }, e))))), Rd(() => { W(L.current) }, []), z.useEffect(() => { if (q) return () => T3(q) }, [q]); const Y = a ? "none" : "auto"; return z.createElement("div", mr({ ref: U, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: Y, ...r } }, T), z.createElement("div", { ref: E, style: { width: "100%", height: "100%" } }, z.createElement("canvas", { ref: L, style: { display: "block" } }, t))) }), w_ = z.forwardRef(function (e, t) { return z.createElement(R3, null, z.createElement(G5, mr({}, e, { ref: t }))) }), Ld = new I, S_ = new I, H5 = new I; function V5(n, e, t) { const i = Ld.setFromMatrixPosition(n.matrixWorld); i.project(e); const r = t.width / 2, s = t.height / 2; return [i.x * r + r, -(i.y * s) + s] } function W5(n, e) { const t = Ld.setFromMatrixPosition(n.matrixWorld), i = S_.setFromMatrixPosition(e.matrixWorld), r = t.sub(i), s = e.getWorldDirection(H5); return r.angleTo(s) > Math.PI / 2 } function j5(n, e, t, i) { const r = Ld.setFromMatrixPosition(n.matrixWorld), s = r.clone(); s.project(e), t.setFromCamera(s, e); const o = t.intersectObjects(i, !0); if (o.length) { const a = o[0].distance; return r.distanceTo(t.ray.origin) < a } return !0 } function J5(n, e) { if (e instanceof Ir) return e.zoom; if (e instanceof Gt) { const t = Ld.setFromMatrixPosition(n.matrixWorld), i = S_.setFromMatrixPosition(e.matrixWorld), r = e.fov * Math.PI / 180, s = t.distanceTo(i); return 1 / (2 * Math.tan(r / 2) * s) } else return 1 } function X5(n, e, t) { if (e instanceof Gt || e instanceof Ir) { const i = Ld.setFromMatrixPosition(n.matrixWorld), r = S_.setFromMatrixPosition(e.matrixWorld), s = i.distanceTo(r), o = (t[1] - t[0]) / (e.far - e.near), a = t[1] - o * e.far; return Math.round(o * s + a) } } const d1 = n => Math.abs(n) < 1e-10 ? 0 : n; function L3(n, e, t = "") { let i = "matrix3d("; for (let r = 0; r !== 16; r++)i += d1(e[r] * n.elements[r]) + (r !== 15 ? "," : ")"); return t + i } const Y5 = (n => e => L3(e, n))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), K5 = (n => (e, t) => L3(e, n(t), "translate(-50%,-50%)"))(n => [1 / n, 1 / n, 1 / n, 1, -1 / n, -1 / n, -1 / n, -1, 1 / n, 1 / n, 1 / n, 1, 1, 1, 1, 1]); function Q5(n) { return n && typeof n == "object" && "current" in n } const Z5 = z.forwardRef(({ children: n, eps: e = .001, style: t, className: i, prepend: r, center: s, fullscreen: o, portal: a, distanceFactor: l, sprite: f = !1, transform: d = !1, occlude: h, onOcclude: p, castShadow: m, receiveShadow: v, material: y, geometry: x, zIndexRange: A = [16777271, 0], calculatePosition: _ = V5, as: w = "div", wrapperClass: S, pointerEvents: T = "auto", ...P }, R) => {
	const { gl: E, camera: B, scene: L, size: U, raycaster: q, events: W, viewport: G } = Fi(), [K] = z.useState(() => document.createElement(w)), ne = z.useRef(), oe = z.useRef(null), N = z.useRef(0), V = z.useRef([0, 0]), Y = z.useRef(null), re = z.useRef(null), j = (a == null ? void 0 : a.current) || W.connected || E.domElement.parentNode, ie = z.useRef(null), ve = z.useRef(!1), Ae = z.useMemo(() => h && h !== "blending" || Array.isArray(h) && h.length && Q5(h[0]), [h]); z.useLayoutEffect(() => { const Me = E.domElement; h && h === "blending" ? (Me.style.zIndex = `${Math.floor(A[0] / 2)}`, Me.style.position = "absolute", Me.style.pointerEvents = "none") : (Me.style.zIndex = null, Me.style.position = null, Me.style.pointerEvents = null) }, [h]), z.useLayoutEffect(() => { if (oe.current) { const Me = ne.current = hP(K); if (L.updateMatrixWorld(), d) K.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"; else { const De = _(oe.current, B, U); K.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${De[0]}px,${De[1]}px,0);transform-origin:0 0;` } return j && (r ? j.prepend(K) : j.appendChild(K)), () => { j && j.removeChild(K), Me.unmount() } } }, [j, d]), z.useLayoutEffect(() => { S && (K.className = S) }, [S]); const $ = z.useMemo(() => d ? { position: "absolute", top: 0, left: 0, width: U.width, height: U.height, transformStyle: "preserve-3d", pointerEvents: "none" } : { position: "absolute", transform: s ? "translate3d(-50%,-50%,0)" : "none", ...o && { top: -U.height / 2, left: -U.width / 2, width: U.width, height: U.height }, ...t }, [t, s, o, U, d]), Oe = z.useMemo(() => ({ position: "absolute", pointerEvents: T }), [T]); z.useLayoutEffect(() => { if (ve.current = !1, d) { var Me; (Me = ne.current) == null || Me.render(z.createElement("div", { ref: Y, style: $ }, z.createElement("div", { ref: re, style: Oe }, z.createElement("div", { ref: R, className: i, style: t, children: n })))) } else { var De; (De = ne.current) == null || De.render(z.createElement("div", { ref: R, style: $, className: i, children: n })) } }); const ke = z.useRef(!0); Zu(Me => { if (oe.current) { B.updateMatrixWorld(), oe.current.updateWorldMatrix(!0, !1); const De = d ? V.current : _(oe.current, B, U); if (d || Math.abs(N.current - B.zoom) > e || Math.abs(V.current[0] - De[0]) > e || Math.abs(V.current[1] - De[1]) > e) { const de = W5(oe.current, B); let ae = !1; Ae && (h !== "blending" ? ae = [L] : Array.isArray(h) && (ae = h.map(Ze => Ze.current))); const Ce = ke.current; if (ae) { const Ze = j5(oe.current, B, q, ae); ke.current = Ze && !de } else ke.current = !de; Ce !== ke.current && (p ? p(!ke.current) : K.style.display = ke.current ? "block" : "none"); const ze = Math.floor(A[0] / 2), Be = h ? Ae ? [A[0], ze] : [ze - 1, 0] : A; if (K.style.zIndex = `${X5(oe.current, B, Be)}`, d) { const [Ze, Je] = [U.width / 2, U.height / 2], je = B.projectionMatrix.elements[5] * Je, { isOrthographicCamera: vt, top: wt, left: k, bottom: D, right: se } = B, we = Y5(B.matrixWorldInverse), Ee = vt ? `scale(${je})translate(${d1(-(se + k) / 2)}px,${d1((wt + D) / 2)}px)` : `translateZ(${je}px)`; let Pe = oe.current.matrixWorld; f && (Pe = B.matrixWorldInverse.clone().transpose().copyPosition(Pe).scale(oe.current.scale), Pe.elements[3] = Pe.elements[7] = Pe.elements[11] = 0, Pe.elements[15] = 1), K.style.width = U.width + "px", K.style.height = U.height + "px", K.style.perspective = vt ? "" : `${je}px`, Y.current && re.current && (Y.current.style.transform = `${Ee}${we}translate(${Ze}px,${Je}px)`, re.current.style.transform = K5(Pe, 1 / ((l || 10) / 400))) } else { const Ze = l === void 0 ? 1 : J5(oe.current, B) * l; K.style.transform = `translate3d(${De[0]}px,${De[1]}px,0) scale(${Ze})` } V.current = De, N.current = B.zoom } } if (!Ae && ie.current && !ve.current) if (d) { if (Y.current) { const De = Y.current.children[0]; if (De != null && De.clientWidth && De != null && De.clientHeight) { const { isOrthographicCamera: de } = B; if (de || x) P.scale && (Array.isArray(P.scale) ? P.scale instanceof I ? ie.current.scale.copy(P.scale.clone().divideScalar(1)) : ie.current.scale.set(1 / P.scale[0], 1 / P.scale[1], 1 / P.scale[2]) : ie.current.scale.setScalar(1 / P.scale)); else { const ae = (l || 10) / 400, Ce = De.clientWidth * ae, ze = De.clientHeight * ae; ie.current.scale.set(Ce, ze, 1) } ve.current = !0 } } } else { const De = K.children[0]; if (De != null && De.clientWidth && De != null && De.clientHeight) { const de = 1 / G.factor, ae = De.clientWidth * de, Ce = De.clientHeight * de; ie.current.scale.set(ae, Ce, 1), ve.current = !0 } ie.current.lookAt(Me.camera.position) } }); const He = z.useMemo(() => ({
		vertexShader: d ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `, fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}), [d]); return z.createElement("group", mr({}, P, { ref: oe }), h && !Ae && z.createElement("mesh", { castShadow: m, receiveShadow: v, ref: ie }, x || z.createElement("planeGeometry", null), y || z.createElement("shaderMaterial", { side: Br, vertexShader: He.vertexShader, fragmentShader: He.fragmentShader })))
}); let Hc = 0; const q5 = d3(n => (lu.onStart = (e, t, i) => { n({ active: !0, item: e, loaded: t, total: i, progress: (t - Hc) / (i - Hc) * 100 }) }, lu.onLoad = () => { n({ active: !1 }) }, lu.onError = e => n(t => ({ errors: [...t.errors, e] })), lu.onProgress = (e, t, i) => { t === i && (Hc = i), n({ active: !0, item: e, loaded: t, total: i, progress: (t - Hc) / (i - Hc) * 100 || 100 }) }, { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 })); function C_(n) { return function (e) { n.forEach(function (t) { typeof t == "function" ? t(e) : t != null && (t.current = e) }) } } function Au(n, e, t) { return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function DE(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(n); e && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(n, r).enumerable })), t.push.apply(t, i) } return t } function IE(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? DE(Object(t), !0).forEach(function (i) { Au(n, i, t[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : DE(Object(t)).forEach(function (i) { Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i)) }) } return n } new pe; new pe; function D3(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } var rr = function n(e, t, i) { var r = this; D3(this, n), Au(this, "dot2", function (s, o) { return r.x * s + r.y * o }), Au(this, "dot3", function (s, o, a) { return r.x * s + r.y * o + r.z * a }), this.x = e, this.y = t, this.z = i }, $5 = [new rr(1, 1, 0), new rr(-1, 1, 0), new rr(1, -1, 0), new rr(-1, -1, 0), new rr(1, 0, 1), new rr(-1, 0, 1), new rr(1, 0, -1), new rr(-1, 0, -1), new rr(0, 1, 1), new rr(0, -1, 1), new rr(0, 1, -1), new rr(0, -1, -1)], FE = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], NE = new Array(512), OE = new Array(512), eV = function (e) { e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8); for (var t = 0; t < 256; t++) { var i; t & 1 ? i = FE[t] ^ e & 255 : i = FE[t] ^ e >> 8 & 255, NE[t] = NE[t + 256] = i, OE[t] = OE[t + 256] = $5[i % 12] } }; eV(0); function tV(n) { if (typeof n == "number") n = Math.abs(n); else if (typeof n == "string") { var e = n; n = 0; for (var t = 0; t < e.length; t++)n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647 } return n === 0 && (n = 311), n } function kE(n) { var e = tV(n); return function () { var t = e * 48271 % 2147483647; return e = t, t / 2147483647 } } var nV = function n(e) { var t = this; D3(this, n), Au(this, "seed", 0), Au(this, "init", function (i) { t.seed = i, t.value = kE(i) }), Au(this, "value", kE(this.seed)), this.init(e) }, iV = new nV(Math.random()), rV = { radius: 1, center: [0, 0, 0] }; function sV(n, e) { for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : iV, i = IE(IE({}, rV), e), r = i.radius, s = i.center, o = 0; o < n.length; o += 3) { var a = Math.pow(t.value(), .3333333333333333), l = t.value() * 2 - 1, f = t.value() * 2 - 1, d = t.value() * 2 - 1, h = Math.sqrt(l * l + f * f + d * d); l = a * l / h, f = a * f / h, d = a * d / h, n[o] = l * r + s[0], n[o + 1] = f * r + s[1], n[o + 2] = d * r + s[2] } return n } function qf(n) { return qf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, qf(n) } function oV(n, e) { if (qf(n) !== "object" || n === null) return n; var t = n[Symbol.toPrimitive]; if (t !== void 0) { var i = t.call(n, e || "default"); if (qf(i) !== "object") return i; throw new TypeError("@@toPrimitive must return a primitive value.") } return (e === "string" ? String : Number)(n) } function aV(n) { var e = oV(n, "string"); return qf(e) === "symbol" ? e : String(e) } function lt(n, e, t) { return e = aV(e), e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } const UE = (n, e) => (n % e + e) % e; let lV = class extends os { constructor(e, t) { super(), lt(this, "object", void 0), lt(this, "domElement", void 0), lt(this, "enabled", !0), lt(this, "target", new I), lt(this, "minDistance", 0), lt(this, "maxDistance", 1 / 0), lt(this, "minZoom", 0), lt(this, "maxZoom", 1 / 0), lt(this, "minPolarAngle", 0), lt(this, "maxPolarAngle", Math.PI), lt(this, "minAzimuthAngle", -1 / 0), lt(this, "maxAzimuthAngle", 1 / 0), lt(this, "enableDamping", !1), lt(this, "dampingFactor", .05), lt(this, "enableZoom", !0), lt(this, "zoomSpeed", 1), lt(this, "enableRotate", !0), lt(this, "rotateSpeed", 1), lt(this, "enablePan", !0), lt(this, "panSpeed", 1), lt(this, "screenSpacePanning", !0), lt(this, "keyPanSpeed", 7), lt(this, "autoRotate", !1), lt(this, "autoRotateSpeed", 2), lt(this, "reverseOrbit", !1), lt(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), lt(this, "mouseButtons", { LEFT: _a.ROTATE, MIDDLE: _a.DOLLY, RIGHT: _a.PAN }), lt(this, "touches", { ONE: Ma.ROTATE, TWO: Ma.DOLLY_PAN }), lt(this, "target0", void 0), lt(this, "position0", void 0), lt(this, "zoom0", void 0), lt(this, "_domElementKeyEvents", null), lt(this, "getPolarAngle", void 0), lt(this, "getAzimuthalAngle", void 0), lt(this, "setPolarAngle", void 0), lt(this, "setAzimuthalAngle", void 0), lt(this, "getDistance", void 0), lt(this, "listenToKeyEvents", void 0), lt(this, "saveState", void 0), lt(this, "reset", void 0), lt(this, "update", void 0), lt(this, "connect", void 0), lt(this, "dispose", void 0), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof Gt ? this.object.zoom : 1, this.getPolarAngle = () => d.phi, this.getAzimuthalAngle = () => d.theta, this.setPolarAngle = H => { let le = UE(H, 2 * Math.PI), _e = d.phi; _e < 0 && (_e += 2 * Math.PI), le < 0 && (le += 2 * Math.PI); let be = Math.abs(le - _e); 2 * Math.PI - be < be && (le < _e ? le += 2 * Math.PI : _e += 2 * Math.PI), h.phi = le - _e, i.update() }, this.setAzimuthalAngle = H => { let le = UE(H, 2 * Math.PI), _e = d.theta; _e < 0 && (_e += 2 * Math.PI), le < 0 && (le += 2 * Math.PI); let be = Math.abs(le - _e); 2 * Math.PI - be < be && (le < _e ? le += 2 * Math.PI : _e += 2 * Math.PI), h.theta = le - _e, i.update() }, this.getDistance = () => i.object.position.distanceTo(i.target), this.listenToKeyEvents = H => { H.addEventListener("keydown", se), this._domElementKeyEvents = H }, this.saveState = () => { i.target0.copy(i.target), i.position0.copy(i.object.position), i.zoom0 = i.object instanceof Gt ? i.object.zoom : 1 }, this.reset = () => { i.target.copy(i.target0), i.object.position.copy(i.position0), i.object instanceof Gt && (i.object.zoom = i.zoom0, i.object.updateProjectionMatrix()), i.dispatchEvent(r), i.update(), l = a.NONE }, this.update = (() => { const H = new I, le = new Hn().setFromUnitVectors(e.up, new I(0, 1, 0)), _e = le.clone().invert(), be = new I, $e = new Hn, yt = 2 * Math.PI; return function () { const X = i.object.position; H.copy(X).sub(i.target), H.applyQuaternion(le), d.setFromVector3(H), i.autoRotate && l === a.NONE && q(L()), i.enableDamping ? (d.theta += h.theta * i.dampingFactor, d.phi += h.phi * i.dampingFactor) : (d.theta += h.theta, d.phi += h.phi); let ce = i.minAzimuthAngle, xe = i.maxAzimuthAngle; return isFinite(ce) && isFinite(xe) && (ce < -Math.PI ? ce += yt : ce > Math.PI && (ce -= yt), xe < -Math.PI ? xe += yt : xe > Math.PI && (xe -= yt), ce <= xe ? d.theta = Math.max(ce, Math.min(xe, d.theta)) : d.theta = d.theta > (ce + xe) / 2 ? Math.max(ce, d.theta) : Math.min(xe, d.theta)), d.phi = Math.max(i.minPolarAngle, Math.min(i.maxPolarAngle, d.phi)), d.makeSafe(), d.radius *= p, d.radius = Math.max(i.minDistance, Math.min(i.maxDistance, d.radius)), i.enableDamping === !0 ? i.target.addScaledVector(m, i.dampingFactor) : i.target.add(m), H.setFromSpherical(d), H.applyQuaternion(_e), X.copy(i.target).add(H), i.object.lookAt(i.target), i.enableDamping === !0 ? (h.theta *= 1 - i.dampingFactor, h.phi *= 1 - i.dampingFactor, m.multiplyScalar(1 - i.dampingFactor)) : (h.set(0, 0, 0), m.set(0, 0, 0)), p = 1, v || be.distanceToSquared(i.object.position) > f || 8 * (1 - $e.dot(i.object.quaternion)) > f ? (i.dispatchEvent(r), be.copy(i.object.position), $e.copy(i.object.quaternion), v = !1, !0) : !1 } })(), this.connect = H => { H === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), i.domElement = H, i.domElement.style.touchAction = "none", i.domElement.addEventListener("contextmenu", Pe), i.domElement.addEventListener("pointerdown", Ze), i.domElement.addEventListener("pointercancel", vt), i.domElement.addEventListener("wheel", D) }, this.dispose = () => { var H, le, _e, be, $e, yt; (H = i.domElement) === null || H === void 0 || H.removeEventListener("contextmenu", Pe), (le = i.domElement) === null || le === void 0 || le.removeEventListener("pointerdown", Ze), (_e = i.domElement) === null || _e === void 0 || _e.removeEventListener("pointercancel", vt), (be = i.domElement) === null || be === void 0 || be.removeEventListener("wheel", D), ($e = i.domElement) === null || $e === void 0 || $e.ownerDocument.removeEventListener("pointermove", Je), (yt = i.domElement) === null || yt === void 0 || yt.ownerDocument.removeEventListener("pointerup", je), i._domElementKeyEvents !== null && i._domElementKeyEvents.removeEventListener("keydown", se) }; const i = this, r = { type: "change" }, s = { type: "start" }, o = { type: "end" }, a = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let l = a.NONE; const f = 1e-6, d = new s1, h = new s1; let p = 1; const m = new I; let v = !1; const y = new pe, x = new pe, A = new pe, _ = new pe, w = new pe, S = new pe, T = new pe, P = new pe, R = new pe, E = [], B = {}; function L() { return 2 * Math.PI / 60 / 60 * i.autoRotateSpeed } function U() { return Math.pow(.95, i.zoomSpeed) } function q(H) { i.reverseOrbit ? h.theta += H : h.theta -= H } function W(H) { i.reverseOrbit ? h.phi += H : h.phi -= H } const G = (() => { const H = new I; return function (_e, be) { H.setFromMatrixColumn(be, 0), H.multiplyScalar(-_e), m.add(H) } })(), K = (() => { const H = new I; return function (_e, be) { i.screenSpacePanning === !0 ? H.setFromMatrixColumn(be, 1) : (H.setFromMatrixColumn(be, 0), H.crossVectors(i.object.up, H)), H.multiplyScalar(_e), m.add(H) } })(), ne = (() => { const H = new I; return function (_e, be) { const $e = i.domElement; if ($e && i.object instanceof Gt && i.object.isPerspectiveCamera) { const yt = i.object.position; H.copy(yt).sub(i.target); let Vt = H.length(); Vt *= Math.tan(i.object.fov / 2 * Math.PI / 180), G(2 * _e * Vt / $e.clientHeight, i.object.matrix), K(2 * be * Vt / $e.clientHeight, i.object.matrix) } else $e && i.object instanceof Ir && i.object.isOrthographicCamera ? (G(_e * (i.object.right - i.object.left) / i.object.zoom / $e.clientWidth, i.object.matrix), K(be * (i.object.top - i.object.bottom) / i.object.zoom / $e.clientHeight, i.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i.enablePan = !1) } })(); function oe(H) { i.object instanceof Gt && i.object.isPerspectiveCamera ? p /= H : i.object instanceof Ir && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom * H)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function N(H) { i.object instanceof Gt && i.object.isPerspectiveCamera ? p *= H : i.object instanceof Ir && i.object.isOrthographicCamera ? (i.object.zoom = Math.max(i.minZoom, Math.min(i.maxZoom, i.object.zoom / H)), i.object.updateProjectionMatrix(), v = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i.enableZoom = !1) } function V(H) { y.set(H.clientX, H.clientY) } function Y(H) { T.set(H.clientX, H.clientY) } function re(H) { _.set(H.clientX, H.clientY) } function j(H) { x.set(H.clientX, H.clientY), A.subVectors(x, y).multiplyScalar(i.rotateSpeed); const le = i.domElement; le && (q(2 * Math.PI * A.x / le.clientHeight), W(2 * Math.PI * A.y / le.clientHeight)), y.copy(x), i.update() } function ie(H) { P.set(H.clientX, H.clientY), R.subVectors(P, T), R.y > 0 ? oe(U()) : R.y < 0 && N(U()), T.copy(P), i.update() } function ve(H) { w.set(H.clientX, H.clientY), S.subVectors(w, _).multiplyScalar(i.panSpeed), ne(S.x, S.y), _.copy(w), i.update() } function Ae(H) { H.deltaY < 0 ? N(U()) : H.deltaY > 0 && oe(U()), i.update() } function $(H) { let le = !1; switch (H.code) { case i.keys.UP: ne(0, i.keyPanSpeed), le = !0; break; case i.keys.BOTTOM: ne(0, -i.keyPanSpeed), le = !0; break; case i.keys.LEFT: ne(i.keyPanSpeed, 0), le = !0; break; case i.keys.RIGHT: ne(-i.keyPanSpeed, 0), le = !0; break }le && (H.preventDefault(), i.update()) } function Oe() { if (E.length == 1) y.set(E[0].pageX, E[0].pageY); else { const H = .5 * (E[0].pageX + E[1].pageX), le = .5 * (E[0].pageY + E[1].pageY); y.set(H, le) } } function ke() { if (E.length == 1) _.set(E[0].pageX, E[0].pageY); else { const H = .5 * (E[0].pageX + E[1].pageX), le = .5 * (E[0].pageY + E[1].pageY); _.set(H, le) } } function He() { const H = E[0].pageX - E[1].pageX, le = E[0].pageY - E[1].pageY, _e = Math.sqrt(H * H + le * le); T.set(0, _e) } function Me() { i.enableZoom && He(), i.enablePan && ke() } function De() { i.enableZoom && He(), i.enableRotate && Oe() } function de(H) { if (E.length == 1) x.set(H.pageX, H.pageY); else { const _e = Xe(H), be = .5 * (H.pageX + _e.x), $e = .5 * (H.pageY + _e.y); x.set(be, $e) } A.subVectors(x, y).multiplyScalar(i.rotateSpeed); const le = i.domElement; le && (q(2 * Math.PI * A.x / le.clientHeight), W(2 * Math.PI * A.y / le.clientHeight)), y.copy(x) } function ae(H) { if (E.length == 1) w.set(H.pageX, H.pageY); else { const le = Xe(H), _e = .5 * (H.pageX + le.x), be = .5 * (H.pageY + le.y); w.set(_e, be) } S.subVectors(w, _).multiplyScalar(i.panSpeed), ne(S.x, S.y), _.copy(w) } function Ce(H) { const le = Xe(H), _e = H.pageX - le.x, be = H.pageY - le.y, $e = Math.sqrt(_e * _e + be * be); P.set(0, $e), R.set(0, Math.pow(P.y / T.y, i.zoomSpeed)), oe(R.y), T.copy(P) } function ze(H) { i.enableZoom && Ce(H), i.enablePan && ae(H) } function Be(H) { i.enableZoom && Ce(H), i.enableRotate && de(H) } function Ze(H) { if (i.enabled !== !1) { if (E.length === 0) { var le, _e; (le = i.domElement) === null || le === void 0 || le.ownerDocument.addEventListener("pointermove", Je), (_e = i.domElement) === null || _e === void 0 || _e.ownerDocument.addEventListener("pointerup", je) } tt(H), H.pointerType === "touch" ? we(H) : wt(H) } } function Je(H) { i.enabled !== !1 && (H.pointerType === "touch" ? Ee(H) : k(H)) } function je(H) { if (Ie(H), E.length === 0) { var le, _e, be; (le = i.domElement) === null || le === void 0 || le.releasePointerCapture(H.pointerId), (_e = i.domElement) === null || _e === void 0 || _e.ownerDocument.removeEventListener("pointermove", Je), (be = i.domElement) === null || be === void 0 || be.ownerDocument.removeEventListener("pointerup", je) } i.dispatchEvent(o), l = a.NONE } function vt(H) { Ie(H) } function wt(H) { let le; switch (H.button) { case 0: le = i.mouseButtons.LEFT; break; case 1: le = i.mouseButtons.MIDDLE; break; case 2: le = i.mouseButtons.RIGHT; break; default: le = -1 }switch (le) { case _a.DOLLY: if (i.enableZoom === !1) return; Y(H), l = a.DOLLY; break; case _a.ROTATE: if (H.ctrlKey || H.metaKey || H.shiftKey) { if (i.enablePan === !1) return; re(H), l = a.PAN } else { if (i.enableRotate === !1) return; V(H), l = a.ROTATE } break; case _a.PAN: if (H.ctrlKey || H.metaKey || H.shiftKey) { if (i.enableRotate === !1) return; V(H), l = a.ROTATE } else { if (i.enablePan === !1) return; re(H), l = a.PAN } break; default: l = a.NONE }l !== a.NONE && i.dispatchEvent(s) } function k(H) { if (i.enabled !== !1) switch (l) { case a.ROTATE: if (i.enableRotate === !1) return; j(H); break; case a.DOLLY: if (i.enableZoom === !1) return; ie(H); break; case a.PAN: if (i.enablePan === !1) return; ve(H); break } } function D(H) { i.enabled === !1 || i.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (H.preventDefault(), i.dispatchEvent(s), Ae(H), i.dispatchEvent(o)) } function se(H) { i.enabled === !1 || i.enablePan === !1 || $(H) } function we(H) { switch (me(H), E.length) { case 1: switch (i.touches.ONE) { case Ma.ROTATE: if (i.enableRotate === !1) return; Oe(), l = a.TOUCH_ROTATE; break; case Ma.PAN: if (i.enablePan === !1) return; ke(), l = a.TOUCH_PAN; break; default: l = a.NONE }break; case 2: switch (i.touches.TWO) { case Ma.DOLLY_PAN: if (i.enableZoom === !1 && i.enablePan === !1) return; Me(), l = a.TOUCH_DOLLY_PAN; break; case Ma.DOLLY_ROTATE: if (i.enableZoom === !1 && i.enableRotate === !1) return; De(), l = a.TOUCH_DOLLY_ROTATE; break; default: l = a.NONE }break; default: l = a.NONE }l !== a.NONE && i.dispatchEvent(s) } function Ee(H) { switch (me(H), l) { case a.TOUCH_ROTATE: if (i.enableRotate === !1) return; de(H), i.update(); break; case a.TOUCH_PAN: if (i.enablePan === !1) return; ae(H), i.update(); break; case a.TOUCH_DOLLY_PAN: if (i.enableZoom === !1 && i.enablePan === !1) return; ze(H), i.update(); break; case a.TOUCH_DOLLY_ROTATE: if (i.enableZoom === !1 && i.enableRotate === !1) return; Be(H), i.update(); break; default: l = a.NONE } } function Pe(H) { i.enabled !== !1 && H.preventDefault() } function tt(H) { E.push(H) } function Ie(H) { delete B[H.pointerId]; for (let le = 0; le < E.length; le++)if (E[le].pointerId == H.pointerId) { E.splice(le, 1); return } } function me(H) { let le = B[H.pointerId]; le === void 0 && (le = new pe, B[H.pointerId] = le), le.set(H.pageX, H.pageY) } function Xe(H) { const le = H.pointerId === E[0].pointerId ? E[1] : E[0]; return B[le.pointerId] } t !== void 0 && this.connect(t), this.update() } }; class E_ extends hi { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new hV(t) }), this.register(function (t) { return new AV(t) }), this.register(function (t) { return new _V(t) }), this.register(function (t) { return new mV(t) }), this.register(function (t) { return new gV(t) }), this.register(function (t) { return new yV(t) }), this.register(function (t) { return new vV(t) }), this.register(function (t) { return new dV(t) }), this.register(function (t) { return new xV(t) }), this.register(function (t) { return new pV(t) }), this.register(function (t) { return new cV(t) }), this.register(function (t) { return new MV(t) }) } load(e, t, i, r) { const s = this; let o; this.resourcePath !== "" ? o = this.resourcePath : this.path !== "" ? o = this.path : o = ts.extractUrlBase(e), this.manager.itemStart(e); const a = function (f) { r ? r(f) : console.error(f), s.manager.itemError(e), s.manager.itemEnd(e) }, l = new Gi(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (f) { try { s.parse(f, o, function (d) { t(d), s.manager.itemEnd(e) }, a) } catch (d) { a(d) } }, i, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, i, r) { let s; const o = {}, a = {}; if (typeof e == "string") s = e; else if (ts.decodeText(new Uint8Array(e, 0, 4)) === I3) { try { o[xt.KHR_BINARY_GLTF] = new wV(e) } catch (h) { r && r(h); return } s = o[xt.KHR_BINARY_GLTF].content } else s = ts.decodeText(new Uint8Array(e)); const l = JSON.parse(s); if (l.asset === void 0 || l.asset.version[0] < 2) { r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const f = new NV(l, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); f.fileLoader.setRequestHeader(this.requestHeader); for (let d = 0; d < this.pluginCallbacks.length; d++) { const h = this.pluginCallbacks[d](f); a[h.name] = h, o[h.name] = !0 } if (l.extensionsUsed) for (let d = 0; d < l.extensionsUsed.length; ++d) { const h = l.extensionsUsed[d], p = l.extensionsRequired || []; switch (h) { case xt.KHR_MATERIALS_UNLIT: o[h] = new fV; break; case xt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: o[h] = new EV; break; case xt.KHR_DRACO_MESH_COMPRESSION: o[h] = new SV(l, this.dracoLoader); break; case xt.KHR_TEXTURE_TRANSFORM: o[h] = new CV; break; case xt.KHR_MESH_QUANTIZATION: o[h] = new TV; break; default: p.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".') } } f.setExtensions(o), f.setPlugins(a), f.parse(i, r) } parseAsync(e, t) { const i = this; return new Promise(function (r, s) { i.parse(e, t, r, s) }) } } function uV() { let n = {}; return { get: function (e) { return n[e] }, add: function (e, t) { n[e] = t }, remove: function (e) { delete n[e] }, removeAll: function () { n = {} } } } const xt = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class cV { constructor(e) { this.parser = e, this.name = xt.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let i = 0, r = t.length; i < r; i++) { const s = t[i]; s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, i = "light:" + e; let r = t.cache.get(i); if (r) return r; const s = t.json, l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e]; let f; const d = new Le(16777215); l.color !== void 0 && d.fromArray(l.color); const h = l.range !== void 0 ? l.range : 0; switch (l.type) { case "directional": f = new g_(d), f.target.position.set(0, 0, -1), f.add(f.target); break; case "point": f = new m_(d), f.distance = h; break; case "spot": f = new p_(d), f.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, f.angle = l.spot.outerConeAngle, f.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, f.target.position.set(0, 0, -1), f.add(f.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type) }return f.position.set(0, 0, 0), f.decay = 2, l.intensity !== void 0 && (f.intensity = l.intensity), f.name = t.createUniqueName(l.name || "light_" + e), r = Promise.resolve(f), t.cache.add(i, r), r } createNodeAttachment(e) { const t = this, i = this.parser, s = i.json.nodes[e], a = (s.extensions && s.extensions[this.name] || {}).light; return a === void 0 ? null : this._loadLight(a).then(function (l) { return i._getNodeRef(t.cache, a, l) }) } } class fV { constructor() { this.name = xt.KHR_MATERIALS_UNLIT } getMaterialType() { return Oi } extendParams(e, t, i) { const r = []; e.color = new Le(1, 1, 1), e.opacity = 1; const s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { const o = s.baseColorFactor; e.color.fromArray(o), e.opacity = o[3] } s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, Ct)) } return Promise.all(r) } } class dV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name].emissiveStrength; return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve() } } class hV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) { const a = o.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new pe(a, a) } return Promise.all(s) } } class pV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s) } } class mV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_SHEEN } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = []; t.sheenColor = new Le(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const o = r.extensions[this.name]; return o.sheenColorFactor !== void 0 && t.sheenColor.fromArray(o.sheenColorFactor), o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Ct)), o.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s) } } class gV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s) } } class yV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_VOLUME } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0; const a = o.attenuationColor || [1, 1, 1]; return t.attenuationColor = new Le(a[0], a[1], a[2]), Promise.all(s) } } class vV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_IOR } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const r = this.parser.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = r.extensions[this.name]; return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve() } } class xV { constructor(e) { this.parser = e, this.name = xt.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const i = this.parser.json.materials[e]; return !i.extensions || !i.extensions[this.name] ? null : Ys } extendMaterialParams(e, t) { const i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const s = [], o = r.extensions[this.name]; t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture)); const a = o.specularColorFactor || [1, 1, 1]; return t.specularColor = new Le(a[0], a[1], a[2]), o.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", o.specularColorTexture, Ct)), Promise.all(s) } } class AV { constructor(e) { this.parser = e, this.name = xt.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, i = t.json, r = i.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; const s = r.extensions[this.name], o = t.options.ktx2Loader; if (!o) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s.source, o) } } class _V { constructor(e) { this.parser = e, this.name = xt.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, i = this.parser, r = i.json, s = r.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const o = s.extensions[t], a = r.images[o.source]; let l = i.textureLoader; if (a.uri) { const f = i.options.manager.getHandler(a.uri); f !== null && (l = f) } return this.detectSupport().then(function (f) { if (f) return i.loadTextureImage(e, o.source, l); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return i.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class MV { constructor(e) { this.name = xt.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { const r = i.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), o = this.parser.options.meshoptDecoder; if (!o || !o.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return s.then(function (a) { const l = r.byteOffset || 0, f = r.byteLength || 0, d = r.count, h = r.byteStride, p = new Uint8Array(a, l, f); return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(d, h, p, r.mode, r.filter).then(function (m) { return m.buffer }) : o.ready.then(function () { const m = new ArrayBuffer(d * h); return o.decodeGltfBuffer(new Uint8Array(m), d, h, p, r.mode, r.filter), m }) }) } else return null } } const I3 = "glTF", Vc = 12, zE = { JSON: 1313821514, BIN: 5130562 }; class wV { constructor(e) { this.name = xt.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, Vc); if (this.header = { magic: ts.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== I3) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const i = this.header.length - Vc, r = new DataView(e, Vc); let s = 0; for (; s < i;) { const o = r.getUint32(s, !0); s += 4; const a = r.getUint32(s, !0); if (s += 4, a === zE.JSON) { const l = new Uint8Array(e, Vc + s, o); this.content = ts.decodeText(l) } else if (a === zE.BIN) { const l = Vc + s; this.body = e.slice(l, l + o) } s += o } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class SV { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = xt.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const i = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, f = {}; for (const d in o) { const h = p1[d] || d.toLowerCase(); a[h] = o[d] } for (const d in e.attributes) { const h = p1[d] || d.toLowerCase(); if (o[d] !== void 0) { const p = i.accessors[e.attributes[d]], m = $f[p.componentType]; f[h] = m.name, l[h] = p.normalized === !0 } } return t.getDependency("bufferView", s).then(function (d) { return new Promise(function (h) { r.decodeDracoFile(d, function (p) { for (const m in p.attributes) { const v = p.attributes[m], y = l[m]; y !== void 0 && (v.normalized = y) } h(p) }, a, f) }) }) } } class CV { constructor() { this.name = xt.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class h1 extends Ku {
	constructor(e) {
		super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join(`
`), i = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join(`
`), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join(`
`), s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join(`
`), o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join(`
`), a = { specular: { value: new Le().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = a, this.onBeforeCompile = function (l) { for (const f in a) l.uniforms[f] = a[f]; l.fragmentShader = l.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o) }, Object.defineProperties(this, { specular: { get: function () { return a.specular.value }, set: function (l) { a.specular.value = l } }, specularMap: { get: function () { return a.specularMap.value }, set: function (l) { a.specularMap.value = l, l ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return a.glossiness.value }, set: function (l) { a.glossiness.value = l } }, glossinessMap: { get: function () { return a.glossinessMap.value }, set: function (l) { a.glossinessMap.value = l, l ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
	} copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }
} class EV { constructor() { this.name = xt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return h1 } extendParams(e, t, i) { const r = t.extensions[this.name]; e.color = new Le(1, 1, 1), e.opacity = 1; const s = []; if (Array.isArray(r.diffuseFactor)) { const o = r.diffuseFactor; e.color.fromArray(o), e.opacity = o[3] } if (r.diffuseTexture !== void 0 && s.push(i.assignTexture(e, "map", r.diffuseTexture, Ct)), e.emissive = new Le(0, 0, 0), e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1, e.specular = new Le(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), r.specularGlossinessTexture !== void 0) { const o = r.specularGlossinessTexture; s.push(i.assignTexture(e, "glossinessMap", o)), s.push(i.assignTexture(e, "specularMap", o, Ct)) } return Promise.all(s) } createMaterial(e) { const t = new h1(e); return t.fog = !0, t.color = e.color, t.map = e.map === void 0 ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = e.aoMap === void 0 ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity, t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap, t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = e.normalMap === void 0 ? null : e.normalMap, t.normalMapType = Js, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = e.specularMap === void 0 ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = e.envMap === void 0 ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class TV { constructor() { this.name = xt.KHR_MESH_QUANTIZATION } } class F3 extends Qu { constructor(e, t, i, r) { super(e, t, i, r) } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r * 3 + r; for (let o = 0; o !== r; o++)t[o] = i[s + o]; return t } interpolate_(e, t, i, r) { const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, f = a * 3, d = r - t, h = (i - t) / d, p = h * h, m = p * h, v = e * f, y = v - f, x = -2 * m + 3 * p, A = m - p, _ = 1 - x, w = A - p + h; for (let S = 0; S !== a; S++) { const T = o[y + S + a], P = o[y + S + l] * d, R = o[v + S + a], E = o[v + S] * d; s[S] = _ * T + w * P + x * R + A * E } return s } } const bV = new Hn; class PV extends F3 { interpolate_(e, t, i, r) { const s = super.interpolate_(e, t, i, r); return bV.fromArray(s).normalize().toArray(s), s } } const ws = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, $f = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, GE = { 9728: fn, 9729: en, 9984: Gf, 9985: Ag, 9986: vu, 9987: rs }, HE = { 33071: zn, 33648: bu, 10497: Uo }, VE = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, p1 = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, uo = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, BV = { CUBICSPLINE: void 0, LINEAR: el, STEP: Bu }, uv = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function RV(n) { return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Ku({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: is })), n.DefaultMaterial } function Wc(n, e, t) { for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]) } function Sa(n, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function LV(n, e, t) { let i = !1, r = !1, s = !1; for (let f = 0, d = e.length; f < d; f++) { const h = e[f]; if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (r = !0), h.COLOR_0 !== void 0 && (s = !0), i && r && s) break } if (!i && !r && !s) return Promise.resolve(n); const o = [], a = [], l = []; for (let f = 0, d = e.length; f < d; f++) { const h = e[f]; if (i) { const p = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position; o.push(p) } if (r) { const p = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal; a.push(p) } if (s) { const p = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color; l.push(p) } } return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (f) { const d = f[0], h = f[1], p = f[2]; return i && (n.morphAttributes.position = d), r && (n.morphAttributes.normal = h), s && (n.morphAttributes.color = p), n.morphTargetsRelative = !0, n }) } function DV(n, e) { if (n.updateMorphTargets(), e.weights !== void 0) for (let t = 0, i = e.weights.length; t < i; t++)n.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (n.morphTargetInfluences.length === t.length) { n.morphTargetDictionary = {}; for (let i = 0, r = t.length; i < r; i++)n.morphTargetDictionary[t[i]] = i } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function IV(n) { const e = n.extensions && n.extensions[xt.KHR_DRACO_MESH_COMPRESSION]; let t; return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + WE(e.attributes) : t = n.indices + ":" + WE(n.attributes) + ":" + n.mode, t } function WE(n) { let e = ""; const t = Object.keys(n).sort(); for (let i = 0, r = t.length; i < r; i++)e += t[i] + ":" + n[t[i]] + ";"; return e } function m1(n) { switch (n) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function FV(n) { return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } class NV { constructor(e = {}, t = {}) { var i, r; this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new uV, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; const s = typeof navigator < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, o = typeof navigator < "u" && ((i = navigator.userAgent) === null || i === void 0 ? void 0 : i.indexOf("Firefox")) > -1, a = typeof navigator < "u" && o ? (r = navigator.userAgent) === null || r === void 0 ? void 0 : r.match(/Firefox\/([0-9]+)\./)[1] : -1; typeof createImageBitmap > "u" || s || o && a < 98 ? this.textureLoader = new Bd(this.options.manager) : this.textureLoader = new a3(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Gi(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const i = this, r = this.json, s = this.extensions; this.cache.removeAll(), this._invokeAll(function (o) { return o._markDefs && o._markDefs() }), Promise.all(this._invokeAll(function (o) { return o.beforeRoot && o.beforeRoot() })).then(function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) }).then(function (o) { const a = { scene: o[0][r.scene || 0], scenes: o[0], animations: o[1], cameras: o[2], asset: r.asset, parser: i, userData: {} }; Wc(s, a, r), Sa(a, r), Promise.all(i._invokeAll(function (l) { return l.afterRoot && l.afterRoot(a) })).then(function () { e(a) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || []; for (let r = 0, s = t.length; r < s; r++) { const o = t[r].joints; for (let a = 0, l = o.length; a < l; a++)e[o[a]].isBone = !0 } for (let r = 0, s = e.length; r < s; r++) { const o = e[r]; o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, i) { if (e.refs[t] <= 1) return i; const r = i.clone(), s = (o, a) => { const l = this.associations.get(o); l != null && this.associations.set(a, l); for (const [f, d] of o.children.entries()) s(d, a.children[f]) }; return s(i, r), r.name += "_instance_" + e.uses[t]++, r } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let i = 0; i < t.length; i++) { const r = e(t[i]); if (r) return r } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const i = []; for (let r = 0; r < t.length; r++) { const s = e(t[r]); s && i.push(s) } return i } getDependency(e, t) { const i = e + ":" + t; let r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (s) { return s.loadMesh && s.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (s) { return s.loadBufferView && s.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (s) { return s.loadMaterial && s.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (s) { return s.loadTexture && s.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this._invokeOne(function (s) { return s.loadAnimation && s.loadAnimation(t) }); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r } getDependencies(e) { let t = this.cache.get(e); if (!t) { const i = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(r.map(function (s, o) { return i.getDependency(e, o) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], i = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[xt.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (s, o) { i.load(ts.resolveURL(t.uri, r.path), s, void 0, function () { o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (i) { const r = t.byteLength || 0, s = t.byteOffset || 0; return i.slice(s, s + r) }) } loadAccessor(e) { const t = this, i = this.json, r = this.json.accessors[e]; if (r.bufferView === void 0 && r.sparse === void 0) return Promise.resolve(null); const s = []; return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function (o) { const a = o[0], l = VE[r.type], f = $f[r.componentType], d = f.BYTES_PER_ELEMENT, h = d * l, p = r.byteOffset || 0, m = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0, v = r.normalized === !0; let y, x; if (m && m !== h) { const A = Math.floor(p / m), _ = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + A + ":" + r.count; let w = t.cache.get(_); w || (y = new f(a, A * m, r.count * m / d), w = new md(y, m / d), t.cache.add(_, w)), x = new zo(w, l, p % m / d, v) } else a === null ? y = new f(r.count * l) : y = new f(a, p, r.count * l), x = new It(y, l, v); if (r.sparse !== void 0) { const A = VE.SCALAR, _ = $f[r.sparse.indices.componentType], w = r.sparse.indices.byteOffset || 0, S = r.sparse.values.byteOffset || 0, T = new _(o[1], w, r.sparse.count * A), P = new f(o[2], S, r.sparse.count * l); a !== null && (x = new It(x.array.slice(), x.itemSize, x.normalized)); for (let R = 0, E = T.length; R < E; R++) { const B = T[R]; if (x.setX(B, P[R * l]), l >= 2 && x.setY(B, P[R * l + 1]), l >= 3 && x.setZ(B, P[R * l + 2]), l >= 4 && x.setW(B, P[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return x }) } loadTexture(e) { const t = this.json, i = this.options, s = t.textures[e].source, o = t.images[s]; let a = this.textureLoader; if (o.uri) { const l = i.manager.getHandler(o.uri); l !== null && (a = l) } return this.loadTextureImage(e, s, a) } loadTextureImage(e, t, i) { const r = this, s = this.json, o = s.textures[e], a = s.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler; if (this.textureCache[l]) return this.textureCache[l]; const f = this.loadImageSource(t, i).then(function (d) { d.flipY = !1, o.name && (d.name = o.name); const p = (s.samplers || {})[o.sampler] || {}; return d.magFilter = GE[p.magFilter] || en, d.minFilter = GE[p.minFilter] || rs, d.wrapS = HE[p.wrapS] || Uo, d.wrapT = HE[p.wrapT] || Uo, r.associations.set(d, { textures: e }), d }).catch(function () { return null }); return this.textureCache[l] = f, f } loadImageSource(e, t) { const i = this, r = this.json, s = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone()); const o = r.images[e], a = self.URL || self.webkitURL; let l = o.uri || "", f = !1; if (o.bufferView !== void 0) l = i.getDependency("bufferView", o.bufferView).then(function (h) { f = !0; const p = new Blob([h], { type: o.mimeType }); return l = a.createObjectURL(p), l }); else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const d = Promise.resolve(l).then(function (h) { return new Promise(function (p, m) { let v = p; t.isImageBitmapLoader === !0 && (v = function (y) { const x = new Qt(y); x.needsUpdate = !0, p(x) }), t.load(ts.resolveURL(h, s.path), v, void 0, m) }) }).then(function (h) { return f === !0 && a.revokeObjectURL(l), h.userData.mimeType = o.mimeType || FV(o.uri), h }).catch(function (h) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h }); return this.sourceCache[e] = d, d } assignTexture(e, t, i, r) { const s = this; return this.getDependency("texture", i.index).then(function (o) { if (i.texCoord !== void 0 && i.texCoord != 0 && !(t === "aoMap" && i.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), s.extensions[xt.KHR_TEXTURE_TRANSFORM]) { const a = i.extensions !== void 0 ? i.extensions[xt.KHR_TEXTURE_TRANSFORM] : void 0; if (a) { const l = s.associations.get(o); o = s.extensions[xt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l) } } return r !== void 0 && (o.encoding = r), e[t] = o, o }) } assignFinalMaterial(e) { const t = e.geometry; let i = e.material; const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, o = t.attributes.normal === void 0; if (e.isPoints) { const a = "PointsMaterial:" + i.uuid; let l = this.cache.get(a); l || (l = new yd, Mn.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = !1, this.cache.add(a, l)), i = l } else if (e.isLine) { const a = "LineBasicMaterial:" + i.uuid; let l = this.cache.get(a); l || (l = new ei, Mn.prototype.copy.call(l, i), l.color.copy(i.color), this.cache.add(a, l)), i = l } if (r || s || o) { let a = "ClonedMaterial:" + i.uuid + ":"; i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"), r && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:"); let l = this.cache.get(a); l || (l = i.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(i))), i = l } i.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = i } getMaterialType() { return Ku } loadMaterial(e) { const t = this, i = this.json, r = this.extensions, s = i.materials[e]; let o; const a = {}, l = s.extensions || {}, f = []; if (l[xt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const h = r[xt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; o = h.getMaterialType(), f.push(h.extendParams(a, s, t)) } else if (l[xt.KHR_MATERIALS_UNLIT]) { const h = r[xt.KHR_MATERIALS_UNLIT]; o = h.getMaterialType(), f.push(h.extendParams(a, s, t)) } else { const h = s.pbrMetallicRoughness || {}; if (a.color = new Le(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) { const p = h.baseColorFactor; a.color.fromArray(p), a.opacity = p[3] } h.baseColorTexture !== void 0 && f.push(t.assignTexture(a, "map", h.baseColorTexture, Ct)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (f.push(t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), f.push(t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), o = this._invokeOne(function (p) { return p.getMaterialType && p.getMaterialType(e) }), f.push(Promise.all(this._invokeAll(function (p) { return p.extendMaterialParams && p.extendMaterialParams(e, a) }))) } s.doubleSided === !0 && (a.side = Br); const d = s.alphaMode || uv.OPAQUE; if (d === uv.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, d === uv.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== Oi && (f.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new pe(1, 1), s.normalTexture.scale !== void 0)) { const h = s.normalTexture.scale; a.normalScale.set(h, h) } return s.occlusionTexture !== void 0 && o !== Oi && (f.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== Oi && (a.emissive = new Le().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && o !== Oi && f.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Ct)), Promise.all(f).then(function () { let h; return o === h1 ? h = r[xt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : h = new o(a), s.name && (h.name = s.name), Sa(h, s), t.associations.set(h, { materials: e }), s.extensions && Wc(r, h, s), h }) } createUniqueName(e) { const t = Tt.sanitizeNodeName(e || ""); let i = t; for (let r = 1; this.nodeNamesUsed[i]; ++r)i = t + "_" + r; return this.nodeNamesUsed[i] = !0, i } loadGeometries(e) { const t = this, i = this.extensions, r = this.primitiveCache; function s(a) { return i[xt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) { return jE(l, a, t) }) } const o = []; for (let a = 0, l = e.length; a < l; a++) { const f = e[a], d = IV(f), h = r[d]; if (h) o.push(h.promise); else { let p; f.extensions && f.extensions[xt.KHR_DRACO_MESH_COMPRESSION] ? p = s(f) : p = jE(new ut, f, t), r[d] = { primitive: f, promise: p }, o.push(p) } } return Promise.all(o) } loadMesh(e) { const t = this, i = this.json, r = this.extensions, s = i.meshes[e], o = s.primitives, a = []; for (let l = 0, f = o.length; l < f; l++) { const d = o[l].material === void 0 ? RV(this.cache) : this.getDependency("material", o[l].material); a.push(d) } return a.push(t.loadGeometries(o)), Promise.all(a).then(function (l) { const f = l.slice(0, l.length - 1), d = l[l.length - 1], h = []; for (let m = 0, v = d.length; m < v; m++) { const y = d[m], x = o[m]; let A; const _ = f[m]; if (x.mode === ws.TRIANGLES || x.mode === ws.TRIANGLE_STRIP || x.mode === ws.TRIANGLE_FAN || x.mode === void 0) A = s.isSkinnedMesh === !0 ? new qA(y, _) : new Tn(y, _), A.isSkinnedMesh === !0 && !A.geometry.attributes.skinWeight.normalized && A.normalizeSkinWeights(), x.mode === ws.TRIANGLE_STRIP ? A.geometry = JE(A.geometry, cB) : x.mode === ws.TRIANGLE_FAN && (A.geometry = JE(A.geometry, OA)); else if (x.mode === ws.LINES) A = new Or(y, _); else if (x.mode === ws.LINE_STRIP) A = new Ws(y, _); else if (x.mode === ws.LINE_LOOP) A = new $A(y, _); else if (x.mode === ws.POINTS) A = new e_(y, _); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode); Object.keys(A.geometry.morphAttributes).length > 0 && DV(A, s), A.name = t.createUniqueName(s.name || "mesh_" + e), Sa(A, s), x.extensions && Wc(r, A, x), t.assignFinalMaterial(A), h.push(A) } for (let m = 0, v = h.length; m < v; m++)t.associations.set(h[m], { meshes: e, primitives: m }); if (h.length === 1) return h[0]; const p = new Ls; t.associations.set(p, { meshes: e }); for (let m = 0, v = h.length; m < v; m++)p.add(h[m]); return p }) } loadCamera(e) { let t; const i = this.json.cameras[e], r = i[i.type]; if (!r) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return i.type === "perspective" ? t = new Gt(UA.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new Ir(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Sa(t, i), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], i = { joints: t.joints }; return t.inverseBindMatrices === void 0 ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then(function (r) { return i.inverseBindMatrices = r, i }) } loadAnimation(e) { const i = this.json.animations[e], r = [], s = [], o = [], a = [], l = []; for (let f = 0, d = i.channels.length; f < d; f++) { const h = i.channels[f], p = i.samplers[h.sampler], m = h.target, v = m.node, y = i.parameters !== void 0 ? i.parameters[p.input] : p.input, x = i.parameters !== void 0 ? i.parameters[p.output] : p.output; r.push(this.getDependency("node", v)), s.push(this.getDependency("accessor", y)), o.push(this.getDependency("accessor", x)), a.push(p), l.push(m) } return Promise.all([Promise.all(r), Promise.all(s), Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (f) { const d = f[0], h = f[1], p = f[2], m = f[3], v = f[4], y = []; for (let A = 0, _ = d.length; A < _; A++) { const w = d[A], S = h[A], T = p[A], P = m[A], R = v[A]; if (w === void 0) continue; w.updateMatrix(); let E; switch (uo[R.path]) { case uo.weights: E = Iu; break; case uo.rotation: E = Go; break; case uo.position: case uo.scale: default: E = Fu; break }const B = w.name ? w.name : w.uuid, L = P.interpolation !== void 0 ? BV[P.interpolation] : el, U = []; uo[R.path] === uo.weights ? w.traverse(function (W) { W.morphTargetInfluences && U.push(W.name ? W.name : W.uuid) }) : U.push(B); let q = T.array; if (T.normalized) { const W = m1(q.constructor), G = new Float32Array(q.length); for (let K = 0, ne = q.length; K < ne; K++)G[K] = q[K] * W; q = G } for (let W = 0, G = U.length; W < G; W++) { const K = new E(U[W] + "." + uo[R.path], S.array, q, L); P.interpolation === "CUBICSPLINE" && (K.createInterpolant = function (oe) { const N = this instanceof Go ? PV : F3; return new N(this.times, this.values, this.getValueSize() / 3, oe) }, K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(K) } } const x = i.name ? i.name : "animation_" + e; return new Nu(x, void 0, y) }) } createNodeMesh(e) { const t = this.json, i = this, r = t.nodes[e]; return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function (s) { const o = i._getNodeRef(i.meshCache, r.mesh, s); return r.weights !== void 0 && o.traverse(function (a) { if (a.isMesh) for (let l = 0, f = r.weights.length; l < f; l++)a.morphTargetInfluences[l] = r.weights[l] }), o }) } loadNode(e) { const t = this.json, i = this.extensions, r = this, s = t.nodes[e], o = s.name ? r.createUniqueName(s.name) : ""; return function () { const a = [], l = r._invokeOne(function (f) { return f.createNodeMesh && f.createNodeMesh(e) }); return l && a.push(l), s.camera !== void 0 && a.push(r.getDependency("camera", s.camera).then(function (f) { return r._getNodeRef(r.cameraCache, s.camera, f) })), r._invokeAll(function (f) { return f.createNodeAttachment && f.createNodeAttachment(e) }).forEach(function (f) { a.push(f) }), Promise.all(a) }().then(function (a) { let l; if (s.isBone === !0 ? l = new Tg : a.length > 1 ? l = new Ls : a.length === 1 ? l = a[0] : l = new bt, l !== a[0]) for (let f = 0, d = a.length; f < d; f++)l.add(a[f]); if (s.name && (l.userData.name = s.name, l.name = o), Sa(l, s), s.extensions && Wc(i, l, s), s.matrix !== void 0) { const f = new it; f.fromArray(s.matrix), l.applyMatrix4(f) } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale); return r.associations.has(l) || r.associations.set(l, {}), r.associations.get(l).nodes = e, l }) } loadScene(e) { const t = this.json, i = this.extensions, r = this.json.scenes[e], s = this, o = new Ls; r.name && (o.name = s.createUniqueName(r.name)), Sa(o, r), r.extensions && Wc(i, o, r); const a = r.nodes || [], l = []; for (let f = 0, d = a.length; f < d; f++)l.push(N3(a[f], o, t, s)); return Promise.all(l).then(function () { const f = d => { const h = new Map; for (const [p, m] of s.associations) (p instanceof Mn || p instanceof Qt) && h.set(p, m); return d.traverse(p => { const m = s.associations.get(p); m != null && h.set(p, m) }), h }; return s.associations = f(o), o }) } } function N3(n, e, t, i) { const r = t.nodes[n]; return i.getDependency("node", n).then(function (s) { if (r.skin === void 0) return s; let o; return i.getDependency("skin", r.skin).then(function (a) { o = a; const l = []; for (let f = 0, d = o.joints.length; f < d; f++)l.push(i.getDependency("node", o.joints[f])); return Promise.all(l) }).then(function (a) { return s.traverse(function (l) { if (!l.isMesh) return; const f = [], d = []; for (let h = 0, p = a.length; h < p; h++) { const m = a[h]; if (m) { f.push(m); const v = new it; o.inverseBindMatrices !== void 0 && v.fromArray(o.inverseBindMatrices.array, h * 16), d.push(v) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', o.joints[h]) } l.bind(new gd(f, d), l.matrixWorld) }), s }) }).then(function (s) { e.add(s); const o = []; if (r.children) { const a = r.children; for (let l = 0, f = a.length; l < f; l++) { const d = a[l]; o.push(N3(d, s, t, i)) } } return Promise.all(o) }) } function OV(n, e, t) { const i = e.attributes, r = new Xo; if (i.POSITION !== void 0) { const a = t.json.accessors[i.POSITION], l = a.min, f = a.max; if (l !== void 0 && f !== void 0) { if (r.set(new I(l[0], l[1], l[2]), new I(f[0], f[1], f[2])), a.normalized) { const d = m1($f[a.componentType]); r.min.multiplyScalar(d), r.max.multiplyScalar(d) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const s = e.targets; if (s !== void 0) { const a = new I, l = new I; for (let f = 0, d = s.length; f < d; f++) { const h = s[f]; if (h.POSITION !== void 0) { const p = t.json.accessors[h.POSITION], m = p.min, v = p.max; if (m !== void 0 && v !== void 0) { if (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))), p.normalized) { const y = m1($f[p.componentType]); l.multiplyScalar(y) } a.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(a) } n.boundingBox = r; const o = new Yo; r.getCenter(o.center), o.radius = r.min.distanceTo(r.max) / 2, n.boundingSphere = o } function jE(n, e, t) { const i = e.attributes, r = []; function s(o, a) { return t.getDependency("accessor", o).then(function (l) { n.setAttribute(a, l) }) } for (const o in i) { const a = p1[o] || o.toLowerCase(); a in n.attributes || r.push(s(i[o], a)) } if (e.indices !== void 0 && !n.index) { const o = t.getDependency("accessor", e.indices).then(function (a) { n.setIndex(a) }); r.push(o) } return Sa(n, e), OV(n, e, t), Promise.all(r).then(function () { return e.targets !== void 0 ? LV(n, e.targets, t) : n }) } function JE(n, e) { let t = n.getIndex(); if (t === null) { const o = [], a = n.getAttribute("position"); if (a !== void 0) { for (let l = 0; l < a.count; l++)o.push(l); n.setIndex(o), t = n.getIndex() } else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n } const i = t.count - 2, r = []; if (e === OA) for (let o = 1; o <= i; o++)r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)); else for (let o = 0; o < i; o++)o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o))); r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = n.clone(); return s.setIndex(r), s } class kV extends ut { constructor(e, t, i, r) { super(); const s = [], o = [], a = [], l = new I, f = new it; f.makeRotationFromEuler(i), f.setPosition(t); const d = new it; d.copy(f).invert(), h(), this.setAttribute("position", new We(s, 3)), this.setAttribute("normal", new We(o, 3)), this.setAttribute("uv", new We(a, 2)); function h() { let y, x = []; const A = new I, _ = new I; if (e.geometry.isGeometry === !0) { console.error("THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead."); return } const w = e.geometry, S = w.attributes.position, T = w.attributes.normal; if (w.index !== null) { const P = w.index; for (y = 0; y < P.count; y++)A.fromBufferAttribute(S, P.getX(y)), _.fromBufferAttribute(T, P.getX(y)), p(x, A, _) } else for (y = 0; y < S.count; y++)A.fromBufferAttribute(S, y), _.fromBufferAttribute(T, y), p(x, A, _); for (x = m(x, l.set(1, 0, 0)), x = m(x, l.set(-1, 0, 0)), x = m(x, l.set(0, 1, 0)), x = m(x, l.set(0, -1, 0)), x = m(x, l.set(0, 0, 1)), x = m(x, l.set(0, 0, -1)), y = 0; y < x.length; y++) { const P = x[y]; a.push(.5 + P.position.x / r.x, .5 + P.position.y / r.y), P.position.applyMatrix4(f), s.push(P.position.x, P.position.y, P.position.z), o.push(P.normal.x, P.normal.y, P.normal.z) } } function p(y, x, A) { x.applyMatrix4(e.matrixWorld), x.applyMatrix4(d), A.transformDirection(e.matrixWorld), y.push(new XE(x.clone(), A.clone())) } function m(y, x) { const A = [], _ = .5 * Math.abs(r.dot(x)); for (let w = 0; w < y.length; w += 3) { let S, T, P, R = 0, E, B, L, U; const q = y[w + 0].position.dot(x) - _, W = y[w + 1].position.dot(x) - _, G = y[w + 2].position.dot(x) - _; switch (S = q > 0, T = W > 0, P = G > 0, R = (S ? 1 : 0) + (T ? 1 : 0) + (P ? 1 : 0), R) { case 0: { A.push(y[w]), A.push(y[w + 1]), A.push(y[w + 2]); break } case 1: { if (S && (E = y[w + 1], B = y[w + 2], L = v(y[w], E, x, _), U = v(y[w], B, x, _)), T) { E = y[w], B = y[w + 2], L = v(y[w + 1], E, x, _), U = v(y[w + 1], B, x, _), A.push(L), A.push(B.clone()), A.push(E.clone()), A.push(B.clone()), A.push(L.clone()), A.push(U); break } P && (E = y[w], B = y[w + 1], L = v(y[w + 2], E, x, _), U = v(y[w + 2], B, x, _)), A.push(E.clone()), A.push(B.clone()), A.push(L), A.push(U), A.push(L.clone()), A.push(B.clone()); break } case 2: { S || (E = y[w].clone(), B = v(E, y[w + 1], x, _), L = v(E, y[w + 2], x, _), A.push(E), A.push(B), A.push(L)), T || (E = y[w + 1].clone(), B = v(E, y[w + 2], x, _), L = v(E, y[w], x, _), A.push(E), A.push(B), A.push(L)), P || (E = y[w + 2].clone(), B = v(E, y[w], x, _), L = v(E, y[w + 1], x, _), A.push(E), A.push(B), A.push(L)); break } } } return A } function v(y, x, A, _) { const w = y.position.dot(A) - _, S = x.position.dot(A) - _, T = w / (w - S); return new XE(new I(y.position.x + T * (x.position.x - y.position.x), y.position.y + T * (x.position.y - y.position.y), y.position.z + T * (x.position.z - y.position.z)), new I(y.normal.x + T * (x.normal.x - y.normal.x), y.normal.y + T * (x.normal.y - y.normal.y), y.normal.z + T * (x.normal.z - y.normal.z))) } } } class XE { constructor(e, t) { this.position = e, this.normal = t } clone() { return new this.constructor(this.position.clone(), this.normal.clone()) } } const cv = new WeakMap; class UV extends hi {
	constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, i, r) { const s = new Gi(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => { const a = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(o, a).then(t).catch(r) }, i, r) } decodeDracoFile(e, t, i, r) { const s = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!i }; this.decodeGeometry(e, s).then(t) } decodeGeometry(e, t) { for (const l in t.attributeTypes) { const f = t.attributeTypes[l]; f.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = f.name) } const i = JSON.stringify(t); if (cv.has(e)) { const l = cv.get(e); if (l.key === i) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r; const s = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(s, o).then(l => (r = l, new Promise((f, d) => { r._callbacks[s] = { resolve: f, reject: d }, r.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { r && s && this._releaseTask(r, s) }), cv.set(e, { key: i, promise: a }), a } _createGeometry(e) { const t = new ut; e.index && t.setIndex(new It(e.index.array, 1)); for (let i = 0; i < e.attributes.length; i++) { const r = e.attributes[i], s = r.name, o = r.array, a = r.itemSize; t.setAttribute(s, new It(o, a)) } return t } _loadLibrary(e, t) { const i = new Gi(this.manager); return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise((r, s) => { i.load(e, r, void 0, s) }) } preload() { return this._initDecoder(), this } _initDecoder() {
		if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(i => {
			const r = i[0]; e || (this.decoderConfig.wasmBinary = i[1]); const s = zV.toString(), o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o]))
		}), this.decoderPending
	} _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const r = new Worker(this.workerSourceURL); r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function (s) { const o = s.data; switch (o.type) { case "decode": r._callbacks[o.id].resolve(o); break; case "error": r._callbacks[o.id].reject(o); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"') } }, this.workerPool.push(r) } else this.workerPool.sort(function (r, s) { return r._taskLoad > s._taskLoad ? -1 : 1 }); const i = this.workerPool[this.workerPool.length - 1]; return i._taskCosts[e] = t, i._taskLoad += t, i }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
} function zV() { let n, e; onmessage = function (o) { const a = o.data; switch (a.type) { case "init": n = a.decoderConfig, e = new Promise(function (d) { n.onModuleLoaded = function (h) { d({ draco: h }) }, DracoDecoderModule(n) }); break; case "decode": const l = a.buffer, f = a.taskConfig; e.then(d => { const h = d.draco, p = new h.Decoder, m = new h.DecoderBuffer; m.Init(new Int8Array(l), l.byteLength); try { const v = t(h, p, m, f), y = v.attributes.map(x => x.array.buffer); v.index && y.push(v.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: v }, y) } catch (v) { console.error(v), self.postMessage({ type: "error", id: a.id, error: v.message }) } finally { h.destroy(m), h.destroy(p) } }); break } }; function t(o, a, l, f) { const d = f.attributeIDs, h = f.attributeTypes; let p, m; const v = a.GetEncodedGeometryType(l); if (v === o.TRIANGULAR_MESH) p = new o.Mesh, m = a.DecodeBufferToMesh(l, p); else if (v === o.POINT_CLOUD) p = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, p); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!m.ok() || p.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg()); const y = { index: null, attributes: [] }; for (const x in d) { const A = self[h[x]]; let _, w; if (f.useUniqueIDs) w = d[x], _ = a.GetAttributeByUniqueId(p, w); else { if (w = a.GetAttributeId(p, o[d[x]]), w === -1) continue; _ = a.GetAttribute(p, w) } y.attributes.push(r(o, a, p, x, A, _)) } return v === o.TRIANGULAR_MESH && (y.index = i(o, a, p)), o.destroy(p), y } function i(o, a, l) { const d = l.num_faces() * 3, h = d * 4, p = o._malloc(h); a.GetTrianglesUInt32Array(l, h, p); const m = new Uint32Array(o.HEAPF32.buffer, p, d).slice(); return o._free(p), { array: m, itemSize: 1 } } function r(o, a, l, f, d, h) { const p = h.num_components(), v = l.num_points() * p, y = v * d.BYTES_PER_ELEMENT, x = s(o, d), A = o._malloc(y); a.GetAttributeDataArrayForAllPoints(l, h, x, y, A); const _ = new d(o.HEAPF32.buffer, A, v).slice(); return o._free(A), { name: f, array: _, itemSize: p } } function s(o, a) { switch (a) { case Float32Array: return o.DT_FLOAT32; case Int8Array: return o.DT_INT8; case Int16Array: return o.DT_INT16; case Int32Array: return o.DT_INT32; case Uint8Array: return o.DT_UINT8; case Uint16Array: return o.DT_UINT16; case Uint32Array: return o.DT_UINT32 } } } let Op; const fv = () => { if (Op) return Op; const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), i = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if (typeof WebAssembly != "object") return { supported: !1 }; let r = n; WebAssembly.validate(t) && (r = e); let s; const o = WebAssembly.instantiate(a(r), {}).then(h => { s = h.instance, s.exports.__wasm_call_ctors() }); function a(h) { const p = new Uint8Array(h.length); for (let v = 0; v < h.length; ++v) { const y = h.charCodeAt(v); p[v] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62 } let m = 0; for (let v = 0; v < h.length; ++v)p[m++] = p[v] < 60 ? i[p[v]] : (p[v] - 60) * 64 + p[++v]; return p.buffer.slice(0, m) } function l(h, p, m, v, y, x) { const A = s.exports.sbrk, _ = m + 3 & -4, w = A(_ * v), S = A(y.length), T = new Uint8Array(s.exports.memory.buffer); T.set(y, S); const P = h(w, m, v, S, y.length); if (P === 0 && x && x(w, _, v), p.set(T.subarray(w, w + m * v)), A(w - A(0)), P !== 0) throw new Error(`Malformed buffer data: ${P}`) } const f = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, d = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return Op = { ready: o, supported: !0, decodeVertexBuffer(h, p, m, v, y) { l(s.exports.meshopt_decodeVertexBuffer, h, p, m, v, s.exports[f[y]]) }, decodeIndexBuffer(h, p, m, v) { l(s.exports.meshopt_decodeIndexBuffer, h, p, m, v) }, decodeIndexSequence(h, p, m, v) { l(s.exports.meshopt_decodeIndexSequence, h, p, m, v) }, decodeGltfBuffer(h, p, m, v, y, x) { l(s.exports[d[y]], h, p, m, v, s.exports[f[x]]) } }, Op }, YE = n => n === Object(n) && !Array.isArray(n) && typeof n != "function"; function T_(n, e) { const t = Fi(r => r.gl), i = Zo(Bd, YE(n) ? Object.values(n) : n); if (z.useLayoutEffect(() => { e == null || e(i) }, [e]), z.useEffect(() => { (Array.isArray(i) ? i : [i]).forEach(t.initTexture) }, [t, i]), YE(n)) { const r = Object.keys(n), s = {}; return r.forEach(o => Object.assign(s, { [o]: i[r.indexOf(o)] })), s } else return i } T_.preload = n => Zo.preload(Bd, n); T_.clear = n => Zo.clear(Bd, n); function GV(n) { return Array.isArray(n) } function dv(n = [0, 0, 0]) { return GV(n) ? n : n instanceof I || n instanceof sl ? [n.x, n.y, n.z] : [n, n, n] } function HV({ debug: n, mesh: e, children: t, position: i, rotation: r, scale: s, ...o }) { const a = z.useRef(null), l = z.useRef(null); return z.useLayoutEffect(() => { const f = (e == null ? void 0 : e.current) || a.current.parent, d = a.current; if (!(f instanceof Tn)) throw new Error('Decal must have a Mesh as parent or specify its "mesh" prop'); const h = { position: new I, rotation: new sl, scale: new I(1, 1, 1) }; if (f) { So(h, { position: i, scale: s }); const p = f.matrixWorld.clone(); if (f.matrixWorld.identity(), !r || typeof r == "number") { const m = new bt; m.position.copy(h.position), m.lookAt(f.position), typeof r == "number" && m.rotateZ(r), So(h, { rotation: m.rotation }) } else So(h, { rotation: r }); return d.geometry = new kV(f, h.position, h.rotation, h.scale), l.current && So(l.current, h), f.matrixWorld = p, () => { d.geometry.dispose() } } }, [e, ...dv(i), ...dv(s), ...dv(r)]), z.createElement("mesh", { ref: a }, t || z.createElement("meshStandardMaterial", mr({ transparent: !0, polygonOffset: !0, polygonOffsetFactor: -10 }, o)), n && z.createElement("mesh", { ref: l }, z.createElement("boxGeometry", null), z.createElement("meshNormalMaterial", { wireframe: !0 }), z.createElement("axesHelper", null))) } let kp = null; function O3(n, e, t) { return i => { t && t(i), n && (kp || (kp = new UV), kp.setDecoderPath(typeof n == "string" ? n : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"), i.setDRACOLoader(kp)), e && i.setMeshoptDecoder(typeof fv == "function" ? fv() : fv) } } function b_(n, e = !0, t = !0, i) { return Zo(E_, n, O3(e, t, i)) } b_.preload = (n, e = !0, t = !0, i) => Zo.preload(E_, n, O3(e, t, i)); b_.clear = n => Zo.clear(E_, n); const k3 = z.forwardRef(({ makeDefault: n, camera: e, regress: t, domElement: i, enableDamping: r = !0, onChange: s, onStart: o, onEnd: a, ...l }, f) => { const d = Fi(T => T.invalidate), h = Fi(T => T.camera), p = Fi(T => T.gl), m = Fi(T => T.events), v = Fi(T => T.setEvents), y = Fi(T => T.set), x = Fi(T => T.get), A = Fi(T => T.performance), _ = e || h, w = i || m.connected || p.domElement, S = z.useMemo(() => new lV(_), [_]); return Zu(() => { S.enabled && S.update() }, -1), z.useEffect(() => (S.connect(w), () => void S.dispose()), [w, t, S, d]), z.useEffect(() => { const T = E => { d(), t && A.regress(), s && s(E) }, P = E => { o && o(E) }, R = E => { a && a(E) }; return S.addEventListener("change", T), S.addEventListener("start", P), S.addEventListener("end", R), () => { S.removeEventListener("start", P), S.removeEventListener("end", R), S.removeEventListener("change", T) } }, [s, o, a, S, d, v]), z.useEffect(() => { if (n) { const T = x().controls; return y({ controls: S }), () => y({ controls: T }) } }, [n, S]), z.createElement("primitive", mr({ ref: f, object: S, enableDamping: r }, l)) }); class VV extends yd {
	constructor(e) {
		super(e), this.onBeforeCompile = (t, i) => {
			const { isWebGL2: r } = i.capabilities; t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${r ? "#include <output_fragment>" : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `)
		}
	}
} const WV = z.forwardRef((n, e) => { const [t] = z.useState(() => new VV(null)); return z.createElement("primitive", mr({}, n, { object: t, ref: e, attach: "material" })) }), jV = z.forwardRef(({ children: n, speed: e = 1, rotationIntensity: t = 1, floatIntensity: i = 1, floatingRange: r = [-.1, .1], ...s }, o) => { const a = z.useRef(null), l = z.useRef(Math.random() * 1e4); return Zu(f => { var d, h; const p = l.current + f.clock.getElapsedTime(); a.current.rotation.x = Math.cos(p / 4 * e) / 8 * t, a.current.rotation.y = Math.sin(p / 4 * e) / 8 * t, a.current.rotation.z = Math.sin(p / 4 * e) / 20 * t; let m = Math.sin(p / 4 * e) / 10; m = UA.mapLinear(m, -.1, .1, (d = r == null ? void 0 : r[0]) !== null && d !== void 0 ? d : -.1, (h = r == null ? void 0 : r[1]) !== null && h !== void 0 ? h : .1), a.current.position.y = m * i }), z.createElement("group", s, z.createElement("group", { ref: C_([a, o]) }, n)) }); let ya, jc; const JV = z.createContext(null), KE = new it, QE = new I, XV = z.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => { const s = z.useRef(null), [o, a] = z.useState([]), [[l, f, d]] = z.useState(() => [new Float32Array(t * 3), Float32Array.from({ length: t * 3 }, () => 1), Float32Array.from({ length: t }, () => 1)]); z.useEffect(() => { s.current.geometry.attributes.position.needsUpdate = !0 }), Zu(() => { for (s.current.updateMatrix(), s.current.updateMatrixWorld(), KE.copy(s.current.matrixWorld).invert(), s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, o.length), ya = 0; ya < o.length; ya++)jc = o[ya].current, jc.getWorldPosition(QE).applyMatrix4(KE), QE.toArray(l, ya * 3), s.current.geometry.attributes.position.needsUpdate = !0, jc.matrixWorldNeedsUpdate = !0, jc.color.toArray(f, ya * 3), s.current.geometry.attributes.color.needsUpdate = !0, d.set([jc.size], ya), s.current.geometry.attributes.size.needsUpdate = !0 }); const h = z.useMemo(() => ({ getParent: () => s, subscribe: p => (a(m => [...m, p]), () => a(m => m.filter(v => v.current !== p.current))) }), []); return z.createElement("points", mr({ userData: { instances: o }, matrixAutoUpdate: !1, ref: C_([r, s]), raycast: () => null }, i), z.createElement("bufferGeometry", null, z.createElement("bufferAttribute", { attach: "attributes-position", count: l.length / 3, array: l, itemSize: 3, usage: Va }), z.createElement("bufferAttribute", { attach: "attributes-color", count: f.length / 3, array: f, itemSize: 3, usage: Va }), z.createElement("bufferAttribute", { attach: "attributes-size", count: d.length, array: d, itemSize: 1, usage: Va })), z.createElement(JV.Provider, { value: h }, n)) }), YV = z.forwardRef(({ children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s }, o) => { const a = z.useRef(null); return Zu(() => { const l = a.current.geometry.attributes; l.position.needsUpdate = !0, t && (l.color.needsUpdate = !0), i && (l.size.needsUpdate = !0) }), z.createElement("points", mr({ ref: C_([o, a]) }, s), z.createElement("bufferGeometry", null, z.createElement("bufferAttribute", { attach: "attributes-position", count: e.length / r, array: e, itemSize: r, usage: Va }), t && z.createElement("bufferAttribute", { attach: "attributes-color", count: t.length / r, array: t, itemSize: 3, usage: Va }), i && z.createElement("bufferAttribute", { attach: "attributes-size", count: i.length / r, array: i, itemSize: 1, usage: Va })), n) }), KV = z.forwardRef((n, e) => n.positions instanceof Float32Array ? z.createElement(YV, mr({}, n, { ref: e })) : z.createElement(XV, mr({}, n, { ref: e }))); var Vm = {}, QV = { get exports() { return Vm }, set exports(n) { Vm = n } }, ZV = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", qV = ZV, $V = qV; function U3() { } function z3() { } z3.resetWarningCache = U3; var e8 = function () { function n(i, r, s, o, a, l) { if (l !== $V) { var f = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw f.name = "Invariant Violation", f } } n.isRequired = n; function e() { return n } var t = { array: n, bigint: n, bool: n, func: n, number: n, object: n, string: n, symbol: n, any: n, arrayOf: e, element: n, elementType: n, instanceOf: e, node: n, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: z3, resetWarningCache: U3 }; return t.PropTypes = t, t }; QV.exports = e8(); function P_({ all: n, scene: e, camera: t }) { const i = Fi(({ gl: o }) => o), r = Fi(({ camera: o }) => o), s = Fi(({ scene: o }) => o); return z.useLayoutEffect(() => { const o = []; n && (e || s).traverse(f => { f.visible === !1 && (o.push(f), f.visible = !0) }), i.compile(e || s, t || r); const a = new jA(128); new WA(.01, 1e5, a).update(i, e || s), a.dispose(), o.forEach(f => f.visible = !1) }, []), null } const G3 = () => { const { progress: n } = q5(); return st(Z5, { as: "div", center: !0, style: { display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" }, children: [ye("span", { className: "canvas-loader" }), st("p", { style: { fontSize: 14, color: "#F1F1F1", fontWeight: 800, marginTop: 40 }, children: [n.toFixed(2), "%"] })] }) }, t8 = () => { const n = b_("./planet/scene.gltf"); return ye("primitive", { object: n.scene, scale: 2.5, "position-y": 0, "rotation-y": 0 }) }, n8 = () => ye(w_, { shadows: !0, frameloop: "demand", dpr: [1, 2], gl: { preserveDrawingBuffer: !0 }, camera: { fov: 45, near: .1, far: 200, position: [-4, 3, 6] }, children: st(z.Suspense, { fallback: ye(G3, {}), children: [ye(k3, { autoRotate: !0, enableZoom: !1, maxPolarAngle: Math.PI / 2, minPolarAngle: Math.PI / 2 }), ye(t8, {}), ye(P_, { all: !0 })] }) }), i8 = n => { const [e] = T_([n.imgUrl]); return st(jV, { speed: 1.75, rotationIntensity: 1, floatIntensity: 2, children: [ye("ambientLight", { intensity: .25 }), ye("directionalLight", { position: [0, 0, .05] }), st("mesh", { castShadow: !0, receiveShadow: !0, scale: 2.75, children: [ye("icosahedronGeometry", { args: [1, 4] }), ye("meshStandardMaterial", { color: "#fff8eb", polygonOffset: !0, polygonOffsetFactor: -5, flatShading: !0 }), ye(HV, { position: [0, 0, 1], rotation: [2 * Math.PI, 0, 6.25], scale: 1, map: e, flatShading: !0 })] })] }) }, r8 = ({ icon: n }) => st(w_, { frameloop: "demand", dpr: [1, 2], gl: { preserveDrawingBuffer: !0 }, children: [st(z.Suspense, { fallback: ye(G3, {}), children: [ye(k3, { enableZoom: !1 }), ye(i8, { imgUrl: n })] }), ye(P_, { all: !0 })] }), s8 = n => { const e = z.useRef(), [t] = z.useState(() => sV(new Float32Array(5e3), { radius: 1.2 })); return Zu((i, r) => { e.current.rotation.x -= r / 10, e.current.rotation.y -= r / 15 }), ye("group", { rotation: [0, 0, Math.PI / 4], children: ye(KV, { ref: e, positions: t, stride: 3, frustumCulled: !0, ...n, children: ye(WV, { transparent: !0, color: "#f272c8", size: .002, sizeAttenuation: !0, depthWrite: !1 }) }) }) }, o8 = () => ye("div", { className: "w-full h-auto absolute inset-0 z-[-1]", children: st(w_, { camera: { position: [0, 0, 1] }, children: [ye(z.Suspense, { fallback: null, children: ye(s8, {}) }), ye(P_, { all: !0 })] }) }), H3 = z.createContext({ transformPagePoint: n => n, isStatic: !1, reducedMotion: "never" }), Dg = z.createContext({}); function a8() { return z.useContext(Dg).visualElement } const B_ = z.createContext(null), Ig = typeof document < "u", ZE = Ig ? z.useLayoutEffect : z.useEffect, V3 = z.createContext({ strict: !1 }); function l8(n, e, t, i) { const r = a8(), s = z.useContext(V3), o = z.useContext(B_), a = z.useContext(H3).reducedMotion, l = z.useRef(); i = i || s.renderer, !l.current && i && (l.current = i(n, { visualState: e, parent: r, props: t, presenceContext: o, blockInitialAnimation: o ? o.initial === !1 : !1, reducedMotionConfig: a })); const f = l.current; return z.useInsertionEffect(() => { f && f.update(t, o) }), ZE(() => { f && f.render() }), z.useEffect(() => { f && f.updateFeatures() }), (window.HandoffAppearAnimations ? ZE : z.useEffect)(() => { f && f.animationState && f.animationState.animateChanges() }), f } function uu(n) { return typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current") } function u8(n, e, t) { return z.useCallback(i => { i && n.mount && n.mount(i), e && (i ? e.mount(i) : e.unmount()), t && (typeof t == "function" ? t(i) : uu(t) && (t.current = i)) }, [e]) } function ed(n) { return typeof n == "string" || Array.isArray(n) } function Fg(n) { return typeof n == "object" && typeof n.start == "function" } const R_ = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], L_ = ["initial", ...R_]; function Ng(n) { return Fg(n.animate) || L_.some(e => ed(n[e])) } function W3(n) { return Boolean(Ng(n) || n.variants) } function c8(n, e) { if (Ng(n)) { const { initial: t, animate: i } = n; return { initial: t === !1 || ed(t) ? t : void 0, animate: ed(i) ? i : void 0 } } return n.inherit !== !1 ? e : {} } function f8(n) { const { initial: e, animate: t } = c8(n, z.useContext(Dg)); return z.useMemo(() => ({ initial: e, animate: t }), [qE(e), qE(t)]) } function qE(n) { return Array.isArray(n) ? n.join(" ") : n } const $E = { animation: ["animate", "exit", "variants", "whileHover", "whileTap", "whileFocus", "whileDrag", "whileInView"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, td = {}; for (const n in $E) td[n] = { isEnabled: e => $E[n].some(t => !!e[t]) }; function d8(n) { for (const e in n) td[e] = { ...td[e], ...n[e] } } function j3(n) { const e = z.useRef(null); return e.current === null && (e.current = n()), e.current } const mf = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let h8 = 1; function p8() { return j3(() => { if (mf.hasEverUpdated) return h8++ }) } const J3 = z.createContext({}), X3 = z.createContext({}), m8 = Symbol.for("motionComponentSymbol"); function g8({ preloadedFeatures: n, createVisualElement: e, useRender: t, useVisualState: i, Component: r }) { n && d8(n); function s(a, l) { let f; const d = { ...z.useContext(H3), ...a, layoutId: y8(a) }, { isStatic: h } = d, p = f8(a), m = h ? void 0 : p8(), v = i(a, h); if (!h && Ig) { p.visualElement = l8(r, v, d, e); const y = z.useContext(X3), x = z.useContext(V3).strict; p.visualElement && (f = p.visualElement.loadFeatures(d, x, n, m, y)) } return z.createElement(Dg.Provider, { value: p }, f && p.visualElement ? z.createElement(f, { visualElement: p.visualElement, ...d }) : null, t(r, a, m, u8(v, p.visualElement, l), v, h, p.visualElement)) } const o = z.forwardRef(s); return o[m8] = r, o } function y8({ layoutId: n }) { const e = z.useContext(J3).id; return e && n !== void 0 ? e + "-" + n : n } function v8(n) { function e(i, r = {}) { return g8(n(i, r)) } if (typeof Proxy > "u") return e; const t = new Map; return new Proxy(e, { get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)) }) } const x8 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function D_(n) { return typeof n != "string" || n.includes("-") ? !1 : !!(x8.indexOf(n) > -1 || /[A-Z]/.test(n)) } const Wm = {}; function A8(n) { Object.assign(Wm, n) } const Og = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], cl = new Set(Og); function Y3(n, { layout: e, layoutId: t }) { return cl.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!Wm[n] || n === "opacity") } const Ti = n => Boolean(n && n.getVelocity), _8 = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, M8 = Og.length; function w8(n, { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 }, i, r) { let s = ""; for (let o = 0; o < M8; o++) { const a = Og[o]; if (n[a] !== void 0) { const l = _8[a] || a; s += `${l}(${n[a]}) ` } } return e && !n.z && (s += "translateZ(0)"), s = s.trim(), r ? s = r(n, i ? "" : s) : t && i && (s = "none"), s } const K3 = n => e => typeof e == "string" && e.startsWith(n), Q3 = K3("--"), g1 = K3("var(--"), S8 = (n, e) => e && typeof n == "number" ? e.transform(n) : n, ku = (n, e, t) => Math.min(Math.max(t, n), e), fl = { test: n => typeof n == "number", parse: parseFloat, transform: n => n }, gf = { ...fl, transform: n => ku(0, 1, n) }, Up = { ...fl, default: 1 }, yf = n => Math.round(n * 1e5) / 1e5, nd = /(-)?([\d]*\.?[\d])+/g, y1 = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, C8 = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i; function Dd(n) { return typeof n == "string" } const Id = n => ({ test: e => Dd(e) && e.endsWith(n) && e.split(" ").length === 1, parse: parseFloat, transform: e => `${e}${n}` }), ho = Id("deg"), ns = Id("%"), nt = Id("px"), E8 = Id("vh"), T8 = Id("vw"), eT = { ...ns, parse: n => ns.parse(n) / 100, transform: n => ns.transform(n * 100) }, tT = { ...fl, transform: Math.round }, Z3 = { borderWidth: nt, borderTopWidth: nt, borderRightWidth: nt, borderBottomWidth: nt, borderLeftWidth: nt, borderRadius: nt, radius: nt, borderTopLeftRadius: nt, borderTopRightRadius: nt, borderBottomRightRadius: nt, borderBottomLeftRadius: nt, width: nt, maxWidth: nt, height: nt, maxHeight: nt, size: nt, top: nt, right: nt, bottom: nt, left: nt, padding: nt, paddingTop: nt, paddingRight: nt, paddingBottom: nt, paddingLeft: nt, margin: nt, marginTop: nt, marginRight: nt, marginBottom: nt, marginLeft: nt, rotate: ho, rotateX: ho, rotateY: ho, rotateZ: ho, scale: Up, scaleX: Up, scaleY: Up, scaleZ: Up, skew: ho, skewX: ho, skewY: ho, distance: nt, translateX: nt, translateY: nt, translateZ: nt, x: nt, y: nt, z: nt, perspective: nt, transformPerspective: nt, opacity: gf, originX: eT, originY: eT, originZ: nt, zIndex: tT, fillOpacity: gf, strokeOpacity: gf, numOctaves: tT }; function I_(n, e, t, i) { const { style: r, vars: s, transform: o, transformOrigin: a } = n; let l = !1, f = !1, d = !0; for (const h in e) { const p = e[h]; if (Q3(h)) { s[h] = p; continue } const m = Z3[h], v = S8(p, m); if (cl.has(h)) { if (l = !0, o[h] = v, !d) continue; p !== (m.default || 0) && (d = !1) } else h.startsWith("origin") ? (f = !0, a[h] = v) : r[h] = v } if (e.transform || (l || i ? r.transform = w8(n.transform, t, d, i) : r.transform && (r.transform = "none")), f) { const { originX: h = "50%", originY: p = "50%", originZ: m = 0 } = a; r.transformOrigin = `${h} ${p} ${m}` } } const F_ = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function q3(n, e, t) { for (const i in e) !Ti(e[i]) && !Y3(i, t) && (n[i] = e[i]) } function b8({ transformTemplate: n }, e, t) { return z.useMemo(() => { const i = F_(); return I_(i, e, { enableHardwareAcceleration: !t }, n), Object.assign({}, i.vars, i.style) }, [e]) } function P8(n, e, t) { const i = n.style || {}, r = {}; return q3(r, i, n), Object.assign(r, b8(n, e, t)), n.transformValues ? n.transformValues(r) : r } function B8(n, e, t) { const i = {}, r = P8(n, e, t); return n.drag && n.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (i.tabIndex = 0), i.style = r, i } const R8 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]); function jm(n) { return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || R8.has(n) } let $3 = n => !jm(n); function L8(n) { n && ($3 = e => e.startsWith("on") ? !jm(e) : n(e)) } try { L8(require("@emotion/is-prop-valid").default) } catch { } function D8(n, e, t) { const i = {}; for (const r in n) r === "values" && typeof n.values == "object" || ($3(r) || t === !0 && jm(r) || !e && !jm(r) || n.draggable && r.startsWith("onDrag")) && (i[r] = n[r]); return i } function nT(n, e, t) { return typeof n == "string" ? n : nt.transform(e + t * n) } function I8(n, e, t) { const i = nT(e, n.x, n.width), r = nT(t, n.y, n.height); return `${i} ${r}` } const F8 = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, N8 = { offset: "strokeDashoffset", array: "strokeDasharray" }; function O8(n, e, t = 1, i = 0, r = !0) { n.pathLength = 1; const s = r ? F8 : N8; n[s.offset] = nt.transform(-i); const o = nt.transform(e), a = nt.transform(t); n[s.array] = `${o} ${a}` } function N_(n, { attrX: e, attrY: t, originX: i, originY: r, pathLength: s, pathSpacing: o = 1, pathOffset: a = 0, ...l }, f, d, h) { if (I_(n, l, f, h), d) { n.style.viewBox && (n.attrs.viewBox = n.style.viewBox); return } n.attrs = n.style, n.style = {}; const { attrs: p, style: m, dimensions: v } = n; p.transform && (v && (m.transform = p.transform), delete p.transform), v && (i !== void 0 || r !== void 0 || m.transform) && (m.transformOrigin = I8(v, i !== void 0 ? i : .5, r !== void 0 ? r : .5)), e !== void 0 && (p.x = e), t !== void 0 && (p.y = t), s !== void 0 && O8(p, s, o, a, !1) } const eR = () => ({ ...F_(), attrs: {} }), O_ = n => typeof n == "string" && n.toLowerCase() === "svg"; function k8(n, e, t, i) { const r = z.useMemo(() => { const s = eR(); return N_(s, e, { enableHardwareAcceleration: !1 }, O_(i), n.transformTemplate), { ...s.attrs, style: { ...s.style } } }, [e]); if (n.style) { const s = {}; q3(s, n.style, n), r.style = { ...s, ...r.style } } return r } function U8(n = !1) { return (t, i, r, s, { latestValues: o }, a) => { const f = (D_(t) ? k8 : B8)(i, o, a, t), h = { ...D8(i, typeof t == "string", n), ...f, ref: s }, { children: p } = i, m = z.useMemo(() => Ti(p) ? p.get() : p, [p]); return r && (h["data-projection-id"] = r), z.createElement(t, { ...h, children: m }) } } const k_ = n => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(); function tR(n, { style: e, vars: t }, i, r) { Object.assign(n.style, e, r && r.getProjectionStyles(i)); for (const s in t) n.style.setProperty(s, t[s]) } const nR = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function iR(n, e, t, i) { tR(n, e, void 0, i); for (const r in e.attrs) n.setAttribute(nR.has(r) ? r : k_(r), e.attrs[r]) } function U_(n, e) { const { style: t } = n, i = {}; for (const r in t) (Ti(t[r]) || e.style && Ti(e.style[r]) || Y3(r, n)) && (i[r] = t[r]); return i } function rR(n, e) { const t = U_(n, e); for (const i in n) if (Ti(n[i]) || Ti(e[i])) { const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i; t[r] = n[i] } return t } function z_(n, e, t, i = {}, r = {}) { return typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), typeof e == "string" && (e = n.variants && n.variants[e]), typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)), e } const Jm = n => Array.isArray(n), z8 = n => Boolean(n && typeof n == "object" && n.mix && n.toValue), G8 = n => Jm(n) ? n[n.length - 1] || 0 : n; function fm(n) { const e = Ti(n) ? n.get() : n; return z8(e) ? e.toValue() : e } function H8({ scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t }, i, r, s) { const o = { latestValues: V8(i, r, s, n), renderState: e() }; return t && (o.mount = a => t(i, a, o)), o } const sR = n => (e, t) => { const i = z.useContext(Dg), r = z.useContext(B_), s = () => H8(n, e, i, r); return t ? s() : j3(s) }; function V8(n, e, t, i) { const r = {}, s = i(n, {}); for (const p in s) r[p] = fm(s[p]); let { initial: o, animate: a } = n; const l = Ng(n), f = W3(n); e && f && !l && n.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate)); let d = t ? t.initial === !1 : !1; d = d || o === !1; const h = d ? a : o; return h && typeof h != "boolean" && !Fg(h) && (Array.isArray(h) ? h : [h]).forEach(m => { const v = z_(n, m); if (!v) return; const { transitionEnd: y, transition: x, ...A } = v; for (const _ in A) { let w = A[_]; if (Array.isArray(w)) { const S = d ? w.length - 1 : 0; w = w[S] } w !== null && (r[_] = w) } for (const _ in y) r[_] = y[_] }), r } const W8 = { useVisualState: sR({ scrapeMotionValuesFromProps: rR, createRenderState: eR, onMount: (n, e, { renderState: t, latestValues: i }) => { try { t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect() } catch { t.dimensions = { x: 0, y: 0, width: 0, height: 0 } } N_(t, i, { enableHardwareAcceleration: !1 }, O_(e.tagName), n.transformTemplate), iR(e, t) } }) }, j8 = { useVisualState: sR({ scrapeMotionValuesFromProps: U_, createRenderState: F_ }) }; function J8(n, { forwardMotionProps: e = !1 }, t, i) { return { ...D_(n) ? W8 : j8, preloadedFeatures: t, useRender: U8(e), createVisualElement: i, Component: n } } function Ds(n, e, t, i = { passive: !0 }) { return n.addEventListener(e, t, i), () => n.removeEventListener(e, t) } const oR = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1; function kg(n, e = "page") { return { point: { x: n[e + "X"], y: n[e + "Y"] } } } const X8 = n => e => oR(e) && n(e, kg(e)); function Ns(n, e, t, i) { return Ds(n, e, X8(t), i) } const Y8 = (n, e) => t => e(n(t)), Io = (...n) => n.reduce(Y8); function aR(n) { let e = null; return () => { const t = () => { e = null }; return e === null ? (e = n, t) : !1 } } const iT = aR("dragHorizontal"), rT = aR("dragVertical"); function lR(n) { let e = !1; if (n === "y") e = rT(); else if (n === "x") e = iT(); else { const t = iT(), i = rT(); t && i ? e = () => { t(), i() } : (t && t(), i && i()) } return e } function uR() { const n = lR(!0); return n ? (n(), !1) : !0 } class qo { constructor(e) { this.isMounted = !1, this.node = e } update() { } } function sT(n, e) { const t = "pointer" + (e ? "enter" : "leave"), i = "onHover" + (e ? "Start" : "End"), r = (s, o) => { if (s.type === "touch" || uR()) return; const a = n.getProps(); n.animationState && a.whileHover && n.animationState.setActive("whileHover", e), a[i] && a[i](s, o) }; return Ns(n.current, t, r, { passive: !n.getProps()[i] }) } class K8 extends qo { mount() { this.unmount = Io(sT(this.node, !0), sT(this.node, !1)) } unmount() { } } class Q8 extends qo { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch { e = !0 } !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Io(Ds(this.node.current, "focus", () => this.onFocus()), Ds(this.node.current, "blur", () => this.onBlur())) } unmount() { } } const cR = (n, e) => e ? n === e ? !0 : cR(n, e.parentElement) : !1, dr = n => n; function hv(n, e) { if (!e) return; const t = new PointerEvent("pointer" + n); e(t, kg(t)) } class Z8 extends qo { constructor() { super(...arguments), this.removeStartListeners = dr, this.removeEndListeners = dr, this.removeAccessibleListeners = dr, this.startPointerPress = (e, t) => { if (this.removeEndListeners(), this.isPressing) return; const i = this.node.getProps(), s = Ns(window, "pointerup", (a, l) => { if (!this.checkPressEnd()) return; const { onTap: f, onTapCancel: d } = this.node.getProps(); cR(this.node.current, a.target) ? f && f(a, l) : d && d(a, l) }, { passive: !(i.onTap || i.onPointerUp) }), o = Ns(window, "pointercancel", (a, l) => this.cancelPress(a, l), { passive: !(i.onTapCancel || i.onPointerCancel) }); this.removeEndListeners = Io(s, o), this.startPress(e, t) }, this.startAccessiblePress = () => { const e = s => { if (s.key !== "Enter" || this.isPressing) return; const o = a => { a.key !== "Enter" || !this.checkPressEnd() || hv("up", this.node.getProps().onTap) }; this.removeEndListeners(), this.removeEndListeners = Ds(this.node.current, "keyup", o), hv("down", (a, l) => { this.startPress(a, l) }) }, t = Ds(this.node.current, "keydown", e), i = () => { this.isPressing && hv("cancel", (s, o) => this.cancelPress(s, o)) }, r = Ds(this.node.current, "blur", i); this.removeAccessibleListeners = Io(t, r) } } startPress(e, t) { this.isPressing = !0; const { onTapStart: i, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), i && i(e, t) } checkPressEnd() { return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !uR() } cancelPress(e, t) { if (!this.checkPressEnd()) return; const { onTapCancel: i } = this.node.getProps(); i && i(e, t) } mount() { const e = this.node.getProps(), t = Ns(this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), i = Ds(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Io(t, i) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } const v1 = new WeakMap, pv = new WeakMap, q8 = n => { const e = v1.get(n.target); e && e(n) }, $8 = n => { n.forEach(q8) }; function e9({ root: n, ...e }) { const t = n || document; pv.has(t) || pv.set(t, {}); const i = pv.get(t), r = JSON.stringify(e); return i[r] || (i[r] = new IntersectionObserver($8, { root: n, ...e })), i[r] } function t9(n, e, t) { const i = e9(e); return v1.set(n, t), i.observe(n), () => { v1.delete(n), i.unobserve(n) } } const n9 = { some: 0, all: 1 }; class i9 extends qo { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } viewportFallback() { requestAnimationFrame(() => { this.hasEnteredView = !0; const { onViewportEnter: e } = this.node.getProps(); e && e(null), this.node.animationState && this.node.animationState.setActive("whileInView", !0) }) } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: t, margin: i, amount: r = "some", once: s, fallback: o = !0 } = e; if (typeof IntersectionObserver > "u") { o && this.viewportFallback(); return } const a = { root: t ? t.current : void 0, rootMargin: i, threshold: typeof r == "number" ? r : n9[r] }, l = f => { const { isIntersecting: d } = f; if (this.isInView === d || (this.isInView = d, s && !d && this.hasEnteredView)) return; d && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", d); const { onViewportEnter: h, onViewportLeave: p } = this.node.getProps(), m = d ? h : p; m && m(f) }; return t9(this.node.current, a, l) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: e, prevProps: t } = this.node;["amount", "margin", "root"].some(r9(e, t)) && this.startObserver() } unmount() { } } function r9({ viewport: n = {} }, { viewport: e = {} } = {}) { return t => n[t] !== e[t] } const s9 = { inView: { Feature: i9 }, tap: { Feature: Z8 }, focus: { Feature: Q8 }, hover: { Feature: K8 } }; function fR(n, e) { if (!Array.isArray(e)) return !1; const t = e.length; if (t !== n.length) return !1; for (let i = 0; i < t; i++)if (e[i] !== n[i]) return !1; return !0 } const o9 = n => /^\-?\d*\.?\d+$/.test(n), a9 = n => /^0[^.\s]+$/.test(n), Os = { delta: 0, timestamp: 0 }, dR = 1 / 60 * 1e3, l9 = typeof performance < "u" ? () => performance.now() : () => Date.now(), hR = typeof window < "u" ? n => window.requestAnimationFrame(n) : n => setTimeout(() => n(l9()), dR); function u9(n) { let e = [], t = [], i = 0, r = !1, s = !1; const o = new WeakSet, a = { schedule: (l, f = !1, d = !1) => { const h = d && r, p = h ? e : t; return f && o.add(l), p.indexOf(l) === -1 && (p.push(l), h && r && (i = e.length)), l }, cancel: l => { const f = t.indexOf(l); f !== -1 && t.splice(f, 1), o.delete(l) }, process: l => { if (r) { s = !0; return } if (r = !0, [e, t] = [t, e], t.length = 0, i = e.length, i) for (let f = 0; f < i; f++) { const d = e[f]; d(l), o.has(d) && (a.schedule(d), n()) } r = !1, s && (s = !1, a.process(l)) } }; return a } const c9 = 40; let x1 = !0, id = !1, A1 = !1; const Fd = ["read", "update", "preRender", "render", "postRender"], Ug = Fd.reduce((n, e) => (n[e] = u9(() => id = !0), n), {}), ci = Fd.reduce((n, e) => { const t = Ug[e]; return n[e] = (i, r = !1, s = !1) => (id || d9(), t.schedule(i, r, s)), n }, {}), Ho = Fd.reduce((n, e) => (n[e] = Ug[e].cancel, n), {}), mv = Fd.reduce((n, e) => (n[e] = () => Ug[e].process(Os), n), {}), f9 = n => Ug[n].process(Os), pR = n => { id = !1, Os.delta = x1 ? dR : Math.max(Math.min(n - Os.timestamp, c9), 1), Os.timestamp = n, A1 = !0, Fd.forEach(f9), A1 = !1, id && (x1 = !1, hR(pR)) }, d9 = () => { id = !0, x1 = !0, A1 || hR(pR) }; function G_(n, e) { n.indexOf(e) === -1 && n.push(e) } function H_(n, e) { const t = n.indexOf(e); t > -1 && n.splice(t, 1) } class V_ { constructor() { this.subscriptions = [] } add(e) { return G_(this.subscriptions, e), () => H_(this.subscriptions, e) } notify(e, t, i) { const r = this.subscriptions.length; if (r) if (r === 1) this.subscriptions[0](e, t, i); else for (let s = 0; s < r; s++) { const o = this.subscriptions[s]; o && o(e, t, i) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } function W_(n, e) { return e ? n * (1e3 / e) : 0 } const h9 = n => !isNaN(parseFloat(n)); class p9 { constructor(e, t = {}) { this.version = "9.1.7", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (i, r = !0) => { this.prev = this.current, this.current = i; const { delta: s, timestamp: o } = Os; this.lastUpdated !== o && (this.timeDelta = s, this.lastUpdated = o, ci.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), r && this.events.renderRequest && this.events.renderRequest.notify(this.current) }, this.scheduleVelocityCheck = () => ci.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: i }) => { i !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity())) }, this.hasAnimated = !1, this.prev = this.current = e, this.canTrackVelocity = h9(this.current), this.owner = t.owner } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new V_); const i = this.events[e].add(t); return e === "change" ? () => { i(), ci.read(() => { this.events.change.getSize() || this.stop() }) } : i } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e, t = !0) { !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify) } setWithVelocity(e, t, i) { this.set(t), this.prev = e, this.timeDelta = i } jump(e) { this.updateAndNotify(e), this.prev = e, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return this.current } getPrevious() { return this.prev } getVelocity() { return this.canTrackVelocity ? W_(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0 } start(e) { return this.stop(), new Promise(t => { this.hasAnimated = !0, this.animation = e(t) || null, this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { this.animation = null } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Uu(n, e) { return new p9(n, e) } const j_ = (n, e) => t => Boolean(Dd(t) && C8.test(t) && t.startsWith(n) || e && Object.prototype.hasOwnProperty.call(t, e)), mR = (n, e, t) => i => { if (!Dd(i)) return i; const [r, s, o, a] = i.match(nd); return { [n]: parseFloat(r), [e]: parseFloat(s), [t]: parseFloat(o), alpha: a !== void 0 ? parseFloat(a) : 1 } }, m9 = n => ku(0, 255, n), gv = { ...fl, transform: n => Math.round(m9(n)) }, ka = { test: j_("rgb", "red"), parse: mR("red", "green", "blue"), transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) => "rgba(" + gv.transform(n) + ", " + gv.transform(e) + ", " + gv.transform(t) + ", " + yf(gf.transform(i)) + ")" }; function g9(n) { let e = "", t = "", i = "", r = ""; return n.length > 5 ? (e = n.substring(1, 3), t = n.substring(3, 5), i = n.substring(5, 7), r = n.substring(7, 9)) : (e = n.substring(1, 2), t = n.substring(2, 3), i = n.substring(3, 4), r = n.substring(4, 5), e += e, t += t, i += i, r += r), { red: parseInt(e, 16), green: parseInt(t, 16), blue: parseInt(i, 16), alpha: r ? parseInt(r, 16) / 255 : 1 } } const _1 = { test: j_("#"), parse: g9, transform: ka.transform }, cu = { test: j_("hsl", "hue"), parse: mR("hue", "saturation", "lightness"), transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) => "hsla(" + Math.round(n) + ", " + ns.transform(yf(e)) + ", " + ns.transform(yf(t)) + ", " + yf(gf.transform(i)) + ")" }, oi = { test: n => ka.test(n) || _1.test(n) || cu.test(n), parse: n => ka.test(n) ? ka.parse(n) : cu.test(n) ? cu.parse(n) : _1.parse(n), transform: n => Dd(n) ? n : n.hasOwnProperty("red") ? ka.transform(n) : cu.transform(n) }, gR = "${c}", yR = "${n}"; function y9(n) { var e, t; return isNaN(n) && Dd(n) && (((e = n.match(nd)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = n.match(y1)) === null || t === void 0 ? void 0 : t.length) || 0) > 0 } function Xm(n) { typeof n == "number" && (n = `${n}`); const e = []; let t = 0, i = 0; const r = n.match(y1); r && (t = r.length, n = n.replace(y1, gR), e.push(...r.map(oi.parse))); const s = n.match(nd); return s && (i = s.length, n = n.replace(nd, yR), e.push(...s.map(fl.parse))), { values: e, numColors: t, numNumbers: i, tokenised: n } } function vR(n) { return Xm(n).values } function xR(n) { const { values: e, numColors: t, tokenised: i } = Xm(n), r = e.length; return s => { let o = i; for (let a = 0; a < r; a++)o = o.replace(a < t ? gR : yR, a < t ? oi.transform(s[a]) : yf(s[a])); return o } } const v9 = n => typeof n == "number" ? 0 : n; function x9(n) { const e = vR(n); return xR(n)(e.map(v9)) } const Vo = { test: y9, parse: vR, createTransformer: xR, getAnimatableNone: x9 }, A9 = new Set(["brightness", "contrast", "saturate", "opacity"]); function _9(n) { const [e, t] = n.slice(0, -1).split("("); if (e === "drop-shadow") return n; const [i] = t.match(nd) || []; if (!i) return n; const r = t.replace(i, ""); let s = A9.has(e) ? 1 : 0; return i !== t && (s *= 100), e + "(" + s + r + ")" } const M9 = /([a-z-]*)\(.*?\)/g, M1 = { ...Vo, getAnimatableNone: n => { const e = n.match(M9); return e ? e.map(_9).join(" ") : n } }, w9 = { ...Z3, color: oi, backgroundColor: oi, outlineColor: oi, fill: oi, stroke: oi, borderColor: oi, borderTopColor: oi, borderRightColor: oi, borderBottomColor: oi, borderLeftColor: oi, filter: M1, WebkitFilter: M1 }, J_ = n => w9[n]; function X_(n, e) { let t = J_(n); return t !== M1 && (t = Vo), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0 } const AR = n => e => e.test(n), S9 = { test: n => n === "auto", parse: n => n }, _R = [fl, nt, ns, ho, T8, E8, S9], Jc = n => _R.find(AR(n)), C9 = [..._R, oi, Vo], E9 = n => C9.find(AR(n)); function T9(n) { const e = {}; return n.values.forEach((t, i) => e[i] = t.get()), e } function b9(n) { const e = {}; return n.values.forEach((t, i) => e[i] = t.getVelocity()), e } function zg(n, e, t) { const i = n.getProps(); return z_(i, e, t !== void 0 ? t : i.custom, T9(n), b9(n)) } function P9(n, e, t) { n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Uu(t)) } function B9(n, e) { const t = zg(n, e); let { transitionEnd: i = {}, transition: r = {}, ...s } = t ? n.makeTargetAnimatable(t, !1) : {}; s = { ...s, ...i }; for (const o in s) { const a = G8(s[o]); P9(n, o, a) } } function R9(n, e, t) { var i, r; const s = Object.keys(e).filter(a => !n.hasValue(a)), o = s.length; if (o) for (let a = 0; a < o; a++) { const l = s[a], f = e[l]; let d = null; Array.isArray(f) && (d = f[0]), d === null && (d = (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !== null && r !== void 0 ? r : e[l]), d != null && (typeof d == "string" && (o9(d) || a9(d)) ? d = parseFloat(d) : !E9(d) && Vo.test(f) && (d = X_(l, f)), n.addValue(l, Uu(d, { owner: n })), t[l] === void 0 && (t[l] = d), d !== null && n.setBaseTarget(l, d)) } } function L9(n, e) { return e ? (e[n] || e.default || e).from : void 0 } function D9(n, e, t) { const i = {}; for (const r in n) { const s = L9(r, e); if (s !== void 0) i[r] = s; else { const o = t.getValue(r); o && (i[r] = o.get()) } } return i } function Ym(n) { return Boolean(Ti(n) && n.add) } const I9 = "framerAppearId", F9 = "data-" + k_(I9); let N9 = dr, Km = dr; const dm = n => n * 1e3, O9 = { current: !1 }, Y_ = n => e => e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2, K_ = n => e => 1 - n(1 - e), Q_ = n => n * n, k9 = K_(Q_), Z_ = Y_(Q_), nn = (n, e, t) => -t * n + t * e + n; function yv(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n } function U9({ hue: n, saturation: e, lightness: t, alpha: i }) { n /= 360, e /= 100, t /= 100; let r = 0, s = 0, o = 0; if (!e) r = s = o = t; else { const a = t < .5 ? t * (1 + e) : t + e - t * e, l = 2 * t - a; r = yv(l, a, n + 1 / 3), s = yv(l, a, n), o = yv(l, a, n - 1 / 3) } return { red: Math.round(r * 255), green: Math.round(s * 255), blue: Math.round(o * 255), alpha: i } } const vv = (n, e, t) => { const i = n * n; return Math.sqrt(Math.max(0, t * (e * e - i) + i)) }, z9 = [_1, ka, cu], G9 = n => z9.find(e => e.test(n)); function oT(n) { const e = G9(n); let t = e.parse(n); return e === cu && (t = U9(t)), t } const MR = (n, e) => { const t = oT(n), i = oT(e), r = { ...t }; return s => (r.red = vv(t.red, i.red, s), r.green = vv(t.green, i.green, s), r.blue = vv(t.blue, i.blue, s), r.alpha = nn(t.alpha, i.alpha, s), ka.transform(r)) }; function wR(n, e) { return typeof n == "number" ? t => nn(n, e, t) : oi.test(n) ? MR(n, e) : CR(n, e) } const SR = (n, e) => { const t = [...n], i = t.length, r = n.map((s, o) => wR(s, e[o])); return s => { for (let o = 0; o < i; o++)t[o] = r[o](s); return t } }, H9 = (n, e) => { const t = { ...n, ...e }, i = {}; for (const r in t) n[r] !== void 0 && e[r] !== void 0 && (i[r] = wR(n[r], e[r])); return r => { for (const s in i) t[s] = i[s](r); return t } }, CR = (n, e) => { const t = Vo.createTransformer(e), i = Xm(n), r = Xm(e); return i.numColors === r.numColors && i.numNumbers >= r.numNumbers ? Io(SR(i.values, r.values), t) : o => `${o > 0 ? e : n}` }, rd = (n, e, t) => { const i = e - n; return i === 0 ? 1 : (t - n) / i }, aT = (n, e) => t => nn(n, e, t); function V9(n) { return typeof n == "number" ? aT : typeof n == "string" ? oi.test(n) ? MR : CR : Array.isArray(n) ? SR : typeof n == "object" ? H9 : aT } function W9(n, e, t) { const i = [], r = t || V9(n[0]), s = n.length - 1; for (let o = 0; o < s; o++) { let a = r(n[o], n[o + 1]); if (e) { const l = Array.isArray(e) ? e[o] : e; a = Io(l, a) } i.push(a) } return i } function ER(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) { const s = n.length; Km(s === e.length), Km(!i || !Array.isArray(i) || i.length === s - 1), n[0] > n[s - 1] && (n = [...n].reverse(), e = [...e].reverse()); const o = W9(e, i, r), a = o.length, l = f => { let d = 0; if (a > 1) for (; d < n.length - 2 && !(f < n[d + 1]); d++); const h = rd(n[d], n[d + 1], f); return o[d](h) }; return t ? f => l(ku(n[0], n[s - 1], f)) : l } function j9(n, e) { const t = n[n.length - 1]; for (let i = 1; i <= e; i++) { const r = rd(0, e, i); n.push(nn(t, 1, r)) } } function J9(n) { const e = [0]; return j9(e, n.length - 1), e } function X9(n, e) { return n.map(t => t * e) } const TR = (n, e, t) => (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n, Y9 = 1e-7, K9 = 12; function Q9(n, e, t, i, r) { let s, o, a = 0; do o = e + (t - e) / 2, s = TR(o, i, r) - n, s > 0 ? t = o : e = o; while (Math.abs(s) > Y9 && ++a < K9); return o } function bR(n, e, t, i) { if (n === e && t === i) return dr; const r = s => Q9(s, 0, 1, n, t); return s => s === 0 || s === 1 ? s : TR(r(s), e, i) } const PR = n => 1 - Math.sin(Math.acos(n)), q_ = K_(PR), Z9 = Y_(q_), BR = bR(.33, 1.53, .69, .99), $_ = K_(BR), q9 = Y_($_), $9 = n => (n *= 2) < 1 ? .5 * $_(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))), e6 = { linear: dr, easeIn: Q_, easeInOut: Z_, easeOut: k9, circIn: PR, circInOut: Z9, circOut: q_, backIn: $_, backInOut: q9, backOut: BR, anticipate: $9 }, lT = n => { if (Array.isArray(n)) { Km(n.length === 4); const [e, t, i, r] = n; return bR(e, t, i, r) } else if (typeof n == "string") return e6[n]; return n }, t6 = n => Array.isArray(n) && typeof n[0] != "number"; function n6(n, e) { return n.map(() => e || Z_).splice(0, n.length - 1) } function w1({ keyframes: n, ease: e = Z_, times: t, duration: i = 300 }) { n = [...n]; const r = t6(e) ? e.map(lT) : lT(e), s = { done: !1, value: n[0] }, o = X9(t && t.length === n.length ? t : J9(n), i); function a() { return ER(o, n, { ease: Array.isArray(r) ? r : n6(n, r) }) } let l = a(); return { next: f => (s.value = l(f), s.done = f >= i, s), flipTarget: () => { n.reverse(), l = a() } } } const xv = .001, i6 = .01, uT = 10, r6 = .05, s6 = 1; function o6({ duration: n = 800, bounce: e = .25, velocity: t = 0, mass: i = 1 }) { let r, s; N9(n <= uT * 1e3); let o = 1 - e; o = ku(r6, s6, o), n = ku(i6, uT, n / 1e3), o < 1 ? (r = f => { const d = f * o, h = d * n, p = d - t, m = S1(f, o), v = Math.exp(-h); return xv - p / m * v }, s = f => { const h = f * o * n, p = h * t + t, m = Math.pow(o, 2) * Math.pow(f, 2) * n, v = Math.exp(-h), y = S1(Math.pow(f, 2), o); return (-r(f) + xv > 0 ? -1 : 1) * ((p - m) * v) / y }) : (r = f => { const d = Math.exp(-f * n), h = (f - t) * n + 1; return -xv + d * h }, s = f => { const d = Math.exp(-f * n), h = (t - f) * (n * n); return d * h }); const a = 5 / n, l = l6(r, s, a); if (n = n * 1e3, isNaN(l)) return { stiffness: 100, damping: 10, duration: n }; { const f = Math.pow(l, 2) * i; return { stiffness: f, damping: o * 2 * Math.sqrt(i * f), duration: n } } } const a6 = 12; function l6(n, e, t) { let i = t; for (let r = 1; r < a6; r++)i = i - n(i) / e(i); return i } function S1(n, e) { return n * Math.sqrt(1 - e * e) } const u6 = ["duration", "bounce"], c6 = ["stiffness", "damping", "mass"]; function cT(n, e) { return e.some(t => n[t] !== void 0) } function f6(n) { let e = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...n }; if (!cT(n, c6) && cT(n, u6)) { const t = o6(n); e = { ...e, ...t, velocity: 0, mass: 1 }, e.isResolvedFromDuration = !0 } return e } const d6 = 5; function RR({ keyframes: n, restDelta: e, restSpeed: t, ...i }) { let r = n[0], s = n[n.length - 1]; const o = { done: !1, value: r }, { stiffness: a, damping: l, mass: f, velocity: d, duration: h, isResolvedFromDuration: p } = f6(i); let m = h6, v = d ? -(d / 1e3) : 0; const y = l / (2 * Math.sqrt(a * f)); function x() { const A = s - r, _ = Math.sqrt(a / f) / 1e3, w = Math.abs(A) < 5; if (t || (t = w ? .01 : 2), e || (e = w ? .005 : .5), y < 1) { const S = S1(_, y); m = T => { const P = Math.exp(-y * _ * T); return s - P * ((v + y * _ * A) / S * Math.sin(S * T) + A * Math.cos(S * T)) } } else if (y === 1) m = S => s - Math.exp(-_ * S) * (A + (v + _ * A) * S); else { const S = _ * Math.sqrt(y * y - 1); m = T => { const P = Math.exp(-y * _ * T), R = Math.min(S * T, 300); return s - P * ((v + y * _ * A) * Math.sinh(R) + S * A * Math.cosh(R)) / S } } } return x(), { next: A => { const _ = m(A); if (p) o.done = A >= h; else { let w = v; if (A !== 0) if (y < 1) { const P = Math.max(0, A - d6); w = W_(_ - m(P), A - P) } else w = 0; const S = Math.abs(w) <= t, T = Math.abs(s - _) <= e; o.done = S && T } return o.value = o.done ? s : _, o }, flipTarget: () => { v = -v, [r, s] = [s, r], x() } } } RR.needsInterpolation = (n, e) => typeof n == "string" || typeof e == "string"; const h6 = n => 0; function p6({ keyframes: n = [0], velocity: e = 0, power: t = .8, timeConstant: i = 350, restDelta: r = .5, modifyTarget: s }) { const o = n[0], a = { done: !1, value: o }; let l = t * e; const f = o + l, d = s === void 0 ? f : s(f); return d !== f && (l = d - o), { next: h => { const p = -l * Math.exp(-h / i); return a.done = !(p > r || p < -r), a.value = a.done ? d : d + p, a }, flipTarget: () => { } } } const m6 = { decay: p6, keyframes: w1, tween: w1, spring: RR }; function LR(n, e, t = 0) { return n - e - t } function g6(n, e = 0, t = 0, i = !0) { return i ? LR(e + -n, e, t) : e - (n - e) + t } function y6(n, e, t, i) { return i ? n >= e + t : n <= -t } const v6 = n => { const e = ({ delta: t }) => n(t); return { start: () => ci.update(e, !0), stop: () => Ho.update(e) } }; function Qm({ duration: n, driver: e = v6, elapsed: t = 0, repeat: i = 0, repeatType: r = "loop", repeatDelay: s = 0, keyframes: o, autoplay: a = !0, onPlay: l, onStop: f, onComplete: d, onRepeat: h, onUpdate: p, type: m = "keyframes", ...v }) { const y = t; let x, A = 0, _ = n, w = !1, S = !0, T; const P = m6[o.length > 2 ? "keyframes" : m] || w1, R = o[0], E = o[o.length - 1]; let B = { done: !1, value: R }; const { needsInterpolation: L } = P; L && L(R, E) && (T = ER([0, 100], [R, E], { clamp: !1 }), o = [0, 100]); const U = P({ ...v, duration: n, keyframes: o }); function q() { A++, r === "reverse" ? (S = A % 2 === 0, t = g6(t, _, s, S)) : (t = LR(t, _, s), r === "mirror" && U.flipTarget()), w = !1, h && h() } function W() { x && x.stop(), d && d() } function G(ne) { S || (ne = -ne), t += ne, w || (B = U.next(Math.max(0, t)), T && (B.value = T(B.value)), w = S ? B.done : t <= 0), p && p(B.value), w && (A === 0 && (_ = _ !== void 0 ? _ : t), A < i ? y6(t, _, s, S) && q() : W()) } function K() { l && l(), x = e(G), x.start() } return a && K(), { stop: () => { f && f(), x && x.stop() }, set currentTime(ne) { t = y, G(ne) }, sample: ne => { t = y; const oe = n && typeof n == "number" ? Math.max(n * .5, 50) : 50; let N = 0; for (G(0); N <= ne;) { const V = ne - N; G(Math.min(V, oe)), N += oe } return B } } } function x6(n) { return !n || Array.isArray(n) || typeof n == "string" && DR[n] } const ef = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`, DR = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: ef([0, .65, .55, 1]), circOut: ef([.55, 0, 1, .45]), backIn: ef([.31, .01, .66, -.59]), backOut: ef([.33, 1.53, .69, .99]) }; function A6(n) { if (n) return Array.isArray(n) ? ef(n) : DR[n] } function _6(n, e, t, { delay: i = 0, duration: r, repeat: s = 0, repeatType: o = "loop", ease: a, times: l } = {}) { return n.animate({ [e]: t, offset: l }, { delay: i, duration: r, easing: A6(a), fill: "both", iterations: s + 1, direction: o === "reverse" ? "alternate" : "normal" }) } const fT = { waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate") }, Av = {}, IR = {}; for (const n in fT) IR[n] = () => (Av[n] === void 0 && (Av[n] = fT[n]()), Av[n]); function M6(n, { repeat: e, repeatType: t = "loop" }) { const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1; return n[i] } const w6 = new Set(["opacity", "clipPath", "filter", "transform"]), zp = 10; function S6(n, e, { onUpdate: t, onComplete: i, ...r }) { if (!(IR.waapi() && w6.has(e) && !r.repeatDelay && r.repeatType !== "mirror" && r.damping !== 0)) return !1; let { keyframes: o, duration: a = 300, elapsed: l = 0, ease: f } = r; if (r.type === "spring" || !x6(r.ease)) { if (r.repeat === 1 / 0) return; const h = Qm({ ...r, elapsed: 0 }); let p = { done: !1, value: o[0] }; const m = []; let v = 0; for (; !p.done && v < 2e4;)p = h.sample(v), m.push(p.value), v += zp; o = m, a = v - zp, f = "linear" } const d = _6(n.owner.current, e, o, { ...r, delay: -l, duration: a, ease: f }); return d.onfinish = () => { n.set(M6(o, r)), ci.update(() => d.cancel()), i && i() }, { get currentTime() { return d.currentTime || 0 }, set currentTime(h) { d.currentTime = h }, stop: () => { const { currentTime: h } = d; if (h) { const p = Qm({ ...r, autoplay: !1 }); n.setWithVelocity(p.sample(h - zp).value, p.sample(h).value, zp) } ci.update(() => d.cancel()) } } } function FR(n, e) { const t = performance.now(), i = ({ timestamp: r }) => { const s = r - t; s >= e && (Ho.read(i), n(s - e)) }; return ci.read(i, !0), () => Ho.read(i) } function C6({ keyframes: n, elapsed: e, onUpdate: t, onComplete: i }) { const r = () => { t && t(n[n.length - 1]), i && i() }; return e ? { stop: FR(r, -e) } : r() } function E6({ keyframes: n, velocity: e = 0, min: t, max: i, power: r = .8, timeConstant: s = 750, bounceStiffness: o = 500, bounceDamping: a = 10, restDelta: l = 1, modifyTarget: f, driver: d, onUpdate: h, onComplete: p, onStop: m }) { const v = n[0]; let y; function x(S) { return t !== void 0 && S < t || i !== void 0 && S > i } function A(S) { return t === void 0 ? i : i === void 0 || Math.abs(t - S) < Math.abs(i - S) ? t : i } function _(S) { y && y.stop(), y = Qm({ keyframes: [0, 1], velocity: 0, ...S, driver: d, onUpdate: T => { h && h(T), S.onUpdate && S.onUpdate(T) }, onComplete: p, onStop: m }) } function w(S) { _({ type: "spring", stiffness: o, damping: a, restDelta: l, ...S }) } if (x(v)) w({ velocity: e, keyframes: [v, A(v)] }); else { let S = r * e + v; typeof f < "u" && (S = f(S)); const T = A(S), P = T === t ? -1 : 1; let R, E; const B = L => { R = E, E = L, e = W_(L - R, Os.delta), (P === 1 && L > T || P === -1 && L < T) && w({ keyframes: [L, T], velocity: e }) }; _({ type: "decay", keyframes: [v, 0], velocity: e, timeConstant: s, power: r, restDelta: l, modifyTarget: f, onUpdate: x(S) ? B : void 0 }) } return { stop: () => y && y.stop() } } const T6 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, b6 = n => ({ type: "spring", stiffness: 550, damping: n === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), P6 = { type: "keyframes", duration: .8 }, B6 = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, R6 = (n, { keyframes: e }) => e.length > 2 ? P6 : cl.has(n) ? n.startsWith("scale") ? b6(e[1]) : T6 : B6, C1 = (n, e) => n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && Vo.test(e) && !e.startsWith("url(")); function L6({ when: n, delay: e, delayChildren: t, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: o, repeatDelay: a, from: l, elapsed: f, ...d }) { return !!Object.keys(d).length } function dT(n) { return n === 0 || typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1 } function hT(n) { return typeof n == "number" ? 0 : X_("", n) } function NR(n, e) { return n[e] || n.default || n } function D6(n, e, t, i) { const r = C1(e, t); let s = i.from !== void 0 ? i.from : n.get(); return s === "none" && r && typeof t == "string" ? s = X_(e, t) : dT(s) && typeof t == "string" ? s = hT(t) : !Array.isArray(t) && dT(t) && typeof s == "string" && (t = hT(s)), Array.isArray(t) ? (t[0] === null && (t[0] = s), t) : [s, t] } const eM = (n, e, t, i = {}) => r => { const s = NR(i, n) || {}, o = s.delay || i.delay || 0; let { elapsed: a = 0 } = i; a = a - dm(o); const l = D6(e, n, t, s), f = l[0], d = l[l.length - 1], h = C1(n, f), p = C1(n, d); let m = { keyframes: l, velocity: e.getVelocity(), ...s, elapsed: a, onUpdate: v => { e.set(v), s.onUpdate && s.onUpdate(v) }, onComplete: () => { r(), s.onComplete && s.onComplete() } }; if (!h || !p || O9.current || s.type === !1) return C6(m); if (s.type === "inertia") return E6(m); if (L6(s) || (m = { ...m, ...R6(n, m) }), m.duration && (m.duration = dm(m.duration)), m.repeatDelay && (m.repeatDelay = dm(m.repeatDelay)), e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) { const v = S6(e, n, m); if (v) return v } return Qm(m) }; function I6(n, e, t = {}) { n.notify("AnimationStart", e); let i; if (Array.isArray(e)) { const r = e.map(s => E1(n, s, t)); i = Promise.all(r) } else if (typeof e == "string") i = E1(n, e, t); else { const r = typeof e == "function" ? zg(n, e, t.custom) : e; i = OR(n, r, t) } return i.then(() => n.notify("AnimationComplete", e)) } function E1(n, e, t = {}) { const i = zg(n, e, t.custom); let { transition: r = n.getDefaultTransition() || {} } = i || {}; t.transitionOverride && (r = t.transitionOverride); const s = i ? () => OR(n, i, t) : () => Promise.resolve(), o = n.variantChildren && n.variantChildren.size ? (l = 0) => { const { delayChildren: f = 0, staggerChildren: d, staggerDirection: h } = r; return F6(n, e, f + l, d, h, t) } : () => Promise.resolve(), { when: a } = r; if (a) { const [l, f] = a === "beforeChildren" ? [s, o] : [o, s]; return l().then(f) } else return Promise.all([s(), o(t.delay)]) } function OR(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) { let { transition: s = n.getDefaultTransition(), transitionEnd: o, ...a } = n.makeTargetAnimatable(e); const l = n.getValue("willChange"); i && (s = i); const f = [], d = r && n.animationState && n.animationState.getState()[r]; for (const h in a) { const p = n.getValue(h), m = a[h]; if (!p || m === void 0 || d && O6(d, h)) continue; const v = { delay: t, elapsed: 0, ...s }; if (window.HandoffAppearAnimations && !p.hasAnimated) { const x = n.getProps()[F9]; x && (v.elapsed = window.HandoffAppearAnimations(x, h, p, ci)) } let y = p.start(eM(h, p, m, n.shouldReduceMotion && cl.has(h) ? { type: !1 } : v)); Ym(l) && (l.add(h), y = y.then(() => l.remove(h))), f.push(y) } return Promise.all(f).then(() => { o && B9(n, o) }) } function F6(n, e, t = 0, i = 0, r = 1, s) { const o = [], a = (n.variantChildren.size - 1) * i, l = r === 1 ? (f = 0) => f * i : (f = 0) => a - f * i; return Array.from(n.variantChildren).sort(N6).forEach((f, d) => { f.notify("AnimationStart", e), o.push(E1(f, e, { ...s, delay: t + l(d) }).then(() => f.notify("AnimationComplete", e))) }), Promise.all(o) } function N6(n, e) { return n.sortNodePosition(e) } function O6({ protectedKeys: n, needsAnimating: e }, t) { const i = n.hasOwnProperty(t) && e[t] !== !0; return e[t] = !1, i } const k6 = [...R_].reverse(), U6 = R_.length; function z6(n) { return e => Promise.all(e.map(({ animation: t, options: i }) => I6(n, t, i))) } function G6(n) { let e = z6(n); const t = V6(); let i = !0; const r = (l, f) => { const d = zg(n, f); if (d) { const { transition: h, transitionEnd: p, ...m } = d; l = { ...l, ...m, ...p } } return l }; function s(l) { e = l(n) } function o(l, f) { const d = n.getProps(), h = n.getVariantContext(!0) || {}, p = [], m = new Set; let v = {}, y = 1 / 0; for (let A = 0; A < U6; A++) { const _ = k6[A], w = t[_], S = d[_] !== void 0 ? d[_] : h[_], T = ed(S), P = _ === f ? w.isActive : null; P === !1 && (y = A); let R = S === h[_] && S !== d[_] && T; if (R && i && n.manuallyAnimateOnMount && (R = !1), w.protectedKeys = { ...v }, !w.isActive && P === null || !S && !w.prevProp || Fg(S) || typeof S == "boolean") continue; const E = H6(w.prevProp, S); let B = E || _ === f && w.isActive && !R && T || A > y && T; const L = Array.isArray(S) ? S : [S]; let U = L.reduce(r, {}); P === !1 && (U = {}); const { prevResolvedValues: q = {} } = w, W = { ...q, ...U }, G = K => { B = !0, m.delete(K), w.needsAnimating[K] = !0 }; for (const K in W) { const ne = U[K], oe = q[K]; v.hasOwnProperty(K) || (ne !== oe ? Jm(ne) && Jm(oe) ? !fR(ne, oe) || E ? G(K) : w.protectedKeys[K] = !0 : ne !== void 0 ? G(K) : m.add(K) : ne !== void 0 && m.has(K) ? G(K) : w.protectedKeys[K] = !0) } w.prevProp = S, w.prevResolvedValues = U, w.isActive && (v = { ...v, ...U }), i && n.blockInitialAnimation && (B = !1), B && !R && p.push(...L.map(K => ({ animation: K, options: { type: _, ...l } }))) } if (m.size) { const A = {}; m.forEach(_ => { const w = n.getBaseTarget(_); w !== void 0 && (A[_] = w) }), p.push({ animation: A }) } let x = Boolean(p.length); return i && d.initial === !1 && !n.manuallyAnimateOnMount && (x = !1), i = !1, x ? e(p) : Promise.resolve() } function a(l, f, d) { var h; if (t[l].isActive === f) return Promise.resolve(); (h = n.variantChildren) === null || h === void 0 || h.forEach(m => { var v; return (v = m.animationState) === null || v === void 0 ? void 0 : v.setActive(l, f) }), t[l].isActive = f; const p = o(d, l); for (const m in t) t[m].protectedKeys = {}; return p } return { animateChanges: o, setActive: a, setAnimateFunction: s, getState: () => t } } function H6(n, e) { return typeof e == "string" ? e !== n : Array.isArray(e) ? !fR(e, n) : !1 } function va(n = !1) { return { isActive: n, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function V6() { return { animate: va(!0), whileInView: va(), whileHover: va(), whileTap: va(), whileDrag: va(), whileFocus: va(), exit: va() } } class W6 extends qo { constructor(e) { super(e), e.animationState || (e.animationState = G6(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); this.unmount(), Fg(e) && (this.unmount = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { } } let j6 = 0; class J6 extends qo { constructor() { super(...arguments), this.id = j6++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: t, custom: i } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === r) return; const s = this.node.animationState.setActive("exit", !e, { custom: i ?? this.node.getProps().custom }); t && !e && s.then(() => t(this.id)) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } const X6 = { animation: { Feature: W6 }, exit: { Feature: J6 } }, pT = (n, e) => Math.abs(n - e); function Y6(n, e) { const t = pT(n.x, e.x), i = pT(n.y, e.y); return Math.sqrt(t ** 2 + i ** 2) } class kR { constructor(e, t, { transformPagePoint: i } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const f = Mv(this.lastMoveEventInfo, this.history), d = this.startEvent !== null, h = Y6(f.offset, { x: 0, y: 0 }) >= 3; if (!d && !h) return; const { point: p } = f, { timestamp: m } = Os; this.history.push({ ...p, timestamp: m }); const { onStart: v, onMove: y } = this.handlers; d || (v && v(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, f) }, this.handlePointerMove = (f, d) => { this.lastMoveEvent = f, this.lastMoveEventInfo = _v(d, this.transformPagePoint), ci.update(this.updatePoint, !0) }, this.handlePointerUp = (f, d) => { if (this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const { onEnd: h, onSessionEnd: p } = this.handlers, m = Mv(f.type === "pointercancel" ? this.lastMoveEventInfo : _v(d, this.transformPagePoint), this.history); this.startEvent && h && h(f, m), p && p(f, m) }, !oR(e)) return; this.handlers = t, this.transformPagePoint = i; const r = kg(e), s = _v(r, this.transformPagePoint), { point: o } = s, { timestamp: a } = Os; this.history = [{ ...o, timestamp: a }]; const { onSessionStart: l } = t; l && l(e, Mv(s, this.history)), this.removeListeners = Io(Ns(window, "pointermove", this.handlePointerMove), Ns(window, "pointerup", this.handlePointerUp), Ns(window, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), Ho.update(this.updatePoint) } } function _v(n, e) { return e ? { point: e(n.point) } : n } function mT(n, e) { return { x: n.x - e.x, y: n.y - e.y } } function Mv({ point: n }, e) { return { point: n, delta: mT(n, UR(e)), offset: mT(n, K6(e)), velocity: Q6(e, .1) } } function K6(n) { return n[0] } function UR(n) { return n[n.length - 1] } function Q6(n, e) { if (n.length < 2) return { x: 0, y: 0 }; let t = n.length - 1, i = null; const r = UR(n); for (; t >= 0 && (i = n[t], !(r.timestamp - i.timestamp > dm(e)));)t--; if (!i) return { x: 0, y: 0 }; const s = (r.timestamp - i.timestamp) / 1e3; if (s === 0) return { x: 0, y: 0 }; const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s }; return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o } function Hi(n) { return n.max - n.min } function T1(n, e = 0, t = .01) { return Math.abs(n - e) <= t } function gT(n, e, t, i = .5) { n.origin = i, n.originPoint = nn(e.min, e.max, n.origin), n.scale = Hi(t) / Hi(e), (T1(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1), n.translate = nn(t.min, t.max, n.origin) - n.originPoint, (T1(n.translate) || isNaN(n.translate)) && (n.translate = 0) } function vf(n, e, t, i) { gT(n.x, e.x, t.x, i ? i.originX : void 0), gT(n.y, e.y, t.y, i ? i.originY : void 0) } function yT(n, e, t) { n.min = t.min + e.min, n.max = n.min + Hi(e) } function Z6(n, e, t) { yT(n.x, e.x, t.x), yT(n.y, e.y, t.y) } function vT(n, e, t) { n.min = e.min - t.min, n.max = n.min + Hi(e) } function xf(n, e, t) { vT(n.x, e.x, t.x), vT(n.y, e.y, t.y) } function q6(n, { min: e, max: t }, i) { return e !== void 0 && n < e ? n = i ? nn(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? nn(t, n, i.max) : Math.min(n, t)), n } function xT(n, e, t) { return { min: e !== void 0 ? n.min + e : void 0, max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0 } } function $6(n, { top: e, left: t, bottom: i, right: r }) { return { x: xT(n.x, t, r), y: xT(n.y, e, i) } } function AT(n, e) { let t = e.min - n.min, i = e.max - n.max; return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i } } function eW(n, e) { return { x: AT(n.x, e.x), y: AT(n.y, e.y) } } function tW(n, e) { let t = .5; const i = Hi(n), r = Hi(e); return r > i ? t = rd(e.min, e.max - i, n.min) : i > r && (t = rd(n.min, n.max - r, e.min)), ku(0, 1, t) } function nW(n, e) { const t = {}; return e.min !== void 0 && (t.min = e.min - n.min), e.max !== void 0 && (t.max = e.max - n.min), t } const b1 = .35; function iW(n = b1) { return n === !1 ? n = 0 : n === !0 && (n = b1), { x: _T(n, "left", "right"), y: _T(n, "top", "bottom") } } function _T(n, e, t) { return { min: MT(n, e), max: MT(n, t) } } function MT(n, e) { return typeof n == "number" ? n : n[e] || 0 } const wT = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Af = () => ({ x: wT(), y: wT() }), ST = () => ({ min: 0, max: 0 }), An = () => ({ x: ST(), y: ST() }); function Qr(n) { return [n("x"), n("y")] } function zR({ top: n, left: e, right: t, bottom: i }) { return { x: { min: e, max: t }, y: { min: n, max: i } } } function rW({ x: n, y: e }) { return { top: e.min, right: n.max, bottom: e.max, left: n.min } } function sW(n, e) { if (!e) return n; const t = e({ x: n.left, y: n.top }), i = e({ x: n.right, y: n.bottom }); return { top: t.y, left: t.x, bottom: i.y, right: i.x } } function wv(n) { return n === void 0 || n === 1 } function P1({ scale: n, scaleX: e, scaleY: t }) { return !wv(n) || !wv(e) || !wv(t) } function Ca(n) { return P1(n) || GR(n) || n.z || n.rotate || n.rotateX || n.rotateY } function GR(n) { return CT(n.x) || CT(n.y) } function CT(n) { return n && n !== "0%" } function Zm(n, e, t) { const i = n - t, r = e * i; return t + r } function ET(n, e, t, i, r) { return r !== void 0 && (n = Zm(n, r, i)), Zm(n, t, i) + e } function B1(n, e = 0, t = 1, i, r) { n.min = ET(n.min, e, t, i, r), n.max = ET(n.max, e, t, i, r) } function HR(n, { x: e, y: t }) { B1(n.x, e.translate, e.scale, e.originPoint), B1(n.y, t.translate, t.scale, t.originPoint) } function oW(n, e, t, i = !1) { const r = t.length; if (!r) return; e.x = e.y = 1; let s, o; for (let a = 0; a < r; a++) { s = t[a], o = s.projectionDelta; const l = s.instance; l && l.style && l.style.display === "contents" || (i && s.options.layoutScroll && s.scroll && s !== s.root && fu(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }), o && (e.x *= o.x.scale, e.y *= o.y.scale, HR(n, o)), i && Ca(s.latestValues) && fu(n, s.latestValues)) } e.x = TT(e.x), e.y = TT(e.y) } function TT(n) { return Number.isInteger(n) || n > 1.0000000000001 || n < .999999999999 ? n : 1 } function yo(n, e) { n.min = n.min + e, n.max = n.max + e } function bT(n, e, [t, i, r]) { const s = e[r] !== void 0 ? e[r] : .5, o = nn(n.min, n.max, s); B1(n, e[t], e[i], o, e.scale) } const aW = ["x", "scaleX", "originX"], lW = ["y", "scaleY", "originY"]; function fu(n, e) { bT(n.x, e, aW), bT(n.y, e, lW) } function VR(n, e) { return zR(sW(n.getBoundingClientRect(), e)) } function uW(n, e, t) { const i = VR(n, t), { scroll: r } = e; return r && (yo(i.x, r.offset.x), yo(i.y, r.offset.y)), i } const cW = new WeakMap; class fW { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = An(), this.visualElement = e } start(e, { snapToCursor: t = !1 } = {}) { const { presenceContext: i } = this.visualElement; if (i && i.isPresent === !1) return; const r = l => { this.stopAnimation(), t && this.snapToCursor(kg(l, "page").point) }, s = (l, f) => { const { drag: d, dragPropagation: h, onDragStart: p } = this.getProps(); if (d && !h && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = lR(d), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Qr(v => { let y = this.getAxisMotionValue(v).get() || 0; if (ns.test(y)) { const { projection: x } = this.visualElement; if (x && x.layout) { const A = x.layout.layoutBox[v]; A && (y = Hi(A) * (parseFloat(y) / 100)) } } this.originPoint[v] = y }), p && p(l, f); const { animationState: m } = this.visualElement; m && m.setActive("whileDrag", !0) }, o = (l, f) => { const { dragPropagation: d, dragDirectionLock: h, onDirectionLock: p, onDrag: m } = this.getProps(); if (!d && !this.openGlobalLock) return; const { offset: v } = f; if (h && this.currentDirection === null) { this.currentDirection = dW(v), this.currentDirection !== null && p && p(this.currentDirection); return } this.updateAxis("x", f.point, v), this.updateAxis("y", f.point, v), this.visualElement.render(), m && m(l, f) }, a = (l, f) => this.stop(l, f); this.panSession = new kR(e, { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a }, { transformPagePoint: this.visualElement.getTransformPagePoint() }) } stop(e, t) { const i = this.isDragging; if (this.cancel(), !i) return; const { velocity: r } = t; this.startAnimation(r); const { onDragEnd: s } = this.getProps(); s && s(e, t) } cancel() { this.isDragging = !1; const { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: i } = this.getProps(); !i && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, i) { const { drag: r } = this.getProps(); if (!i || !Gp(e, r, this.currentDirection)) return; const s = this.getAxisMotionValue(e); let o = this.originPoint[e] + i[e]; this.constraints && this.constraints[e] && (o = q6(o, this.constraints[e], this.elastic[e])), s.set(o) } resolveConstraints() { const { dragConstraints: e, dragElastic: t } = this.getProps(), { layout: i } = this.visualElement.projection || {}, r = this.constraints; e && uu(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = $6(i.layoutBox, e) : this.constraints = !1, this.elastic = iW(t), r !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Qr(s => { this.getAxisMotionValue(s) && (this.constraints[s] = nW(i.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !uu(e)) return !1; const i = e.current, { projection: r } = this.visualElement; if (!r || !r.layout) return !1; const s = uW(i, r.root, this.visualElement.getTransformPagePoint()); let o = eW(r.layout.layoutBox, s); if (t) { const a = t(rW(o)); this.hasMutatedConstraints = !!a, a && (o = zR(a)) } return o } startAnimation(e) { const { drag: t, dragMomentum: i, dragElastic: r, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, f = Qr(d => { if (!Gp(d, t, this.currentDirection)) return; let h = l && l[d] || {}; o && (h = { min: 0, max: 0 }); const p = r ? 200 : 1e6, m = r ? 40 : 1e7, v = { type: "inertia", velocity: i ? e[d] : 0, bounceStiffness: p, bounceDamping: m, timeConstant: 750, restDelta: 1, restSpeed: 10, ...s, ...h }; return this.startAxisValueAnimation(d, v) }); return Promise.all(f).then(a) } startAxisValueAnimation(e, t) { const i = this.getAxisMotionValue(e); return i.start(eM(e, i, 0, t)) } stopAnimation() { Qr(e => this.getAxisMotionValue(e).stop()) } getAxisMotionValue(e) { const t = "_drag" + e.toUpperCase(), i = this.visualElement.getProps(), r = i[t]; return r || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0) } snapToCursor(e) { Qr(t => { const { drag: i } = this.getProps(); if (!Gp(t, i, this.currentDirection)) return; const { projection: r } = this.visualElement, s = this.getAxisMotionValue(t); if (r && r.layout) { const { min: o, max: a } = r.layout.layoutBox[t]; s.set(e[t] - nn(o, a, .5)) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: t } = this.getProps(), { projection: i } = this.visualElement; if (!uu(t) || !i || !this.constraints) return; this.stopAnimation(); const r = { x: 0, y: 0 }; Qr(o => { const a = this.getAxisMotionValue(o); if (a) { const l = a.get(); r[o] = tW({ min: l, max: l }, this.constraints[o]) } }); const { transformTemplate: s } = this.visualElement.getProps(); this.visualElement.current.style.transform = s ? s({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), Qr(o => { if (!Gp(o, e, null)) return; const a = this.getAxisMotionValue(o), { min: l, max: f } = this.constraints[o]; a.set(nn(l, f, r[o])) }) } addListeners() { if (!this.visualElement.current) return; cW.set(this.visualElement, this); const e = this.visualElement.current, t = Ns(e, "pointerdown", l => { const { drag: f, dragListener: d = !0 } = this.getProps(); f && d && this.start(l) }), i = () => { const { dragConstraints: l } = this.getProps(); uu(l) && (this.constraints = this.resolveRefConstraints()) }, { projection: r } = this.visualElement, s = r.addEventListener("measure", i); r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i(); const o = Ds(window, "resize", () => this.scalePositionWithinConstraints()), a = r.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: f }) => { this.isDragging && f && (Qr(d => { const h = this.getAxisMotionValue(d); h && (this.originPoint[d] += l[d].translate, h.set(h.get() + l[d].translate)) }), this.visualElement.render()) }); return () => { o(), t(), s(), a && a() } } getProps() { const e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: i = !1, dragPropagation: r = !1, dragConstraints: s = !1, dragElastic: o = b1, dragMomentum: a = !0 } = e; return { ...e, drag: t, dragDirectionLock: i, dragPropagation: r, dragConstraints: s, dragElastic: o, dragMomentum: a } } } function Gp(n, e, t) { return (e === !0 || e === n) && (t === null || t === n) } function dW(n, e = 10) { let t = null; return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"), t } class hW extends qo { constructor(e) { super(e), this.removeGroupControls = dr, this.removeListeners = dr, this.controls = new fW(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || dr } unmount() { this.removeGroupControls(), this.removeListeners() } } class pW extends qo { constructor() { super(...arguments), this.removePointerDownListener = dr } onPointerDown(e) { this.session = new kR(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: t, onPan: i, onPanEnd: r } = this.node.getProps(); return { onSessionStart: e, onStart: t, onMove: i, onEnd: (s, o) => { delete this.session, r && r(s, o) } } } mount() { this.removePointerDownListener = Ns(this.node.current, "pointerdown", e => this.onPointerDown(e)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } function mW() { const n = z.useContext(B_); if (n === null) return [!0, null]; const { isPresent: e, onExitComplete: t, register: i } = n, r = z.useId(); return z.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0] } function PT(n, e) { return e.max === e.min ? 0 : n / (e.max - e.min) * 100 } const Xc = { correct: (n, e) => { if (!e.target) return n; if (typeof n == "string") if (nt.test(n)) n = parseFloat(n); else return n; const t = PT(n, e.target.x), i = PT(n, e.target.y); return `${t}% ${i}%` } }, WR = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/; function gW(n) { const e = WR.exec(n); if (!e) return [,]; const [, t, i] = e; return [t, i] } function R1(n, e, t = 1) { const [i, r] = gW(n); if (!i) return; const s = window.getComputedStyle(e).getPropertyValue(i); return s ? s.trim() : g1(r) ? R1(r, e, t + 1) : r } function yW(n, { ...e }, t) { const i = n.current; if (!(i instanceof Element)) return { target: e, transitionEnd: t }; t && (t = { ...t }), n.values.forEach(r => { const s = r.get(); if (!g1(s)) return; const o = R1(s, i); o && r.set(o) }); for (const r in e) { const s = e[r]; if (!g1(s)) continue; const o = R1(s, i); o && (e[r] = o, t && t[r] === void 0 && (t[r] = s)) } return { target: e, transitionEnd: t } } const BT = "_$css", vW = { correct: (n, { treeScale: e, projectionDelta: t }) => { const i = n, r = n.includes("var("), s = []; r && (n = n.replace(WR, m => (s.push(m), BT))); const o = Vo.parse(n); if (o.length > 5) return i; const a = Vo.createTransformer(n), l = typeof o[0] != "number" ? 1 : 0, f = t.x.scale * e.x, d = t.y.scale * e.y; o[0 + l] /= f, o[1 + l] /= d; const h = nn(f, d, .5); typeof o[2 + l] == "number" && (o[2 + l] /= h), typeof o[3 + l] == "number" && (o[3 + l] /= h); let p = a(o); if (r) { let m = 0; p = p.replace(BT, () => { const v = s[m]; return m++, v }) } return p } }; class xW extends tg.Component { componentDidMount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: i, layoutId: r } = this.props, { projection: s } = e; A8(AW), s && (t.group && t.group.add(s), i && i.register && r && i.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => { this.safeToRemove() }), s.setOptions({ ...s.options, onExitComplete: () => this.safeToRemove() })), mf.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: t, visualElement: i, drag: r, isPresent: s } = this.props, o = i.projection; return o && (o.isPresent = s, r || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || ci.postRender(() => { const a = o.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), !e.currentAnimation && e.isLead() && this.safeToRemove()) } componentWillUnmount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: i } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), i && i.deregister && i.deregister(r)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function jR(n) { const [e, t] = mW(), i = z.useContext(J3); return tg.createElement(xW, { ...n, layoutGroup: i, switchLayoutGroup: z.useContext(X3), isPresent: e, safeToRemove: t }) } const AW = { borderRadius: { ...Xc, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: Xc, borderTopRightRadius: Xc, borderBottomLeftRadius: Xc, borderBottomRightRadius: Xc, boxShadow: vW }; function _W(n, e, t = {}) { const i = Ti(n) ? n : Uu(n); return i.start(eM("", i, e, t)), { stop: () => i.stop(), isAnimating: () => i.isAnimating() } } const JR = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], MW = JR.length, RT = n => typeof n == "string" ? parseFloat(n) : n, LT = n => typeof n == "number" || nt.test(n); function wW(n, e, t, i, r, s) { r ? (n.opacity = nn(0, t.opacity !== void 0 ? t.opacity : 1, SW(i)), n.opacityExit = nn(e.opacity !== void 0 ? e.opacity : 1, 0, CW(i))) : s && (n.opacity = nn(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, i)); for (let o = 0; o < MW; o++) { const a = `border${JR[o]}Radius`; let l = DT(e, a), f = DT(t, a); if (l === void 0 && f === void 0) continue; l || (l = 0), f || (f = 0), l === 0 || f === 0 || LT(l) === LT(f) ? (n[a] = Math.max(nn(RT(l), RT(f), i), 0), (ns.test(f) || ns.test(l)) && (n[a] += "%")) : n[a] = f } (e.rotate || t.rotate) && (n.rotate = nn(e.rotate || 0, t.rotate || 0, i)) } function DT(n, e) { return n[e] !== void 0 ? n[e] : n.borderRadius } const SW = XR(0, .5, q_), CW = XR(.5, .95, dr); function XR(n, e, t) { return i => i < n ? 0 : i > e ? 1 : t(rd(n, e, i)) } function IT(n, e) { n.min = e.min, n.max = e.max } function sr(n, e) { IT(n.x, e.x), IT(n.y, e.y) } function FT(n, e, t, i, r) { return n -= e, n = Zm(n, 1 / t, i), r !== void 0 && (n = Zm(n, 1 / r, i)), n } function EW(n, e = 0, t = 1, i = .5, r, s = n, o = n) { if (ns.test(e) && (e = parseFloat(e), e = nn(o.min, o.max, e / 100) - o.min), typeof e != "number") return; let a = nn(s.min, s.max, i); n === s && (a -= e), n.min = FT(n.min, e, t, a, r), n.max = FT(n.max, e, t, a, r) } function NT(n, e, [t, i, r], s, o) { EW(n, e[t], e[i], e[r], e.scale, s, o) } const TW = ["x", "scaleX", "originX"], bW = ["y", "scaleY", "originY"]; function OT(n, e, t, i) { NT(n.x, e, TW, t ? t.x : void 0, i ? i.x : void 0), NT(n.y, e, bW, t ? t.y : void 0, i ? i.y : void 0) } function kT(n) { return n.translate === 0 && n.scale === 1 } function YR(n) { return kT(n.x) && kT(n.y) } function L1(n, e) { return n.x.min === e.x.min && n.x.max === e.x.max && n.y.min === e.y.min && n.y.max === e.y.max } function UT(n) { return Hi(n.x) / Hi(n.y) } class PW { constructor() { this.members = [] } add(e) { G_(this.members, e), e.scheduleRender() } remove(e) { if (H_(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const t = this.members[this.members.length - 1]; t && this.promote(t) } } relegate(e) { const t = this.members.findIndex(r => e === r); if (t === 0) return !1; let i; for (let r = t; r >= 0; r--) { const s = this.members[r]; if (s.isPresent !== !1) { i = s; break } } return i ? (this.promote(i), !0) : !1 } promote(e, t) { const i = this.lead; if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) { i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, t && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: r } = e.options; r === !1 && i.hide() } } exitAnimationComplete() { this.members.forEach(e => { const { options: t, resumingFrom: i } = e; t.onExitComplete && t.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete() }) } scheduleRender() { this.members.forEach(e => { e.instance && e.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function zT(n, e, t) { let i = ""; const r = n.x.translate / e.x, s = n.y.translate / e.y; if ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `), t) { const { rotate: l, rotateX: f, rotateY: d } = t; l && (i += `rotate(${l}deg) `), f && (i += `rotateX(${f}deg) `), d && (i += `rotateY(${d}deg) `) } const o = n.x.scale * e.x, a = n.y.scale * e.y; return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none" } const BW = (n, e) => n.depth - e.depth; class RW { constructor() { this.children = [], this.isDirty = !1 } add(e) { G_(this.children, e), this.isDirty = !0 } remove(e) { H_(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(BW), this.isDirty = !1, this.children.forEach(e) } } function LW(n) { window.MotionDebug && window.MotionDebug.record(n) } const GT = ["", "X", "Y", "Z"], HT = 1e3; let DW = 0; const Ea = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }; function KR({ attachResizeListener: n, defaultParent: e, measureScroll: t, checkIsScrollRoot: i, resetTransform: r }) { return class { constructor(o, a = {}, l = e == null ? void 0 : e()) { this.id = DW++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.potentialNodes = new Map, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { Ea.totalNodes = Ea.resolvedTargetDeltas = Ea.recalculatedProjection = 0, this.nodes.forEach(NW), this.nodes.forEach(zW), this.nodes.forEach(GW), this.nodes.forEach(OW), LW(Ea) }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.elementId = o, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0, o && this.root.registerPotentialNode(o, this); for (let f = 0; f < this.path.length; f++)this.path[f].shouldResetTransform = !0; this.root === this && (this.nodes = new RW) } addEventListener(o, a) { return this.eventHandlers.has(o) || this.eventHandlers.set(o, new V_), this.eventHandlers.get(o).add(a) } notifyListeners(o, ...a) { const l = this.eventHandlers.get(o); l && l.notify(...a) } hasListeners(o) { return this.eventHandlers.has(o) } registerPotentialNode(o, a) { this.potentialNodes.set(o, a) } mount(o, a = !1) { if (this.instance) return; this.isSVG = o instanceof SVGElement && o.tagName !== "svg", this.instance = o; const { layoutId: l, layout: f, visualElement: d } = this.options; if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.elementId && this.root.potentialNodes.delete(this.elementId), a && (f || l) && (this.isLayoutDirty = !0), n) { let h; const p = () => this.root.updateBlockedByResize = !1; n(o, () => { this.root.updateBlockedByResize = !0, h && h(), h = FR(p, 250), mf.hasAnimatedSinceResize && (mf.hasAnimatedSinceResize = !1, this.nodes.forEach(WT)) }) } l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && d && (l || f) && this.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: p, hasRelativeTargetChanged: m, layout: v }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const y = this.options.transition || d.getDefaultTransition() || JW, { onLayoutAnimationStart: x, onLayoutAnimationComplete: A } = d.getProps(), _ = !this.targetLayout || !L1(this.targetLayout, v) || m, w = !p && m; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || w || p && (_ || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, w); const S = { ...NR(y, "layout"), onPlay: x, onComplete: A }; (d.shouldReduceMotion || this.options.layoutRoot) && (S.delay = 0, S.type = !1), this.startAnimation(S) } else !p && this.animationProgress === 0 && WT(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = v }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const o = this.getStack(); o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Ho.preRender(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(HW), this.animationId++) } getTransformTemplate() { const { visualElement: o } = this.options; return o && o.getProps().transformTemplate } willUpdate(o = !0) { if (this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let d = 0; d < this.path.length; d++) { const h = this.path[d]; h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const f = this.getTransformTemplate(); this.prevTransformTemplateValue = f ? f(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate") } didUpdate() { if (this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(VT); return } this.isUpdating && (this.isUpdating = !1, this.potentialNodes.size && (this.potentialNodes.forEach(XW), this.potentialNodes.clear()), this.nodes.forEach(UW), this.nodes.forEach(IW), this.nodes.forEach(FW), this.clearAllSnapshots(), mv.update(), mv.preRender(), mv.render()) } clearAllSnapshots() { this.nodes.forEach(kW), this.sharedNodes.forEach(VW) } scheduleUpdateProjection() { ci.preRender(this.updateProjection, !1, !0) } scheduleCheckAfterUnmount() { ci.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure()) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const o = this.layout; this.layout = this.measure(!1), this.layoutCorrected = An(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0) } updateScroll(o = "measure") { let a = Boolean(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && (this.scroll = { animationId: this.root.animationId, phase: o, isRoot: i(this.instance), offset: t(this.instance) }) } resetTransform() { if (!r) return; const o = this.isLayoutDirty || this.shouldResetTransform, a = this.projectionDelta && !YR(this.projectionDelta), l = this.getTransformTemplate(), f = l ? l(this.latestValues, "") : void 0, d = f !== this.prevTransformTemplateValue; o && (a || Ca(this.latestValues) || d) && (r(this.instance, f), this.shouldResetTransform = !1, this.scheduleRender()) } measure(o = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return o && (l = this.removeTransform(l)), YW(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: o } = this.options; if (!o) return An(); const a = o.measureViewportBox(), { scroll: l } = this.root; return l && (yo(a.x, l.offset.x), yo(a.y, l.offset.y)), a } removeElementScroll(o) { const a = An(); sr(a, o); for (let l = 0; l < this.path.length; l++) { const f = this.path[l], { scroll: d, options: h } = f; if (f !== this.root && d && h.layoutScroll) { if (d.isRoot) { sr(a, o); const { scroll: p } = this.root; p && (yo(a.x, -p.offset.x), yo(a.y, -p.offset.y)) } yo(a.x, d.offset.x), yo(a.y, d.offset.y) } } return a } applyTransform(o, a = !1) { const l = An(); sr(l, o); for (let f = 0; f < this.path.length; f++) { const d = this.path[f]; !a && d.options.layoutScroll && d.scroll && d !== d.root && fu(l, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }), Ca(d.latestValues) && fu(l, d.latestValues) } return Ca(this.latestValues) && fu(l, this.latestValues), l } removeTransform(o) { const a = An(); sr(a, o); for (let l = 0; l < this.path.length; l++) { const f = this.path[l]; if (!f.instance || !Ca(f.latestValues)) continue; P1(f.latestValues) && f.updateSnapshot(); const d = An(), h = f.measurePageBox(); sr(d, h), OT(a, f.latestValues, f.snapshot ? f.snapshot.layoutBox : void 0, d) } return Ca(this.latestValues) && OT(a, this.latestValues), a } setTargetDelta(o) { this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(o) { this.options = { ...this.options, ...o, crossfade: o.crossfade !== void 0 ? o.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } resolveTargetDelta() { var o; const a = this.getLead(); if (this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty), !((Boolean(this.resumingFrom) || this !== a) && this.isSharedProjectionDirty || this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty || this.attemptToResolveRelativeTarget)) return; const { layout: d, layoutId: h } = this.options; if (!(!this.layout || !(d || h))) { if (!this.targetDelta && !this.relativeTarget) { const p = this.getClosestProjectingParent(); p && p.layout ? (this.relativeParent = p, this.relativeTarget = An(), this.relativeTargetOrigin = An(), xf(this.relativeTargetOrigin, this.layout.layoutBox, p.layout.layoutBox), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (!(!this.relativeTarget && !this.targetDelta)) { if (this.target || (this.target = An(), this.targetWithTransforms = An()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? Z6(this.target, this.relativeTarget, this.relativeParent.target) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : sr(this.target, this.layout.layoutBox), HR(this.target, this.targetDelta)) : sr(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const p = this.getClosestProjectingParent(); p && Boolean(p.resumingFrom) === Boolean(this.resumingFrom) && !p.options.layoutScroll && p.target ? (this.relativeParent = p, this.relativeTarget = An(), this.relativeTargetOrigin = An(), xf(this.relativeTargetOrigin, this.target, p.target), sr(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } Ea.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (!(!this.parent || P1(this.parent.latestValues) || GR(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var o; const a = this.getLead(), l = Boolean(this.resumingFrom) || this !== a; let f = !0; if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (f = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (f = !1), f) return; const { layout: d, layoutId: h } = this.options; if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || h)) return; sr(this.layoutCorrected, this.layout.layoutBox), oW(this.layoutCorrected, this.treeScale, this.path, l); const { target: p } = a; if (!p) return; this.projectionDelta || (this.projectionDelta = Af(), this.projectionDeltaWithTransform = Af()); const m = this.treeScale.x, v = this.treeScale.y, y = this.projectionTransform; vf(this.projectionDelta, this.layoutCorrected, p, this.latestValues), this.projectionTransform = zT(this.projectionDelta, this.treeScale), (this.projectionTransform !== y || this.treeScale.x !== m || this.treeScale.y !== v) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", p)), Ea.recalculatedProjection++ } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(o = !0) { if (this.options.scheduleRender && this.options.scheduleRender(), o) { const a = this.getStack(); a && a.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } setAnimationOrigin(o, a = !1) { const l = this.snapshot, f = l ? l.latestValues : {}, d = { ...this.latestValues }, h = Af(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const p = An(), m = l ? l.source : void 0, v = this.layout ? this.layout.source : void 0, y = m !== v, x = this.getStack(), A = !x || x.members.length <= 1, _ = Boolean(y && !A && this.options.crossfade === !0 && !this.path.some(jW)); this.animationProgress = 0; let w; this.mixTargetDelta = S => { const T = S / 1e3; jT(h.x, o.x, T), jT(h.y, o.y, T), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (xf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), WW(this.relativeTarget, this.relativeTargetOrigin, p, T), w && L1(this.relativeTarget, w) && (this.isProjectionDirty = !1), w || (w = An()), sr(w, this.relativeTarget)), y && (this.animationValues = d, wW(d, f, this.latestValues, T, _, A)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = T }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(o) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Ho.update(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = ci.update(() => { mf.hasAnimatedSinceResize = !0, this.currentAnimation = _W(0, HT, { ...o, onUpdate: a => { this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a) }, onComplete: () => { o.onComplete && o.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const o = this.getStack(); o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(HT), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const o = this.getLead(); let { targetWithTransforms: a, target: l, layout: f, latestValues: d } = o; if (!(!a || !l || !f)) { if (this !== o && this.layout && f && QR(this.options.animationType, this.layout.layoutBox, f.layoutBox)) { l = this.target || An(); const h = Hi(this.layout.layoutBox.x); l.x.min = o.target.x.min, l.x.max = l.x.min + h; const p = Hi(this.layout.layoutBox.y); l.y.min = o.target.y.min, l.y.max = l.y.min + p } sr(a, l), fu(a, d), vf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d) } } registerSharedNode(o, a) { this.sharedNodes.has(o) || this.sharedNodes.set(o, new PW), this.sharedNodes.get(o).add(a); const f = a.options.initialPromotionConfig; a.promote({ transition: f ? f.transition : void 0, preserveFollowOpacity: f && f.shouldPreserveFollowOpacity ? f.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const o = this.getStack(); return o ? o.lead === this : !0 } getLead() { var o; const { layoutId: a } = this.options; return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this } getPrevLead() { var o; const { layoutId: a } = this.options; return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0 } getStack() { const { layoutId: o } = this.options; if (o) return this.root.sharedNodes.get(o) } promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) { const f = this.getStack(); f && f.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const o = this.getStack(); return o ? o.relegate(this) : !1 } resetRotation() { const { visualElement: o } = this.options; if (!o) return; let a = !1; const { latestValues: l } = o; if ((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a) return; const f = {}; for (let d = 0; d < GT.length; d++) { const h = "rotate" + GT[d]; l[h] && (f[h] = l[h], o.setStaticValue(h, 0)) } o.render(); for (const d in f) o.setStaticValue(d, f[d]); o.scheduleRender() } getProjectionStyles(o = {}) { var a, l; const f = {}; if (!this.instance || this.isSVG) return f; if (this.isVisible) f.visibility = ""; else return { visibility: "hidden" }; const d = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, f.opacity = "", f.pointerEvents = fm(o.pointerEvents) || "", f.transform = d ? d(this.latestValues, "") : "none", f; const h = this.getLead(); if (!this.projectionDelta || !this.layout || !h.target) { const y = {}; return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = fm(o.pointerEvents) || ""), this.hasProjected && !Ca(this.latestValues) && (y.transform = d ? d({}, "") : "none", this.hasProjected = !1), y } const p = h.animationValues || h.latestValues; this.applyTransformsToTarget(), f.transform = zT(this.projectionDeltaWithTransform, this.treeScale, p), d && (f.transform = d(p, f.transform)); const { x: m, y: v } = this.projectionDelta; f.transformOrigin = `${m.origin * 100}% ${v.origin * 100}% 0`, h.animationValues ? f.opacity = h === this ? (l = (a = p.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : f.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0; for (const y in Wm) { if (p[y] === void 0) continue; const { correct: x, applyTo: A } = Wm[y], _ = f.transform === "none" ? p[y] : x(p[y], h); if (A) { const w = A.length; for (let S = 0; S < w; S++)f[A[S]] = _ } else f[y] = _ } return this.options.layoutId && (f.pointerEvents = h === this ? fm(o.pointerEvents) || "" : "none"), f } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(o => { var a; return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop() }), this.root.nodes.forEach(VT), this.root.sharedNodes.clear() } } } function IW(n) { n.updateLayout() } function FW(n) { var e; const t = ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || n.snapshot; if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: r } = n.layout, { animationType: s } = n.options, o = t.source !== n.layout.source; s === "size" ? Qr(h => { const p = o ? t.measuredBox[h] : t.layoutBox[h], m = Hi(p); p.min = i[h].min, p.max = p.min + m }) : QR(s, t.layoutBox, i) && Qr(h => { const p = o ? t.measuredBox[h] : t.layoutBox[h], m = Hi(i[h]); p.max = p.min + m }); const a = Af(); vf(a, i, t.layoutBox); const l = Af(); o ? vf(l, n.applyTransform(r, !0), t.measuredBox) : vf(l, i, t.layoutBox); const f = !YR(a); let d = !1; if (!n.resumeFrom) { const h = n.getClosestProjectingParent(); if (h && !h.resumeFrom) { const { snapshot: p, layout: m } = h; if (p && m) { const v = An(); xf(v, t.layoutBox, p.layoutBox); const y = An(); xf(y, i, m.layoutBox), L1(v, y) || (d = !0), h.options.layoutRoot && (n.relativeTarget = y, n.relativeTargetOrigin = v, n.relativeParent = h) } } } n.notifyListeners("didUpdate", { layout: i, snapshot: t, delta: l, layoutDelta: a, hasLayoutChanged: f, hasRelativeTargetChanged: d }) } else if (n.isLead()) { const { onExitComplete: i } = n.options; i && i() } n.options.transition = void 0 } function NW(n) { Ea.totalNodes++, n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = Boolean(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty)) } function OW(n) { n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1 } function kW(n) { n.clearSnapshot() } function VT(n) { n.clearMeasurements() } function UW(n) { const { visualElement: e } = n.options; e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), n.resetTransform() } function WT(n) { n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0 } function zW(n) { n.resolveTargetDelta() } function GW(n) { n.calcProjection() } function HW(n) { n.resetRotation() } function VW(n) { n.removeLeadSnapshot() } function jT(n, e, t) { n.translate = nn(e.translate, 0, t), n.scale = nn(e.scale, 1, t), n.origin = e.origin, n.originPoint = e.originPoint } function JT(n, e, t, i) { n.min = nn(e.min, t.min, i), n.max = nn(e.max, t.max, i) } function WW(n, e, t, i) { JT(n.x, e.x, t.x, i), JT(n.y, e.y, t.y, i) } function jW(n) { return n.animationValues && n.animationValues.opacityExit !== void 0 } const JW = { duration: .45, ease: [.4, 0, .1, 1] }; function XW(n, e) { let t = n.root; for (let s = n.path.length - 1; s >= 0; s--)if (Boolean(n.path[s].instance)) { t = n.path[s]; break } const r = (t && t !== n.root ? t.instance : document).querySelector(`[data-projection-id="${e}"]`); r && n.mount(r, !0) } function XT(n) { n.min = Math.round(n.min), n.max = Math.round(n.max) } function YW(n) { XT(n.x), XT(n.y) } function QR(n, e, t) { return n === "position" || n === "preserve-aspect" && !T1(UT(e), UT(t), .2) } const KW = KR({ attachResizeListener: (n, e) => Ds(n, "resize", e), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Sv = { current: void 0 }, ZR = KR({ measureScroll: n => ({ x: n.scrollLeft, y: n.scrollTop }), defaultParent: () => { if (!Sv.current) { const n = new KW(0, {}); n.mount(window), n.setOptions({ layoutScroll: !0 }), Sv.current = n } return Sv.current }, resetTransform: (n, e) => { n.style.transform = e !== void 0 ? e : "none" }, checkIsScrollRoot: n => Boolean(window.getComputedStyle(n).position === "fixed") }), QW = { pan: { Feature: pW }, drag: { Feature: hW, ProjectionNode: ZR, MeasureLayout: jR } }, ZW = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]), qR = n => ZW.has(n), qW = n => Object.keys(n).some(qR), YT = n => n === fl || n === nt, KT = (n, e) => parseFloat(n.split(", ")[e]), QT = (n, e) => (t, { transform: i }) => { if (i === "none" || !i) return 0; const r = i.match(/^matrix3d\((.+)\)$/); if (r) return KT(r[1], e); { const s = i.match(/^matrix\((.+)\)$/); return s ? KT(s[1], n) : 0 } }, $W = new Set(["x", "y", "z"]), e7 = Og.filter(n => !$W.has(n)); function t7(n) { const e = []; return e7.forEach(t => { const i = n.getValue(t); i !== void 0 && (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0)) }), e.length && n.render(), e } const ZT = { width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) => n.max - n.min - parseFloat(e) - parseFloat(t), height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) => n.max - n.min - parseFloat(e) - parseFloat(t), top: (n, { top: e }) => parseFloat(e), left: (n, { left: e }) => parseFloat(e), bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min), right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min), x: QT(4, 13), y: QT(5, 14) }, n7 = (n, e, t) => { const i = e.measureViewportBox(), r = e.current, s = getComputedStyle(r), { display: o } = s, a = {}; o === "none" && e.setStaticValue("display", n.display || "block"), t.forEach(f => { a[f] = ZT[f](i, s) }), e.render(); const l = e.measureViewportBox(); return t.forEach(f => { const d = e.getValue(f); d && d.jump(a[f]), n[f] = ZT[f](l, s) }), n }, i7 = (n, e, t = {}, i = {}) => { e = { ...e }, i = { ...i }; const r = Object.keys(e).filter(qR); let s = [], o = !1; const a = []; if (r.forEach(l => { const f = n.getValue(l); if (!n.hasValue(l)) return; let d = t[l], h = Jc(d); const p = e[l]; let m; if (Jm(p)) { const v = p.length, y = p[0] === null ? 1 : 0; d = p[y], h = Jc(d); for (let x = y; x < v; x++)m ? Km(Jc(p[x]) === m) : m = Jc(p[x]) } else m = Jc(p); if (h !== m) if (YT(h) && YT(m)) { const v = f.get(); typeof v == "string" && f.set(parseFloat(v)), typeof p == "string" ? e[l] = parseFloat(p) : Array.isArray(p) && m === nt && (e[l] = p.map(parseFloat)) } else h != null && h.transform && (m != null && m.transform) && (d === 0 || p === 0) ? d === 0 ? f.set(m.transform(d)) : e[l] = h.transform(p) : (o || (s = t7(n), o = !0), a.push(l), i[l] = i[l] !== void 0 ? i[l] : e[l], f.jump(p)) }), a.length) { const l = a.indexOf("height") >= 0 ? window.pageYOffset : null, f = n7(e, n, a); return s.length && s.forEach(([d, h]) => { n.getValue(d).set(h) }), n.render(), Ig && l !== null && window.scrollTo({ top: l }), { target: f, transitionEnd: i } } else return { target: e, transitionEnd: i } }; function r7(n, e, t, i) { return qW(e) ? i7(n, e, t, i) : { target: e, transitionEnd: i } } const s7 = (n, e, t, i) => { const r = yW(n, e, i); return e = r.target, i = r.transitionEnd, r7(n, e, t, i) }, D1 = { current: null }, $R = { current: !1 }; function o7() { if ($R.current = !0, !!Ig) if (window.matchMedia) { const n = window.matchMedia("(prefers-reduced-motion)"), e = () => D1.current = n.matches; n.addListener(e), e() } else D1.current = !1 } function a7(n, e, t) { const { willChange: i } = e; for (const r in e) { const s = e[r], o = t[r]; if (Ti(s)) n.addValue(r, s), Ym(i) && i.add(r); else if (Ti(o)) n.addValue(r, Uu(s, { owner: n })), Ym(i) && i.remove(r); else if (o !== s) if (n.hasValue(r)) { const a = n.getValue(r); !a.hasAnimated && a.set(s) } else { const a = n.getStaticValue(r); n.addValue(r, Uu(a !== void 0 ? a : s, { owner: n })) } } for (const r in t) e[r] === void 0 && n.removeValue(r); return e } const eL = Object.keys(td), l7 = eL.length, qT = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], u7 = L_.length; class c7 { constructor({ parent: e, props: t, presenceContext: i, reducedMotionConfig: r, visualState: s }, o = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.scheduleRender = () => ci.render(this.render, !1, !0); const { latestValues: a, renderState: l } = s; this.latestValues = a, this.baseTarget = { ...a }, this.initialValues = t.initial ? { ...a } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = r, this.options = o, this.isControllingVariants = Ng(t), this.isVariantNode = W3(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(e && e.current); const { willChange: f, ...d } = this.scrapeMotionValuesFromProps(t, {}); for (const h in d) { const p = d[h]; a[h] !== void 0 && Ti(p) && (p.set(a[h], !1), Ym(f) && f.add(h)) } } scrapeMotionValuesFromProps(e, t) { return {} } mount(e) { this.current = e, this.projection && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, i) => this.bindToMotionValue(i, t)), $R.current || o7(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : D1.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { this.projection && this.projection.unmount(), Ho.update(this.notifyUpdate), Ho.render(this.render), this.valueSubscriptions.forEach(e => e()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) this.features[e].unmount(); this.current = null } bindToMotionValue(e, t) { const i = cl.has(e), r = t.on("change", o => { this.latestValues[e] = o, this.props.onUpdate && ci.update(this.notifyUpdate, !1, !0), i && this.projection && (this.projection.isTransformDirty = !0) }), s = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, () => { r(), s() }) } sortNodePosition(e) { return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current) } loadFeatures({ children: e, ...t }, i, r, s, o) { let a, l; for (let f = 0; f < l7; f++) { const d = eL[f], { isEnabled: h, Feature: p, ProjectionNode: m, MeasureLayout: v } = td[d]; m && (a = m), h(t) && (!this.features[d] && p && (this.features[d] = new p(this)), v && (l = v)) } if (!this.projection && a) { this.projection = new a(s, this.latestValues, this.parent && this.parent.projection); const { layoutId: f, layout: d, drag: h, dragConstraints: p, layoutScroll: m, layoutRoot: v } = t; this.projection.setOptions({ layoutId: f, layout: d, alwaysMeasureLayout: Boolean(h) || p && uu(p), visualElement: this, scheduleRender: () => this.scheduleRender(), animationType: typeof d == "string" ? d : "both", initialPromotionConfig: o, layoutScroll: m, layoutRoot: v }) } return l } updateFeatures() { for (const e in this.features) { const t = this.features[e]; t.isMounted ? t.update(this.props, this.prevProps) : (t.mount(), t.isMounted = !0) } } triggerBuild() { this.build(this.renderState, this.latestValues, this.options, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : An() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } makeTargetAnimatable(e, t = !0) { return this.makeTargetAnimatableFromInstance(e, this.props, t) } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let i = 0; i < qT.length; i++) { const r = qT[i]; this.propEventSubscriptions[r] && (this.propEventSubscriptions[r](), delete this.propEventSubscriptions[r]); const s = e["on" + r]; s && (this.propEventSubscriptions[r] = this.on(r, s)) } this.prevMotionValues = a7(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext(e = !1) { if (e) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const i = this.parent ? this.parent.getVariantContext() || {} : {}; return this.props.initial !== void 0 && (i.initial = this.props.initial), i } const t = {}; for (let i = 0; i < u7; i++) { const r = L_[i], s = this.props[r]; (ed(s) || s === !1) && (t[r] = s) } return t } addVariantChild(e) { const t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { t !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, t)), this.values.set(e, t), this.latestValues[e] = t.get() } removeValue(e) { this.values.delete(e); const t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let i = this.values.get(e); return i === void 0 && t !== void 0 && (i = Uu(t, { owner: this }), this.addValue(e, i)), i } readValue(e) { return this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.readValueFromInstance(this.current, e, this.options) } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; const { initial: i } = this.props, r = typeof i == "string" || typeof i == "object" ? (t = z_(this.props, i)) === null || t === void 0 ? void 0 : t[e] : void 0; if (i && r !== void 0) return r; const s = this.getBaseTargetFromProps(this.props, e); return s !== void 0 && !Ti(s) ? s : this.initialValues[e] !== void 0 && r === void 0 ? void 0 : this.baseTarget[e] } on(e, t) { return this.events[e] || (this.events[e] = new V_), this.events[e].add(t) } notify(e, ...t) { this.events[e] && this.events[e].notify(...t) } } class tL extends c7 { sortInstanceNodePosition(e, t) { return e.compareDocumentPosition(t) & 2 ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, { vars: t, style: i }) { delete t[e], delete i[e] } makeTargetAnimatableFromInstance({ transition: e, transitionEnd: t, ...i }, { transformValues: r }, s) { let o = D9(i, e || {}, this); if (r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s) { R9(this, i, o); const a = s7(this, i, o, t); t = a.transitionEnd, i = a.target } return { transition: e, transitionEnd: t, ...i } } } function f7(n) { return window.getComputedStyle(n) } class d7 extends tL { readValueFromInstance(e, t) { if (cl.has(t)) { const i = J_(t); return i && i.default || 0 } else { const i = f7(e), r = (Q3(t) ? i.getPropertyValue(t) : i[t]) || 0; return typeof r == "string" ? r.trim() : r } } measureInstanceViewportBox(e, { transformPagePoint: t }) { return VR(e, t) } build(e, t, i, r) { I_(e, t, i, r.transformTemplate) } scrapeMotionValuesFromProps(e, t) { return U_(e, t) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; Ti(e) && (this.childSubscription = e.on("change", t => { this.current && (this.current.textContent = `${t}`) })) } renderInstance(e, t, i, r) { tR(e, t, i, r) } } class h7 extends tL { constructor() { super(...arguments), this.isSVGTag = !1 } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (cl.has(t)) { const i = J_(t); return i && i.default || 0 } return t = nR.has(t) ? t : k_(t), e.getAttribute(t) } measureInstanceViewportBox() { return An() } scrapeMotionValuesFromProps(e, t) { return rR(e, t) } build(e, t, i, r) { N_(e, t, i, this.isSVGTag, r.transformTemplate) } renderInstance(e, t, i, r) { iR(e, t, i, r) } mount(e) { this.isSVGTag = O_(e.tagName), super.mount(e) } } const p7 = (n, e) => D_(n) ? new h7(e, { enableHardwareAcceleration: !1 }) : new d7(e, { enableHardwareAcceleration: !0 }), m7 = { layout: { ProjectionNode: ZR, MeasureLayout: jR } }, g7 = { ...X6, ...s9, ...QW, ...m7 }, gr = v8((n, e) => J8(n, e, g7, p7)), Mi = { paddingX: "sm:px-16 px-6", paddingY: "sm:py-16 py-6", padding: "sm:px-16 px-6 sm:py-16 py-10", heroHeadText: "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2", heroSubText: "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]", sectionHeadText: "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]", sectionSubText: "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider" }, y7 = "./assets/logo-533739ed.svg", v7 = "./assets/backend-beab4dd9.png", x7 = "./assets/creator-1e1de083.png", A7 = "./assets/mobile-d7db4dfa.png", _7 = "./assets/web-f6f159db.png", M7 = "./assets/view-6160ee14.png", w7 = "./assets/menu-b5599218.svg", S7 = "./assets/close-54702a70.svg", C7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAAOVBMVEVHcEwAX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX54AX55Ol4BIAAAAEnRSTlMANm2GB7/17PwS3qxXmUcqHM48mWIsAAALtUlEQVR42t2dWWLjIAxA4xWMd9//sOO009YLAkkIbMffM2me4YEQgrxeqZ6yGYe86NtqNkrV66PMXLV9kQ9jU74+6ymbrCvaFbTWy/HRb/C26LKPoW6yvJ/VmfTAreY+z5rn0w5F9Yb18S76/Y9UVQxPZi6zvFJfKPhnZc7KpzZub0isv5277aYH4natWrhPXeUPQy6Htl5CnrrqniTz2Ksl9Knbx7g85WbRS/ijivEZ8lYStF/P/ACVQ+U9jNhVV368vA9SWUreXRsv5q4qS8p7VPmGU1QpK+9pVi4/Xt7DFNVnny7v8bmRyvHkvaXKUeU95Eaqofx4eQ8rx6tVfsub9jHF9Pny7lt5vmrhmE7eU7R5icpJ5T3NyuPny3tQOe3C8RJ5D0/CHNBl8l6k8pXyXqByoLzvnSQzV1XVttX3rlqAG1pHVzlAXl2bqi3yLhun5ueZxqHL+9a/8+TKATV3lLc2bdFBu6LNlOV9xYVW8XJAXHnrue9G35dqsrw1POZI6VymvNr0A9KzclyZ77JwbLqZtTE25yOlw5VZMdc8lcs7yMtZ2ky8VyuqMlNe7uJ1KgzLHSmVmfKGBEK8N6xFVGbOvIF/nOlQeA4opbyHF53zVA7LAUWQt5zGbOi6Ls+7bsiyCS5W4qkc8q6l5S3HYY2o3tVaawCt/1doVV8hmP0LZElVZstrD26noWhN/V3ApPcrgDXILuzBSTlUdaLxUlbeNZ6olCf8tFdopVKZLe9of3kKFTpY+8aYQGVRectsxUW1kgY/gNWv0elcWXlpDWTvIsxvhFNZVl6ygkAOg9fnNCIHNPHk1XZ5OS0D5DDGgvHFEDmgtUlYwJbeU2bchIFdZWbX8+aAWK/SYh9zdL1AZd6oeOg9zPnz58OAkjSuyr6FI3ec/u09zAjJr3LJXDiaSDPx/7RDJpKqt+cwmCpHi7VMMU6F1D6bvStybNGYAIQ5Ks6z2D6bBtKR9FeqY4Zcog+QjqRKo+MG1aLEdW9XmTQsWoGty7M7bBWacJWtwEY0wBFtZbvKhNDGCqzAAGe+XGV7OvJr5RkCDAY4xeUqAzkM7PIEAHasVW6hsj3anIOApdcqSVRWQcBggHNflf2N4QaGqqBuoDJQXeoNkXzAkMrZjVU2QcDCaxXZfj3TF44IYJEAJxayfVztA4EXsbVKjFl5jAEstVaJMXqdx1UJYFjl6vpqy+O4KgMsr7J6X97RF0XRf1/pUUupLAUMqcxMw+o1dvh7mvHrgg+mIfudBTlg6CQcc7/6NJGW05C3rMpDrecsBvDXWqW0rlWk9vWarOB91hAH2KGy2EQ6ce6FiAcskHYA7duExMRW1iHA3r8FVEFlrdy+Hnnwjwq8fnxQ2uEc1TShcZyODOzY9+apbBsKSYN/dGBZle25hgYfx8VvYVcGkbczY3t/eJVTAIdmEFELFGyPSQMclkHEvT9kj0kFrAMyiNioBtVjUgEvjjI0UZVvBAypzC09sQ6F3h6TFPgOKocAM9pFQ/WG3HqJiRpghwD3khWlvHSufSiceh0FmDveSFaR2Qtq8zjA/KIO1mYA4f1FA+ZXSsuqfFw4RgRmhw6ym6yH9xcVWFxlRjpXH95fXGB+qaWsynk6YHbVqmhBaJESmD3eCKqcGJhbaqnFVEYCd2LA3NBBC9VLpAfml1qK1EtcAXypytcAs6umTR+6yXoVMD/ADlT5MmCmyjq09OlCYG7oAKqMyrNfCcxdBWit+Jus1wLzSy3tBcmIPPvVwPzLeJgqXw8coDKnXuIGwPzcHEflWwBLqzyo2wOzSy2tpU/ZE4DZpZaWKkZZ4DYWcMA9AeMzgUMuUGueCcxWeb/fjwTu7gDMV7koH9nCfJWr5qnAzKppOnCx3AWYpTIZ2DXBxgQe7b/QR1aZDNxUVwCvvRe4AYR6AIIMPJn0wP9LiIDLfGgqk4GHOjXw78Fk8DIfispkYMcgvegYwLv0BHShM15lKnDTLkmBp2N/hVTGlrNTgUfjyppJA1uz0sAtsEiVqcCuHi3dwuCtAoDKqBpYIrBrUpJuYbjeQwOnEjGXhhGBB+cHSgJ7spTA7/P5VaYBu8Is0RZGbCkpUGVB4MwtidQ8jFwIsVSmAReeVNkgAoxNQANlLKvKsxDw6BkF1ebsYcUFJq2AgLvZWxng0tPA2vxZ1cw8YHK6yjorCwFnvlc//32YM0CRzWJYin5lgJve96dbXL4IBp5amaM4MsCddyjZpvpqVpfmXuh8UFkEePJuI2+m4Ve+MAct9t3sozBwWXhfvcEdEPdNS8wE7FZlCeDB/y02n+UapL3zcMM86/6nsgDwRKuLcH0WIrTkqax/DhiXAsA94g13uDELtXgYQ1QOB9YG0cfmCacwbrUUcqpOoIUxHaz/mxncAiDXwyX3VF3XhANj/tCAKyZYZ00rnj2hxYlDVDunAN58kmdVVVnLSAUPyGqdAFhvjkU4E0Fr37cBdyrNfYdSwNuVkjNZv381OwtEz7pHB95Mwu4xelGdNaScF+FTdXGBtw3syRMYay7qeyqRPSAbEXjbwO7c9X50ex0GOh396lIh4HnTalPliUDtv3vwK37cW4hlgOvtONTV6Aj0JLErHSmjsgxw26DnJEDhfQAMnKqTuO9QBNhk+AZeKuiXPHbqR1NZAnjXoX0NvBve9kPxvseqPsrVpRLA/bb75Z4mUAO4WGgP8WGUW4gFgKttS4y+cH+ewOXRaTqLcQtxOLDZNpkvV79Li3j6NKxyE3B1aSiw3geKvszX9sqtc5/usTsLASqHAqt82wK+mAMMs1wDvOEexYkBvOf1p3J14czdVfbVLTArc+47DATe8yL2JpT7Jx+hKFxBR3F0WmCz5x39exOt+/fD4HWW2NWlIcBmHxU7S7jccTRmkBe6JC0AuMoOY6xegoYsb+bUWrpDTeeyget+P3aWuf/v2pM73plpk44MzwExgc9vO0f8gocjysJ9CeC32CkLRx7weWrsEP/Z38DefBh4dal0ceke97yO6RCvGNPAiG/B/sUULrAtvMXw7leR7CZeAu87pALbop4yV8R3y5uLt7MyOwdEBLbFtQ2OV3XIPbRcY/TImTcrkYCt94E0PU6eHvvT6f4VSEgOiABs/xMjstLI4H84vcMNJpDK7oUjGhhYsnTIYFbnaF7MuOVUWaK4FMwvYaeytsEDI1YhP53OvjMTXlyqq8DNAEKHJnRqyLNSqNaSnyOucxIvpijMlc51lfKygSmpQ903NODX1C74Tz/pFqGFacnhanpRn4y0sj8MqOLAxJ08MzBOk3a0xepOZWFg6gYPNsQ65rdoqedtUCQLTM3710XJAqYMXIewVxKYvLNDH7D+YlYi8W9sJAfM2IZn8zKIf45vSQEzdmd1O734z0Qm/r5ZSQiYUUoTxstp4+90rgTwe3WtE/PyiFeVw8uHe1Y5XB/KuxJzii1rFdzCnB9E1AHj1TYBIvtbpYL10sd3VEjwvvec5wuA6Y/pypfQM0oW1MYCroaX3NMIdus4wLXAcLXv1mIlxFGAZ7nuLN7IEYCBG2SCTS7ULYGBi0UkJqhMYvASBoaujhHq1wKnAUSBocuB5J7wEmJJ4Ejyyp4GEDyoFU1e0RJisVMtUeUVPA0gAxxfXjGVRYCBW2Ji9mu2ygLAqeSVUTkYGLjp6bYqBwKnljf8NEBgNW1yeQO29MKBgUu8EqtMPA3AB04587oXjnMS4PlKeQNUZgKbq+Vlq8wCVjeQ91hNhFWZAVxfNvN6VNZxgG8k7zEHZCIA30xeeg6IBnw/eU8qa0Hge8pLnJUJwPbi+6epjAa+s7wUlZHAdZ+Vr8c8rnQuCvgJ8mJzQAhg/RB5celcP/Bz5D3uOFpV9gE/S16Eym7g58nrVdkF/Ex5PelcB/Bj5XWmc0Fg9WB5XelcANh+ovGxKm+iTSvwB8gL5oBswJ8hL6DyGdh+wu0DVP7OAR2BP0tei8p74M+T96TyDth+ePGjVO42Jb7ZBTPvP46uvOwZsUbgAAAAAElFTkSuQmCC", E7 = "./assets/docker-6961ba01.png", T7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAAWlBMVEX9/f0BDSEioP/AwMEim/////8ACR7x8fEAESbu7u7p6OgWaaxlcH4IKU7c29sejN739/cTS31WYG/7+/qLkZnPz88IGzUgl/EKFCmrrbEce8V4gIs6Q1IfKj1wpeHDAAAMbUlEQVR42u2diWKqOhCGGZAQdpB9e//XPJOg1rYBEhQkPYztuW3qVT4ny8yfAQz7bobj3swx/m6ba5zAJ/AJfAKfwCfwCfw54C9zHvan2/4TzC9z/4eO7DyN3BP4BD6BT+AT+AQ+EPB/F3j8d6Hle5IH93c2sl3bAbIlO3mYvW2b43wK2HGSLEsc14sKy2rQ8knr+D/cAvYlenCbfomGm2UVkee5ib03sIMftVc0eXft+6EsazRgD/L9Qfj33QDtx6+jEcr+wL9vX08PAEopvjy+Ov6nLIehv3Z5U4wHvguw7SRu0QT9UMPtqCkeFD+wn4Z/4X+nIPyz4H+YeBp/i/EJ/EOrETsvHDyWHYCTIr8OlMgybGL8cxz63HITZ2Ngp7kO6Fl6AENfl9fcG5E3Anabvj4G7Z0Z+jxKNtK07MS6Hgp3RKZ9gx17A00rKY6HOyLXV8tga8dbNS0cvD0cEHecwobcfXe25AU1oYc1oAEfye8Djq5Hde/dyb2VvBG46Ak9uJGhcd4GbB2fF5085M6bgK0BqAYGJffx68BFrwUv79XJG4AjHfrznZjNXK9pWjg/a8OLMUhfvKppuYE+vMzHV/c1TStpaqBaWf5StqTDAvxzcbJeAU6umvmXdWrPWQ9s1doBQ50nq4HdK6HaGekjZy1wo5+DGXGerAR2eg0dzOatyFkH3NRUS6tzZ5WmlVyJnsBsFK/RtIoB9ASG2rJXaFpOrqmDkTjIVmRLXq8tMOk9dWB9ezSbtqwVwA3V1yBf0aWvRF9gck1UgR2vB42B+0gZ2NJ4CPOFSRVYzzj62yBW07RynXkpdJmippV1RGdgJgOoaVrJVWtg6CPFbMnpNQcuFIE9vYHJoAocDVpPWrS0FIGLUu9Zum4cNWCr1NrBVBHYyCxJeQd+2rdyQwKfql8jqh6W1LOgZBYKLMUHs7JmpZS7Y0PuKGlassBp3Lbxs1XMTHxUlwv7McYn+GnICzP3DbUYsIKmJQnsm2iX28Mcf+Hfl/tPvLmKkbrckxnyTE3Tkgula9+8yNgIjcyE7AbMN3ulsyUvp5IevkgbMreIDIcEdjp4OzB3NEPeZZbOEyVgVwoYQA2YMV/acI8pm3SKXXoTD49ejtMdtAUIjgLMkP3t41YSGPZRgBEZu/XmwNmBgHcgRmBDQdPabtJ6EG+cfpIgyVQ0rURS0loLfNl6HJPAcxU0LWkNbz2w6e8ArJAeBhsDY2oRkuMA29sDY9C1ZadW9XCyHtj8aZMxV0r+AnDlp0/m+21cTTCb8YYuVu3Sq4HNOCT3c0VrLvCUYdpOIG/o4j2B4ZfoVaaxKVyM6z8IzN+dhMLZLZ6bqG9iIDzOQlZKsqaBJwKPtwKjm4XaiDnVpxGRDQWcA3AWYIY/hmHJ26WBVeq0XE8KWBBaioHxAETEZis+WGDjPq6qu0rG1bGqihE8rOWYp0PLieThvR7mmx+tKTNPA6Ghz2b2X6/MsePWD19LHnYDJmElEW0x3Mo051SiKgUpYPvDwJQKXPxjEAOZx72FaBKKCQJnnwaGVJAzke9zAq5fi8GqWZXwoS6tMGnxUVyZs8CkTiuZ2PxzwIoern+FH996J8jK+pLAH+/SFNo5YGleWeDPT1qCZz8Bk7S6vBVYSdPapEvDHDCEsflWYEVNa28Pg2DReg3YU6rT2gS4nhnD8h1aGviD2dK9WmBulpZ3sKkLMMaWv9fh+5PDamJbWSAUbQC8yRgmqTkZaRFRLsXSI58niC3mTpcHtCbAUM/E0oLhXfEiiTH1r8swTP32Bv25Lq0UWoqmpXu2RH6vSVVKyWMGp1z6qDFLZnmjHmMYBPnw5Z4Pw68hbPoURDpIiOlFrAMwCCVsH6aG95T6Q6BM0+NrWpSUfjWjacHv+WxSwpUrftpG05IFxrxetMx+PVfg4Za+pNJvo2nJTFqs7jCc0KUfq7DAw1X6UoHTnvnwKCDfL2NZl+mkavPotqIluvJfKXDaLT3ElaYc9xPKshzSdG5v6Wv7EISBVhvS1V7eTQBA4riN25bVnFajsjyZA3ypj+LcEJ28Gnm3Ls0j4Mst+jXnyzy+piXhIv0oViQHB5bNeZ41acEgvsvvcbrGzTt2aVn7XuMRVjOle36ofIHJ/SYt6Sqeb2r6rOAx9my1Cs3dNK2VlWkwr3iYrEIzBPKOwOPNoaU0L5HYXfzZsxW8vJumtZJXmCGK6nAV9of3yYel5mdhDLVMzPbRZIu7dksPZXgxtRdvti3vLEkXW+9Yp7WEO1kRjxNXLLF16Et162MAY/TVTrh3XJskdh9YeTnRo0tLLKfA9sMVl/BjTlr8vKXlGBFILbElbkoUtH3Qw7cz09KwlAkcgJSLyGa8PFfvpmldHufkjVbxs/DCsJSuK2PI7Xyhh0SVh6qm5a4XAG5FpWzL4FZORhXPLmUK9HxtS7XYqfes0/pxw5J1+Tsiz/TsZRfvX+Mxnim9XodjAnQ7iRyHy8AHKHlQNOCDeV1x+SGKWtSJCQ3FyIuniKh2afcQwOzAqTDeNH0N6rTWerkURF+Ls9bhuzTM/UmghiztIG4zaSmWHs7OTzPrl2Ar3ZQAVtG0nJ3HMJS+H5Lp/cLf8c0y8BHqtGaypJirdFPFA4ICr/dqWuvPPVwHzOQdLkxSUWgm6tLLs7SaAGB0u3v4ljBjmkGek0gAkaBpLgceiopHDntOWg8BjzOnY8IxxuKURZiXzYGzHPb38JNW0Pq3M/r8VphDVMux9BYefusYnjxhU7zzSP+Mh5+VhKkNV1MiH9bKw4vqdAl/0MOvCB7qmtaRPSxT0qRcp9Ud18NSb6GsaXWH9bBZpVI7D9k+1+LZ3MNyvPtdmmZrD2PALbl7qCgAdLuGlrIelt8gPnqXpq0ps2lTSV/Q5uDAbNswXjiPluHKX2xtmy59u8zjN1sJTEiZsr0GMTQ/N9wPFa60ttWkFfo/La1Xy5NQ3mpRH1nD41McL4upMg1ucj0t+rht+9dW0ivXImHVxmE4Xt+l5RdBZWWqmCiySx2odRxVTSv71DXx+QdIaV2Xd6OwZktO9XpaxkdvAgB3nRr4Y1VnUdW09L7rAQN2N0kPDwz833n4BP7jwJ0qsN68FBSBs6b+q8ATmpbuwHXnuUp1Wtp7OFfUtLT3sOIVxPUHbhSBrVrzdUkZWPeb01jGfwVMVYHdQu/7LcFQKFbiFXrfUYsOkaKmFel9kzjSTwKL67Q82VK8owJfvUTtvoeO5vc9ZNmhyrmHhuz9hw6cOyid1WIkmt+stfHUTuOxk0jn2/HSwVL0sJ14Wt9wuS+UgbW+PW0dRKrAhtZ3XK6byFUGjvSNtWCwlIHtTHYD8ZBhBxvCSpqWYSRuo23CVOeR5ziO0n0PWYaoa5+GvnAyw1C776HrRlGuabBFOi+xVe8Sz4gtPWMPnLJWAkedli4mQTTOxarAnp4ufjhYGdiNilw/7RIgj24oysDoYv0CatJbUWKvBY6aQTNiKPPoHk0pAyNx0enWo4PCy+w54KnAg5mHxHp1atI3hTsRO85rWqNlUdHoNFPD0ESeN+PCSU3r3obzVq5Pmgg8iPZmBulMtnQb4V5hdbokEVB3BS5JzivADi7GVqDHasx53exVYI8R6+Bjxlu4mf0qMCfujj+OuX/ZivQyMCfOjx6AkCFH3sR+BzAnbnp6YCcD4PqL/jWMtwBzYuzWh3UyKQPkdRPDlvDwbOBxb8OoGrt1f8zZGt2bWxabnxc55jSt722ZG1lWg04+HDKQIWis4inAmnfhbPLw1Jbwbp1fBwA4lHeHa1Ow6UqSw5YFNlzera0m6OujuBmg7pl3MbxK5kfuGuDbiozIeTCMN9r9KCsQOvQdx/USw94E+I7MmPsBHf0B7PE9oR76K9JabPA62WK4sRrYZRnyHbq79v1QljV397ezl7YwDlrXdTn0/TXIc0Y74trLi9ELwOyLjWYObTVNnudd0AVBcN3Y8C26Dt+taTjqiBslhmFvCsyX7ixhno5GT/+0Bj8FdlBfx2WNLazNWtX29Fr4lgX/sHHo4krkSh7zS8B8MxWheSJV8GMY3x9/u3t+PLiHvaktupnHWD1P8ZhlNK2FYCTxuPFjeFj0sC3aXDdxEvys3ZXHvKRpLbbZRoYPI3NuA9xlAV6CbdmtjX++POjL0J7CA/k29lrJ+B7sJVdhSmtaf67NPYFP4BP4BD6BT+AjAb8WeGjY9p9gKmtaf6XNPoFP4BP4BD6BT+AT+HPA/wAkb0zyAuooLgAAAABJRU5ErkJggg==", b7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAAb1BMVEXu7u4AAEWRkf8BAUgAAEr///8AAEP+/v6Li//x8fH9/f309PPo6OeOjv9paZT4+PcJCU1ubtLAwMJLS6EgIGUSElZeXrzc3NtWVoSAgOfPz9CIiPQsLHeJia6xsbc8PI/Hx8l+fqPv7++fn7M/P3UgrunKAAAOvElEQVR42uydC2OqIBTHQwwrJTFfmZZlfv/PeNHa1gTU46Nit7Pdx2xr/eJwOOcPyGL5ZZticbdi83evLRYf4A/wB/gD/AH+AH+AXwe8+bZ1cbf1H75WLIr/AfPh2k9T/2VH/rm2/AB/gD/AH+AP8Af4nYD/u8Tjv0stP9US4Amt7x927bu5y3mvrdfFw+99InCx5i9mw1+AEx/Ou931elTY5cG22+2l+qz/erDbFW5HtV1Pu93ufIidxdpePhu44LDO4Xq87MsyCMOQccMYI8Q/v41U9vAV4h/V47j6H/8L8x+5faL6Sv1Aw/j16gH+XTfjvyso95fr6bDYPA3YcjnsaVsGDNVEGJvVp2nyfx7tTnr7on7M/GX3iw+X8eP7dfth9P3U/Av+j3l7JxnHvsbr5XL9BGD3fCxDRlAT4JnGvYGwsDyeF649M3Cx24fc0czXW9UVwv3VcdczAq+vJXsL2i9owkqOXMyjaXFn3jOCzXcy3socubBn0LRs97AN3wz31p8J2x+syTUt7s0ZRuY7GsYk4I08cbXk8OY139aqRnaLKYEP+3f05sdGLs92MR3woXxr3jpeB6cb8QTA1i57d97KrcPrupgGeBcg8/0NI3a1iwmArYMWvKbJcFh59Whg3n9NTYz3Y3esprV09hr03+/IlR3scZqWvd7qw1sR751xmpZ7DTXirQrs43JMtbQ8ZMTUylBwtkcA21usFy8fnErHHg68Y8jUjZiPxoOBeYQ2tQMmWWwPBb4ybGpIfHEHAq9LZGoIjIN7E4OBd8zU0TA52kM0LcvVsAffhqbSWQ/QtOxziPQEJuFuOUDTsi+mrkYuG3i1VDgl0hUYlQs48PoQaguM2W5AC1+Zti5tossAAUDXGF134v0aClzE+nbhqmaKocDrc4D1BcbhDgysZR7908RHqKa1PmrchauR2LVAmpblXrQG5tklUNNy93q3cBYXsGpprXOQrsM0ENgJdAbGLDwDgeNQ6xbm4xIQ+KA5MDsBgc+hqbWxE0ziseDyDpLbq1r4CAG2rA0YGAdye1HChi8OSNNanoDAKPASwVL+x39NG7MLT4/7a1qLxRHYMChLqWArSo3kNeMbPgI1rQsQmHDgldTyV6RsGB03lgWolhw4sCHnNbxX9OIaeDMnMM4VDbxKX+HTmFxgwGCXRr4K2PBf4dNk684KjJlnrN7Jp8l2s5zTpVGYqFp4lb5iFcHswMouvFpR/y8CR4YS2PBeUIhw4I0F0LQWW9BrJEHS0sKv8GketFyIpuVeYMC5uoGrOP2KFnYAmpZluVtQo7CoDZgmz/dpDgwpD4HAbTH6ReklEHgJAyZ5Oy+N2Lu3sA0Cxg2PTtOX+/SswEKM9poeTp/u07O6NGrE6LRsxjAaoT8E3MyjuQM3+zRNgjFNjBvbUCcHtkDAqFH7Gx4W8pCh6SWutxTfdw/Xu3dHA8sTD0gfJr7RrAeFcZkOKZkQwSzIfT/yaosiPw9Cjj0u8ZCnlk5/YBw2K8OMCJkXTy+BvRgTFOSRl1KD29dfNE2iPEA9Funz1BKkaUGAG/7L+ysWFS6gT2PCsiipKJtDumEkUcZIH2CQptUfWPDoiHuvoAfwkgnDcFOqyGYoTaOsaxczuDzsDcxjNBXbEvvG8JIJkyBKjZbkjRqpH7T7dV0tzQLMvbdBVol2Mp/uHWBZntD2XJW3ste+PZC3sDUTcCMg3yUsUeNKevo0YX7agVv/niRH+AXAKGx4tBHhW3pNh0lbJIxoD97KldqIZ3NpklFpX216evVOkH68Ri/emljt1bMFrWZ0ovdojITRuRquevB6xqqvGYnaaaCaVl9gofQ3vsoEiQjSw6fbpRNRHlTOagA1rd6Kh+C534WgKNzWA3RHkeBTuoIQK58SqGn1Lh6aMfqn1MeC7EO7Zk4xyVMQb8voPlN5KJT+xo+YI3pnlwyAAs9YwUypec8F3PRb44cJCdJth09jLO3AlJcM3Kghj96KN3EeiQczwaN/vFZSFLcPxdI5dZ5SRXkWBLxM9GTppipHnwdY9OiHXy+Wje0+jZspTN26Xh5WNxurhIAw8yQhTfGc87i06NGPRWCzjOqQASSzF5RGwU9ZhEiYJ4ZEAsbPAhY9+leZLyZbtGU1gETM57y/C19eZwvEitg/i6aFRI9+fLclCC2rASRivhjkZAOX3Kdn0bTaPdrESPBptQzAvYX2+GaMJc8p8+k5NC1xmUMjCqOM9k8UxAKaV0N9km15jj6HpoWClLY3iRh3DYUiL/MGeTQSv1Gao8+haQlRWCgASWT0zIwki2IU443wNssDwwzlYadHywKRyqeR6NGqCTjh19IIP0UAEHqd+BKRuBJC4dNEFouq+3gKH0giiLJnSDxY9Gi/+U4jSQEhHTZFCv5sTG5CYHgWsOhaordKsidD1jUli2Jo4ims14qK6V1aCB6yGUJJPWDIVgNI6wZDamI6rQCeOmhJYrQ4jMhWJEpfXk5Xg00FPK2mJYp0q1zW48RRUzbcEH964Ik1LYkT9utx8owxMiYHnljTEnOKamKPNj9kBazY1zGZA3jS8hCF3uCXKMmMmPf2wFk6uNeJMgAeBbyaALhT4pGk8BBtFU0JTOWJx6TAOBzzCgWfHgdsTADc5dJkhEf/zD9NBSwvHqYExqOGkRVtVrDDgavtYIrycEpNq3P1bKdPo+5xmBpdRmuNPvEyEPAQTQvlo3iFgUSid3C/97ssz/MsC4IQz75OC43y6EoqaKSXMk3av5/lgb8+EGoc9XE/LATPvk6rdYdD32nO3y6dGd2j9eOyy9vSS/ykdVrtOxz6+fRvGUBaD49aYz1pecjGerRQMknnlUatsZ5SABB1w0E+jTvGpe4FA+Zz1mmJYtYUPi0J06O2O00JLJkGrYZ/aggjp7pGbC42RcLEW52QoXdwaXGie5VG7QNmJCH+HYRlnbharYjfIGgR2aQIaTVxokx0WFmu1brWrhN4Ik1LMSmC20yWmTV8WjrUceLWldG4bSUecO+hElhS+nduepfMQDRnORXp+a8lAM1nJSxTLu6bbu8hcCGDagZC8GkmFy6NpFrkIZ63Vh0hlnupcoJ9sr2HkhhtdGcIJO8smVT5KqWJn1VbOx6P22NB5nsJHxXmB5ZNXHePl3Kf/lXmYBxR5fp3L/Lz8narm6zM/chL0nrZFp0O+NJ/4rrHDh3cw6dbShJab2i5W/3FfWifrIWXKmACWqjSPpfSnDll7dMPVYPS3rcXAAMr7sUDW4rU6dOo63vgEvdQl1YBR0M8Wq6C0Ua0gy+mnayFLRWwJAPsucGfZN0+XQUIOnsLKxIPBTBgIVK3TwurAXAIrLRbWxiiaSnu4yFxzN47zqTCZHMEB2zx6GxhoKYlBx4Yo+XhrpbQmylU30083S0M1LSkwP2XIfXTsiURHoGI21p4glvTSFJiyG1nJEKJpIUQ81NjkhZ2xwP3XnYlL7P6rWfHSLoQXJ50trXw+DumSdIliO4kUyZl9wbAhOW9kKmRZGhGYMyGx2jFKglFJ8SEl360PV7zh5NIneRN4tJhIsxnQW4rxOO0OCHmKe7hUiGn1JA2dC0ZVnvjW3ZNTxK0mB81zIfc4A/jPBLMN9V6Rn0PgO+ZQkq//pcmHqdtP+oaqGkp7olXneJOHj6ABxLXP/748/Uh8y3fTliYVdWvV98DlVt1rwc/z4JQNYc2WNPaHN/iDIBKyiGYsfBujLH6zh597vIA0rRUufSLqL/v0tL/di3Q8nBz1PmUBzjwW7XwM4D/uxb+AH+A/xawpT8w9B7xG50PEPsCBt0jXnNgjI42TNM66d7CR6CmpTswu7qbzX8EjNkOCLzT+3Aak+2AEo/2wGcg8DnQ/LylA+wUACfW/ggxd/lfAZdKYMU94uOt1qfi4dLhLg3Ze2jrfe4h2cYL0LmHG1vrozwxuTiwNR6WrflhrVcg8NLW/DjeswM7JG7pOlofuFwewMDFRWeX3sZQ4M36pPOh6UcHClx1Ym19mgQ7ZwEEtmxHX58m+1gNrNC0LNc5hVhjjy4K0N5D/oBz0HVgQuWhqE7UBp17WDjO4aip6sHTLHsJPSV+wQumXaZlEyMestwBwNynt1o2cVU4WIOA41OGNW7gAcDno34lE+ZZ1h0FClzwXqxf8kHK872BwcCLRXy46jYWV4XhrQcPAXbieIuxZg791YOXIE3rnpU4znmP9HLo3aGa3pbkjh3rtGqz7Ph80mkwRtkprrNKVRMqNa27WVWk1kfrIeExduyipZO2lIc3YJ59nI+6FMYovJxjezMGmF+LD7sL04IYmdszH4KtkcBOfDhfdBicULjdxc5mObaFq4Rrd/zX3tn2NggCcVziKLE1YAimhliC4Pf/jLvDapssUUfdRhcuTV/8+4L79R48sLHp31oL+YxXpJeBZ+Kkg1ye1G3iPQIYslr6MeUJpCx7j7xndgTwRGx4m+xcfWq7wCvojgivDR53rXLYuextLJOsZFL2g0RetsGxfqb1rLGzcFDIhiuSHDL5UNxI/RiwqvUQrm4enjVsXdJzVSZVy4Qo7hH3spOD7gaGtMYge943p0Q6NiENRtfq2on1yo0CnnoXIA+daso/DjT+eUujusED7rW4bI0bccD3di0hzgMfFUzYhPx+rAEV+kirRqA1xmI2i82LUSxwQL5ix4ZyvnE+9qptmulxO7M9PYHnMO3xYdM2qh87jrDSWAvRFXT7YhQPjMgOAw3Q1nrj/TAMHK37aeN8AE7vDZQVGGSa1nUlGP1hYOfO4hJOfzSktzRhdYP4Es2axeRix2hhjfmlIdPqutjn80vA+FxTyoS4OBxH9BRqqxd7uHqcht9lWOOqEbMOsPXdl+8C7xk8vmqMUXEWoabn9e92XexwrXBFBSbElGnf9XnHmdaqVuHvueZJDNCRHkwsVhez069qsAS8uwcmYyzK580zrR0ao5jii1YtSUbxHuTBWoR/Mbul/6Rl4AycgTNwBk4bOHrweE/NRY6W76tFbB7eWqMZOANn4AycgTNwBv474E+o3Qstll0VDQAAAABJRU5ErkJggg==", P7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAAtFBMVEVHcExDqc+twcuQrLhkudd/xd44kLI2aH83aoE6pczg8fdpjqC64O18nazO6fJNrtE2aH82aH9Neo6iucSr2epyvtqb0uVYs9SMy+HN2t86pcxsutY4jrA2aH9/xd5/xd5/xd59xN52wdxwvtpkpr9TjqY5pcs4occ2aH82aH82d5M4kLE2aH9/xd45pcz///80Z343pMs/b4X3+vv8/f42gJ3u9vno7vC+ztZag5bc5elHcEwU9EErAAAAPHRSTlMA/v39/OL7+f79/v7+/v7+0SP+/v7+/f7+/mUW/IH0onDMMVD+/JnE9lr++////////////////////wD7J7sUAAALUUlEQVR42u2dC3ebOBOGjU2+AsaQtY0hzTZJ03ab3TUGGS04/v8/7OMmCQFyzMUxwppzepr4Vj+8M5rRSKiTybn2+PJd3Q3c1N9//Xic9GOvz3fy0IHj76eq/SC/vnx33cEDJ8wqUP/qTPz44/uTywkwUNXOxLE3uy4nwLHEXYlTb+YHGKQaf+3qzfwAZyL/fu3ozVwBxyq3lPgRezNfwLH9fmzjzc9PLrfAr928mTtg9Uc3b+YNuGkQV7yZP4W/dvPmUStc580jVrjem8erMMObx6ow05vHqfAJbx6lwqe8eYQKn/bm8Sn8gTePT+EP5R2bwnfjAlZvDVgoLBQWCguFhcJCYaGwUPiWFQZlG7PCMZ0qmbZsWennWpZsm5K66xF6SAoDIJmyu9ENLQyDzMJQM/SNK5tSb0oPBTimtd21EQbQq1gQGmvXlvpABqr6+1vJrgEMgOmutcBjW6DprqmCHoj/29L29vnAYGc6RuhB75RBGBqOuQOdL+1/Pg385dOBY3WNwDvHAsM1OxNfHViV9dA710Jd7ubXV1cYSI7mNTHNkQDPCpvr0Gtm4drkGNjWodfUgnWXQL4usG00540H7A7EV41h0EbfVONN+zi+IjAwW/LGceyq/CkMpE3gtTVNBvwpbIWteeOBS+INGJiG18E0C/CmsMN0aBiEWmJhcGqkbjluXQsY2CyBobZ24nm/aduWo2vMYc2w+QJWWQJrGzmd7afNHcli1tmByxUwM4I1tzjRj+fJGxbxRuUKmDFEa1ZpxstOXnq7IL4SsLqBjIICnBvshskRMMOjoV6FAKD+2niazROwXOvRYV1yZbyWM2A3ON9LTa3P6vJKwLUjEVw3GdBDroDXtanVAQ2AuVJYdfUaW9ciAGkECu+kWmO8dgQKJ833c5cJmS5tcwXcPWePF9iuT0u6OVbg+pzttex5DB4YSDqj7AbjBGa1vlrOHYYODHYyIws73K4enmwiqxZjbUI3wTiAqbwsyRttRH3p2hEKmWnalrNm9fA0l+MFcbrzg+pqwzjRpdWc3ViAcXcDntjyobkddgEMFfjURg9LBbvbAdY2NtdbHpoBw3BtddviwRMwDLTOuDwBB4Zjq923H/IEvHbl7hsuuYrhQNMTlW8HOIljY9MNmcM8rDkmuKXCw4NQ71B6cAicbbi8LWAv3IxjPnw2cLJvaQwtHtU1sJ3cxJNoPIquZTzxz8y2ZcvdnNjF44XuGIDp9RfJlDdGzxuXBt7EA6rNamt5sNU+nuH3pZmNy3advOED73aWwdo2rY4TeOfWLz7ANqsPPACzlpda+TQXwIAhcZv9lly4NHNnZosg5gJ4J+msTdMjBVbXsK9FcT6AWZOK0QLvBDBnwKDeGgPrvADbcp2xv73KucLSRqszdt3EGqW5UbhWMOgAdm3pca0wo1Rk3rbB2ozHz6Ala03mAsxampvSkrVflNGXAxIjhGGLvR7XUZhBwLiDElgMjw4sXmZLrA2jtX059m2K/MyHWaMQ1O3yWSzgxI3zOj8dD1ZihQZ172FyJhGzh+cFbbZrDezew+QsFsuU8tpzp5rWWuv3vvhrAbNKiWSnjrF2XEuWLctZGyE8dc80T33pkycAwCCMLYAXOPjgane1sHIrgf5oXbzdDcTXmw/LzQ4dqg5vvN3VojphF+C2xzxc8+CSdfuDS7zQadll4fNommQ5nMMtD60PH+rAe90mXlvi0JF43bbU/MC0ZIrhStxuTGt8JF5cQXc7B/DqfelGhx4m6dcxOd8RD6Rzj7VM9llu7B33u2nV7ODSc87x3MjqKPZLA5BMA4MPxNVdu4/DaYextpQfPqwFENbOneIZoyzt+jhxeTCLael0PzteWgvRAdNhesB0DJv2BPpZeR3S6mG2+y47QNyJzXWzI8RBj2eID265tNGi4hiAd+lhafjn/jcT8LEgLoAFsAAWwAJYAAtgASyABbAAFsACWAALYAEsgAWwABbAAngcwEAoLBQWCguFhcJCYaEw58A//zdE+/fPWvtn2xXY+rVXODK/o8LWz6VS+gi+rCHwz197n2veZsCxN2/5xm0EzL03NwT++WsEuOcDW9wHbyPgcXjz+cDJ2Lzd3gzw3Vi8+Tzgp+ev9+PB/RD46fvL4x/325sBvnt5nUxuB/jp+cfj5IaAY29OH2oD7BM784lznjnj0fbAd8+v+UMtgJU9NoX5DP31t8y3bOue8JX6z2kLnHtzS2B/vpoimxVTuL+f4SdWS59+C37Pak4hk/cscPXjK4vqgx2AkTe3BZ6Rm5Ie3ovAyyO+WSeinlCmhcMADkv6IqFPO+K3+O/og6J5d4WJN/cAHM6LAszJLWk08PKhcOdSRL1ni5+Dq1xNf7/Kb3gKVg2LwCpw0Zt7AIazYgTPIAN4HhVvS5vRH7eISlfCnx/rHKgVMOXNfQAfiAT+/uDVAyuz4p15xfekUTyF+X/5ME2f8NEDXrTompZeXieTXoG9IwlIEnklYHwlYDlY80g4UhJjf8gvQBfgGusIXAhifxEygPMrAY/ZG8MFzUEcICGMLw/jwgwCuBDEygoygBc56CoHn9K5hoxpUXwpcEyHM2U7PGCPBGQxhIvAeNA9zvNXPCxL0uFxK/60JfL/w9IfIjD2OyqEKWAk4GG58mp9mgxT4UKZ5YFxnLeYt34CcIS/fDGEKeB8EIrzbO7bwapUP5FEdJg/ePWvGQowyqo+FcJUDOevDxZ4/C17q4/HrfAhYLj99YGDCBaCOHdcWAHGSSl2fuTcUcVdqVqsVQq+PHB0CApBnKkXREEFGMV2rNl+ityiMgAvIurG+Wm7xuJlgVdRMYjT+MwvAgWMYjuui3E0HCo8+2mRt0UK/gTgRebEs2R0ycV7WIUlYBzbQZJjURBXgci4lQ3W2wECz6ckiPPwnM7KCqO4hUnc4iAOqiGqrAIyuZz7gwRekCDOQ3i2qAAjUZNhFyfcOEbLn1oAbj4t/CTg94iU0+nUEF2DYgwjzbNhCP12rGSdYt3SWuILAy9REKPcc3wvA+OkFMzSnhzqEbCLrQGP0nNlhYbcrLsTz3QrwEi4eDBXFGWLukBxIcVoA6ALMkSF84wTu2f2U6xiBRglpXC6SmyKuOhKCk8ZyKRkeJVWDJzJlwRxOuIkl4AGLhacMLPaKCWl5RHi2sQfHnCmC5yhEF5WgMslY31nCzs+nGLXfngfIHCu32GffeF4pCkDzyPWEVNUNwx3seb4R9gmNV0aGAcxCuFKDM+YB2sVii08YiWD8zzyWDOMAQBnykaLFURXgAKmGplln8aJiTQ5kk8gEh/2/uCAM6Bg+pAPvGVgHJvREVlU7NjRI1aafYnE5Vw9AODcZWGUfsepgoHzpRaSlBbvyFBLA6Jii/SG0q4OWXeAzZsAFwfOKyeIp0OUwiQpJak6N/wYEpAAZsMUmTeFjVPT5YHJ+lmqD60wTkppOCJipDrMiy3swqiVgK9A88705V26UAIntVFJYbyGMKvJuVmxRWosXG2SV3ReTOsfuJB3kjYjrTAejYoZhozcqYvgtmyh4bvHM8WmqenywKUxlVKYoNGuiS5DUmz57w9epZYstLgbpqZPAMa1Y9YHKCpMkhL9tfEycvwwGbGKFwU3A2DDWdNlgOeH1KYp4X6W/XZIww09d5gmAf2e/3JY0EtJU/SWJfn5UNzc4L/jh2eNJL4IMN6Gkn1Dhdp+Qv2m0K8kUUweV/b1r9m329VyGeAttaMo/5v8WniSubsp/zv/U/dPlF56XeDhmgAWwAJYAI8N+PHWgCffbg3477cbAx5VEJ8D/Pjty20Bj0ris4Anf9/fGPCIiM8Ejom/3Bbw5I9v9283BTx5jJHv35QvnNtbjvN/d7To+7npDgYAAAAASUVORK5CYII=", B7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAA5FBMVEVHcEx3ByjpOW6DHTzoWYTmNGmbCjV3CCnpV4LlEFDcwMiua393CCl3CCnAi5uMLEn609/3s8fImqj5xtXSrLf0nbj84+voLmaxMFa4fpDrQnXjEVCiVWzq2N3jzNLyg6SbSmLTOmd3CCnzkK7uXYnoT3zoWYToU4DoWYToWYToWYToWYTAOGHlEFDlEFHXRXF3CCnoWYSvDDzlEFB3CCn////oWYR2BifkDE1/ByvGDkX+/P3gD0779Pf9+vv67vF6DC371+G0dojmF1XnIl3vaJF/FTXw5OeVO1bweJzvcJd7Dy9Up2rxAAAAM3RSTlMA/v7++fv+9P74/v3mO/7+/f7+/v7+/v4I/v5f/v/+/v4agv7+MORMyoxpr/6/mfmvda8Iz4wDAAAK+ElEQVR42u2dbXuiyBKGNWbPGJiVhBijiRozSeZlZ+bM7irBXQ5gNEET////OaDQgFTz1sSmsevaL+PoXNzUU13VVQ1bq6W122+/xhs7KbH9/Hl9WyvEbr98P/5tXH6zmYtA7j58+/z4yAKwo7//EhPf/vX1+PGxyQSwg0xI3LXV/PjIDrCNTEK8VTNjwCfXXTI1MwY8Hv98IFMzc8An17l4kZqZAx7/zBHFt398PX5kFviBSM3sAZ98ybs2swl8kjGId9XMoIevidRcaWBIzVUGBtVcXWCMmisLjFNzRYHxaq4ksK3mGPdWDzhWzRUEjldzBYETcasG/HhowMccmANzYA7MgTkwB+bAHJgDc+CSA08TrCjg7o5RA34+irXLgoD//rRjtIAXd6exdvFciI//95962D5QAp5eniqx1rkqCFidhIwacLMTD2y8jSsFPL4x4oGVi0WVgKfPZwm8ytNlpYCvnpKA9ftplST9oicBa4VouizAiwslEfj8cloZ4OnleSKw0mlWCLhpJgMbNxWS9I2WDKycFVBslQM4RVLaJKarqgCPjzppgPW3qkh6mpyUiiq2ygG8uNBSAZ8eTSsBDCYl04SKrWp4GNwpnZ9Hva7dLaohaWCnpN1A26fzyyoAg0nJvIdqEZO42CoFMLRTOj2CWiDkxVYpJA0lpbPnxdl7FFtlAIZ2SsYdXG4Sd7ZKAAwnpZfp+B5KTK/sSxrcKdll8/QI6mOSdmvLIGkw/zxP4R0FabFFHxjk2rZz7jQoXTHvYWinpL/ZWFMoiBXCYqsEwFBS2izGcCeTsLNFHxjcKW1KSDiIzSbbHobbd9uN7wIKYsJiiz4wtFMyXt2+gAkWW2xLGkpKnaZbZHcKHyPSBsYkW3dheobkTlZsUQcGV+ILT7XQgqadLViWNJSUtJvYiRNRsUUZeArOlFA1BQexs7FgFhhMSr4LwSAm6tbSBm6asbt8eKhIUmzRjmEoKTmbf8/ejILHiHSBMcVjIEbBIFZuFqx6GJwpBWZmmLkxQbFF2cNg2jkPNDXgICYotugCgzul8FmOVyiIjVc2PQwLdrP5j91bkBRbdIGb8OYg8Z4oT0dsSho8fReeH4HteEXPXWzRBIaT0u5xrBu90DNbVIGvTpMXJMz5ntzFFlVJg0lpZ0CIOVbcuWcQeHGnxGz+44M4WH6yApy2ioLPFZ/l1DRNYDA6td2mJNyOz11s0ZQ06LroKOUIPFict9iiB4w5fRc5bYf5npZzNE7Rw7DnIhxTzDnMnMUWRQ/Dp+/O31527O3CgIstxoAxp+8MPWpFHpCnBpzqSHj8OcRLtoCbHULgfKNxepJOfE4p8YD8HUseTnkkPNZybSCoAV+dEgM/NRkCHqc8Eh57QP6VHUlPUzyn9D4PfdACJk5Km8R0xQzw+MosADhPsUULmDgp5R0j0gEuIilB3ZHyevjoqRBg854VDxeQlLYPfTACnPY5peRi65kJ4GKSUr7ROB1geKdkdJ7wBqcx/YYNSYPjE6Xzcol/UQsmCDKPxmkA45KScwoea3CzNvsTtlSA4Z1SbM8GfgBiZ5hcWknDSSn26WBsqZK12KIAjNsphQbh0V/Bca+cZzyHSAMYk5TicyquB5a1s0UDGPNGh/inN7C5O+NDHzRi+DVXYx1XnZ1n6wJQAIYHvlrSOBBTf2vmVdk9jHmjQ2K/BvO7jA997B8Yt1NKikVcYtKyFVv7B8bEYopT35guSbbR+N6Bcattco2IWd21bK8z2T9wM2cIY29VtjHi/iUNCzPNCytwvexMD33sGxi39KR6cONNJy+29g6Mefddmm0e7reZXmeyd0ljklKa3ILdMWUZI+4bGD59l7b9eGcQd7b2DGyvtJphaCEzbEsXhtP7TuTXm3/htbSSnj6/vNn2GjL7g5d01dLm169Ra5Z40RpTtvK8m5YDc2AOzIE5MAfmwByYA3NgDsyBOTAH5sAcmANzYA7MgTkwB+bAHJgDc2AOzIE5MAfmwBx4v8A//mXIyIF/rax/2LHJDm9m4OaPxkRlySZkwD+kdeSfYMsyAdtqnjDOmwH4/pej5snkUICb7Ks5E7CtZrUKvCmB7bW5XgncdMC2mmcVwU0FfPzDmlSGNxH4+Pj79cfq4CYCH3/94/b3j5ODAf767aFWOxzgz9+/dGuHA+yoefMRMbBXw0O1vPc5ptZP2AkUCfzZUXMBwKpat6SROJ/Pxf5Istf76FXP1sh2s/06aLNJAdAYYFfN5MDqTBLbw6VuaJqhL4dtUYqkOKnlmxgqX+urVsh6Yl8iLfhAYKRmYmC1MR+Gnk0zBbERvuJ6L/A41lAKAYvGzqO08C0jBfbVTAqsrtqRh4BNOQSlWu3AXy77ccDblwAIoqUWCXwcUDMhsLoSoP91YzvoY1UaBP+uFSxiIWDnrrQaanHAITWTAatSWwOf8e4FIlUVg5LXhEYysKLL+Yl3gf96qNUKAlbXPcSiDwRhgP40WKn+l+TtTXFvzXKUAljRW7lVvQvcrRUHvPLEagzFVUNaiYIREa4qDd2bsA12fQ7FsDFo2yYsDTjWSYBrhQGrM7T8Cqv6pm5YCd4HSJLqaOmq1L077YDvELDes2xrrFpLj7idV9TvCNwQwu6wiUV3zV56mlYnW9lry767WA8kCHi+rbRmokcckn5JgFfLXW8g/eqeItWGyylIrh50sQ4CuxHfcj/RWrPSAfd1dG0entUSNtYe1d2604tzed3fel+T/SU8AowiIL+m3w84erW2WVtrrFFS8tYqlI8DxRYAjOJkIJUOeA4Ao20TSkoozL2Ky+zHAaO6bLkqHXAPAI6UJgJy66yleTkrBthL24o5YhBYRSFpJyMU837OAoBnCLjPooe97xi9ul+n+BkHAnZ14C/0THk4GLcoQ/nFVuU8jFZmZ8m1c6yyU2zFAjMZw25S0gQHEf0J7S2qBmxfveGXJn4RYopV9XDDqzQ35aRfVHjFVtyixWIMo6Skyz3HWsOdzlblFi3UIDC25vVHPBiw8FCYknSwpY7y0LbhoYU6WyyWllAt3ZC21gjulKLmFlsAsDQEG7ql2h4aLb+B1RpuTBADSQnqS45wwP2lEu2MlAN4sopcm+osy454DTFYaABNunkdbgBY3poV6n2VrcWDCgm0LDsrDtopKeZysHT/00P3KNTiceJ/jVo8g1X5WjxrL2VqcmO7UjXahh+AHr2mt1aejcL3KABse3xm+U08TbZKB2wTDVDjfGSt142VbHqXuw4savZ66xla2bfFlt+mFVp2mm6Dne0SAVtex00xloIsCwMj0Mb0E0xw2DDy1rGNB/1GvGHoRiBvmeKshMCBKFWclxX6OdehQTslTfYvfifr4CYPZs8qbNRSJPBk0h+CWXalBmZKuhioSyw52MvGAA/mVnHDtGKBJyMhcsmGMAoVxeGSCY3WWvYGAgQ226N1gePSYoHViSQvQxNEbSlL9eBOKRTCgXmU83FkIG6YA7nfUIsciBfsYVukI3lo6po3wLfXa9UdpW578sI86C+14bbqhbYdxPW+ELS23OtL64KPPBQN7ORjqd+T2+223JoHrnfdcM0KfXtmeZ+vg1/afnM9Kf5QS/HAmx3SzLKs9Sx0CAdzFil0Rkl9/2NL7wDsY0xKYHsCLo9xYA7MgTlw1YBv/zww4O6n+mEBV0vTaTxcKU2n8XClXJwGuNv99OGwPFy7rQ5xOmCb+ONhAde6v//5sX5QwN1bG/lDdYD/DzXxNrOtRDAhAAAAAElFTkSuQmCC", R7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAArlBMVEVHcEzzayT4mSX83S3zayTzayT4mSX7syf1fyX7rib83S38sSb83S37wSn5rCf8sib83Cz83S35miX4mSXtPSP4mSXsNSP5myXsNSPsNSP83S34mCX5nyX5mSX83S381yz83S3zZST82Cz0bST83S3yZCP8sib8sibyXiP8sSbsNSPuRiP8mS3zayT8sSb4mSX83S3sNSP2hiT80Cr1dyTvTyP7pyb8uCfuRiP8wiib7o8oAAAALHRSTlMAZoH84/zKFB0Jga5mBDDJyp138hXhx0tm/O+aYri3Ut6EQrp0SOiFoZ/p/BUTDekAAAiMSURBVHja7d3ZduI4EAZgBQcsEyS2pt0NZg0k6e7jZRzPMLz/i41NQli8YMmyrZKnLnL/nb9UkreA0P+Vrwy66ZVTy+WGUqwbRCau3lusplpJNQ1rNVgMu70l1Q0ZuGQ50LyySvv643nT6WDR7VG95rCN7dSrsLTpYBiia8y3q3mVgo9ZD7pLXFPQvUrzPau11bAWM1159ZSmedpguKm8t7terTVdbGmlMeOVV3OFrb2pcLNaal7tYm1aIXnrSVHTxbIaMhl6klRFKcsDjsgVjC+ZwJ636uJmgT1vUPZSlg3saUPaLHDY1z2jWeByQ5YRHJ69lqRR4PCSuas3ChySF7RZ4GiDIs0Ce6ut0SywV8pClhkc7k96s8Cet8DNAmue8GEtecKecLH0YG9AGwYWnDEAsFgxBLDQWQ0C7Ancj2GAva7RMLC2Jc0Ce9Nlw8DeatMwsLBR3YUC9oZiBpcETw/zDq6ekJau//lwxcsYziIOl7GQ8weFE7HXFbEbky2YVexNRTQ1MRrX1PoQzqTeinn3sAdmHa/EXBsT2h1MYcQ8FHXdpG963VJqOFwMVtP3d9muIsp7IEsMHVPr9enlcHgX4F7oCECF+6eBzdf+y34fses/YVZU+ua17zhOqC6AHmBA4vDsbkXkEM1vhhTxMWbzyXFOaPUjPpI/U+YkCzp9VEt+fXFOxW4e6PDEiD59iff7d4UH9df0ugzZYSQvIEaMiNl3OMnyH7futjUjeUhAggn+5fCRVxRmxOG0vhLnn9hdpIh4f8g3p0HuTB83H667Om9fTzcIbMa3YidXyF0CVoyfHI6Q4fY0IrQfEx+U3Yo/nm+9OLG2fld2TkcZv8bA99sacE+Hg+spLnbelZ3TYZkvCeI7C3kLGYwSmvqeeGhAXsW4nyTOXMgrDDpiy2EVw17ERO8zi2Ev4pSIs8SgF3FqxBli0DtxWCOHUTylsMH0hVEM+jgdNfUvh1EMfGqhZRo47VJiSGCDcT9dnHx72lC1p1PE0Md02lacKoY+ptPndPLVogb7cBldFvczwAmjWgO+LyGUsYiTmhrkU8Rch600cRc6eJkJji9j8ODMqZWwjKGfPAjOBseaegj85JF11kpsauhHrex9Kd7UGniw8XQHfNPUC1158HVTFz5MR++9mqZljVol1shK/ce0OcB7QWCiU3M0m3cm4/HYLbnGk7mFecFXEfOCdWrNQqpbYXVMwgneFwQTbLY6lVo/Yx4ZfODLucUO1s1ZHdoPMeEDX2xNjGBCW3Vpj2KTD3wRMRPYMGcTt9bqYD7wOWIGsG7Ox27dNeIDnyPODTZk4LruXOcDf0WcF2zOZOCGq5jygb8izgfGrYkrSVmc4D0D2LA6rjQ14gSfjls5wFSSbi4I3ucEE5niLQL+jPgeGEsVbyHwIQ+Yzl1XFfA+B9jsuOqAP3o6C2xYE1cl8OEO2GiNXaXA+2ywMZPRWwR87OlUsD5zXdXAhwywrN5C4H06WFpvIXDU08lgo+UqCT6kgMlo3CywJa+3GNhJBpsTV1XwewKY4I6rLPiQAJZ3QJcEHrkKg/dxsNQLuDDYeb8Fy72AxYNJy1UbfLgBy97QosH63G0W2HJVB++vwNJPrOJg5xIs/8Qq8KglCUwn8ntjj8RZwX0dVsATLC5hCAG7MyIuYRABU1RwSp/BEEa02yJIWMIjAN45RsISBnDIcucUIWEJm2PZueMZRuLAZCY7d24ZSCAYF9uTxuNJp8yat0yd+/XhRDD3nVnf9x+f1w8U62WWUeQF8SQwZ0f7QdB+fsB1fkbACebpaD+w7fbzzkC1fgnECWae0X7EtZ8fav9GhBPcYg83jPdNgv/0wgc22E4dR679uJbhEyA+MNMS/uDa7QcpvuLjAhOGJfzRzXZbEi9nwi3WeO32WpJP2rjAxowt3mg+f0OAwXrOS2H/xLUfdwgyOOfNnbPXXiPQ4Hwz68L7iGGDLZZxdZxYCDZ4xJav/UiBg2ds3vazARucY1e69IZnLAQbfP/+3bW3TaGDOwwDS64ZXRL42ivVEuYC37tWumrosN6Q4uAbr0y7cCng4AZsKw6+bWjlE44FrHjCsYBVB8cDtt8IcHDWPpwQsDx3O8o4WiYEDP+klXFXOilgu70DDs54kpYIlmpqcV0Pt5g6Wq5FLPaOR3LAUvW02Jt4aWCJrpf4btOOmTpaqoi5wGknDz/N25ZnFfM9eZizgWW6rcX3MG3GDJbmTi0feMS2hI9bE4YMThnTWWD77RtgcPLU8rO8dlsOMR+YzNnBYcYYLDh5Ed8D2887sODEo8ddsP24xkDBifcA7oOjV9MwSHDiFy15wOGOvN7VOb0I59u0SRtTkAvcbkdv0+4orqnm/zDVCZzU07kSPrEf66q/2er7qR1bnAmfxHZd9ecvpvoCJ7zJ49sQ6l9OcMJrAGqDEz4CUBwcH1uKgxPe1lIcHP/4UHFw/AoiUBwci1h1MLEgTq0C4NjdS+XBsW8fAsXBseOW8uDbE7WvPPh2awqUB9+8DaA++KapffXBN1dNgfrg60ntqw++OX4E6oMR7UCKWAD4+j/jBQ0AXw0uvwlgdPn/loMmgMnFLwD4TQBf/eaB3wTwlThoAhgZ53XsB00AI3L+5RK/EWBETAhigeDLM5ffCDAheCb94BKaMCL6aCK5WCwYXfzIVNAQ8Pln0/yGgMNpPZdYzAb++T3XK0f4cyXLeAJhTPgt59cL9POHeAPo4B+5XwD7/IFLHzb4d/7XQ4nxmXIAGJxzCZ/Jx1+plWsls4F/ML7YSLAV/e6yTGQW8M839g+uophDszxkFvB3rld/CdLpaD4ZS2L+l2EBc7/qTJCBzdZ8IoM5N/j3utBrziRCU6s1e45eaW3XV39+5qnf39dUzJf8xNAx3e0eaqsfeWpHZfqMv+r6D8nfxytoSS5jAAAAAElFTkSuQmCC", L7 = "./assets/nodejs-721e5f30.png", D7 = "./assets/reactjs-d1bacfff.png", I7 = "./assets/redux-0ff2273d.png", F7 = "./assets/tailwind-eb70aafa.png", N7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAMAAAAJixmgAAAAPFBMVEUoVq8sW7Jbf8Lu8vkdUK3j6fV/ms////8kVK/4+v1sjMmou9+5yOU0YbU/abiVrNjW3/BLc73J1OsQSqqp9ZQlAAANMklEQVR42uydDXPjKAyGAWMsDMbG+f//9SDd7aathfkQifc23pu5mb2rmyeAEK+ExKZ/7GFv4DfwG/gN/AZ+A7+B38Bv4DfwG/gN/AZ+A7+B38Bv4DfwG/gN/C8D62F8fLT+3wLrcdutNeuq1Pz5R62rsXbfN/0/AtYBNYCqWQjv3LIwAGD3P+Hfy+KcE2JWAXx/znizzhN4t+ssHNxuNyklyAD5+ADEv5ThvzInlLHbOOi/FlgPm11VhJWSfeU8eO7oSxhqO45/I3AYW6tmzwMFy34CNDA/K7t1HOcuwGFslee3EtjPJ8x86ZTtNrc7AOttFQurov090jc+h7mt/wpgPRrBAepxP5gZd7PpgUwNPFjXCvsJzcVKv5oZ8WxWnhHxxmFevNqHCwNrO3My3I/HidXqqwJrQzi8v+1XmNiK0vVklMtXADHvHZktYS3r6wEHXk7P+4EcLfbVgAfTifcD2SuipUwGvPeYzw/IXJjtSsDbzDvyRpcT3LzrywAP6yJZ5weYIPC9iIAt+YZ0OK+dah5kGuBhlv1547zmc6vnRQNsnGRPeYD7xg2KBHicGbAnPZKtw8uBjXsOL8RnUeOrgYfeW9KD7uVbT8kUwFtXn+PxrBjPx/r1RmtdevOCZMts9+EijkfvGQ2SO2U3Gp2eAHjruyfF46HZyOQtAmDb06sMVnk2FxMATL8lDDKOLqmq1Q6sVa8lHEZXmOuJeLqfzVrWnVyZbgfu5FcG0zybYZouCCxYD+mOe9UlTn5NYIh+Rp9o2iWBAbzap+mfAQbm1m5R8QsCR+1qmP4dYJDCdkz0uCCw36fpXwKe+2Zt5QJr9HBGCgzQmTcXeDQKMySUwCB976y8PGC9LuARYkLgYJ/3SySmaeOk5GpAFC0q4MBrp+kKwPF8AP2BmTM54ztsu1nDY8w+Dl2Ah6jSQTCfiEhLBCyXc4ldjzF307slPs4LtZYqeznA9i5agdi6CgDA5zN/Uu+riumMUt4leSlvMQOkTAFieRO6P/D5Ag64YuFfo3aBmi9F+RAsw2J9aFadgaU7caBHMy9HGX4gwSk70AH/ju1jwESyNE+HjPSuFibRAJtfc3Vcdr4Fu19vxXxcihGOO3DSbobhTYSgQTq1EQFvgv+ec7ZfpAXcmhghPYRvHU5ekKkInQFr5dgJMIEuDUvqxK83xU+1/uAYbRTAm4cnAMs5NaF3lRV/dlmBY3bmc/A/kwYB3ptDLbCkXKwtmKtMGVs3A4/z50Ygsfdt7cBiS/HmGkW57K3AYQ9+XGfHwGMzsE9oOmO+TQSeManZmZP1AKyOP5ZuBYbE59S58zn39MHSu/2DtQinh2N3Rvs24JRop01RNgUXWxPwqCADeGo7LkEiD0nvoizjzZ3arTSwhy+mpQuwdHviG1/KXsZFC/BgvpBIP3ZwtYDjAzwUe63AzzQiljRZMmsobFOSB77sdHkyBci1AXj/MqNxV6vJ80gM8FaxVuBMRWCpGf11QgXPA1vqssHnQOfgULVU3EmchiVt9DdzOk/UqhZwdOfUVlS98kQYY4lN+NvA9QBmbktYkJq3ns3pBLD5biKl16hMXy3cadyrrVoo4NJ2Ggf+uSfIZUB1+kqfA/eid3GrPXkNdcD7D1MkF2T+WQ+VwJjzFixWbQ62FGMdsP0xT+ViMBmoEtglBrheLdrqgNfbgRCTVK4rlLuNzMf689xsFfA43w7Om5pSmk4IHdbXuzK35MbEcLVSHthU5FV1Vkty7NjQdC1IJmUAlg4ofZcmUKslq0yWzjaYJcDJJBGGq3cH3zF2fBh9xR4C3pI6lRmmMAE8qiM7tFhsCpZf8wgDPKImmrdIKMmdOAFccnZdy60WKgo2eG4Z7jRDj2ayZFAq/EB8Ru+NOQVJq8XQX3pIgFmtvdj1SGiqv8N39XGMrRgYc48XxDMfVOmgSGcwk9V67ytppjHg40UJ0uiS/z/p8m7oKa1V505FbjDg4xHDt05TeH4AhnhtBDcZE6oCCjzMErE0A6o/Ec3o3TcHI29rMfCBJ/3xOeWGevs0hkW3mqy7mR6KgZHjN7qIC+8Q45swRSbjrRwY2ZUYAPYu7CcwNXrHlDSCjBGZ0LVYofcOmJ6ALQLkwTZhkry+1EbMCs97uEZmCk50gMY1R4rb9amNmJX6xugeVxJwkeiMNhSXzWGxdMCoO73N2cCAmtEvAdprAAPmTg/5zlbwDFDxnyRvk3SEUTcm306ja0zbhV0OGLX532NRKbdypPHXngKM6r461/eQWLxBW5rL5sTA0mIZgplzGt0mBwUXHGFc9x2UzPs42As2L68IjPv9NstOg991y88/HRjQkN+YJfTcULdS3dgVgXFVUOck1uIHrgLXhR44pUKi6sxDsnHKRmMmi6wgSAVwMnaCa0YP2casYh9nRE/F4SEd3EGF3wzXMHz7mjbKTHI8TLuJaMZW3EnPPjVq4w2jAy4WAMaTDAs8sHvmbXH0Wu5MVsPoRqdpnc6ZMxUdD+1Z90pgnZ6aEo0LnQwxromRbcLx461UQnxGYCit1yZM1kwGXCPEn7kQgF4kC2empFs5ToRJBIShlpPfj+vKYTtNnLQ4GmAhrMpVE0yb7MlRT+J3BROrGNc8d0FXKqImXHrq16JJasn8B+xafb540C0gfqrXAJo1mIi6eNxkUdYCrUl5ONUgJX5HCFuPCdtOWr64Kqnl9COkiuLa44AYoCFS0kKCdWlL56IrnpQSU2EPU2LQYyWlyapMTJsyFDncRT88+IQZPZVllHSwWUXJpT9MEGqoD9OY8DuktIUTK5NLD9KHf4wYmit5dAMHFytpZ3Rt+nBGydnEXjztP2MIeHI0aSnQ6gTxjFBR4r7u8H0zTjijNBG0nNN/EnjMiAYm7OH308/No188aUHu+kseWZor7m59c6mBr+hXQ1qfuv4aT5YpSezxw2P+ESQOG82Zd99c3tqLWlnhz1SFpMdoPjjURI/E5Zqrr+JlzenUWVv/6UgEeFUR3XKfo2zOnQHnOFuJKMRDD7XUhA57EnvijE7fEM/Q1VIXvMMy9jGXSUr8xp22pF1A2i5Ma5txSEWDn/f1aQQP6zdRxoF6gJuuxMe8x4xfkfTVdyVEooYbVZLDpwrcVPQgXqfJCtUlK0NtqbJPoyJt1BQWWBPwtGctsLm6e1tYwaQmGnxb4ZJ4lSHjt7DqhkCjIl7BamgDzkwU85UFoYlNdNK3zwTOzH0UdSWhx5k9e4DP6mlpkzPn0gXAnjbAuEiYD5x5iUhWTepRkXa1gdTZLRs4LyQAvMJSUztZzK9TO3CmwFbTuo1WyUqf3AqA0+HPx0BE+ZZEXEw/6xOwiWiIS90PbT0tb+YcyyjGm1fkKfzCIuKNuImPzOyWkFFuWecdaCQvWcaDWohNtBqogLHY2ME2mL03DYZ4QifSbMqBdV6ZmFgSO7fMM3W/8YRmVgEc7FZeIjTkdlkpLWaY4VTmGpC8Pg/ZKTbz/oodiRX0s8ltbJH7CcWYtYBJcQsmdHbrEpvpFcHtvNdKrBxF3JKqwAfIbU6T7SbwM+LBkPcbL2nQlAtccNEuXR+WnjepFFcDF8htMrU7jTOtihWfonNLfoOp7K0z9jxDM+Zn8t7MsqyDTz7wYLKrti1IuXZt6dt+nsWD64FLbp3ELqs/Ok0MAZee1xU2jS/pmTbm158BcPPXPrpD7LQi6ce3VHgoahK35XvAANwJtf/aovRulKC3VoG3WFoqAg5rMP9Cc7BO3Asxxyd2SGLQocVpecuxsjaAhSXMQd5+PVJ2aNkLNRGAwr6HNTWuoVcDaukq5PDSRo/1JVTJecGtFWJ4cWdLbTzAJXh9VbijvJVn2I7l64nhtAMXGfC9KOHLidE6uR2A7+EX+CvncyVwIBYcXjqffXVL5rp2vNq+krh6/dYDx3Pe8iri4KY3tHStbbisN/WidRwl2YYWtvUdpnM6t3V4JM9ucUgMPG1GPH2QgXszTtNrgOOJHuSTh3feh+llwHEhuyd6XcF7Vs0dqNu6xOvNeP604WUHutGTge/T+jlul2zbjciAwyDHvqLQfTZzYbZpugBwdDSVY9AZ1ytL0z+eUbxkQHohUyk5zM2NmxEx8DTtq+91ZgS2iHWbpmsBxw7QPex1lD5FQcPs5wFP02iV73CgIFu85MCTHiIynfkKo7v4Zs+qI3BMr94UncQXTHPA1dOFgT+25XnhzcMclm60zJoalx540nq0q4CmSkIguVjtSE/bA/i+mLfYxb4uvALh5+6Rxy64fYA/VrNRwcsugwZ5jznabexE2w/4g9muSnC4SZljksN3s8xqDbRTz4f1fLkext2ss3BwDyDKMILwPdAW/jLGGFkYWRNgBz1Nfy/w50ibVc1CeOeWGCb+fNiyLM4JEQbW2H3U0xMeNj3nCdi7DeCrCs/8+5//2qWDEwBAGABifkQKQsH9h/WpExTB3AaBy8w51+o11lLwmfwuIkZxbXwWMDAwMDAwMDAwMDAwMDAwMDAwMPBbbT5+IHL920PlAAAAAElFTkSuQmCC", O7 = "./assets/threejs-567acc40.svg", k7 = "./assets/meta-e5448f3d.png", U7 = "./assets/shopify-161ee928.png", z7 = "./assets/starbucks-cd829d2c.png", G7 = "./assets/tesla-20a0eda3.png", H7 = "./assets/demon-ec39d647.jpg", V7 = "./assets/boy-0096e822.jpg", W7 = "./assets/mango-c5df493e.jpg", j7 = "./assets/egg-101f8a9b.jpg", J7 = "./assets/potato-c8fa46e8.jpg", X7 = "./assets/dragon-32ef7130.jpg", $T = [{ id: "about", title: "About" }, { id: "work", title: "Work" }, { id: "contact", title: "Contact" }], Y7 = [{ source_to_go_to: "", title: "Architectural Visualization", icon: _7 }, { source_to_go_to: "", title: "Animations and Walkthroughs", icon: A7 }, { source_to_go_to: "", title: "Product Visualization", icon: v7 }, { source_to_go_to: "", title: "Courses", icon: x7 }], K7 = [{ name: "3ds_max", icon: P7 }, { name: "Sketchup", icon: C7 }, { name: "AutoCAD", icon: B7 }, { name: "V-ray", icon: N7 }, { name: "Lumion", icon: D7 }, { name: "D5_render", icon: I7 }, { name: "Unreal_Engine", icon: F7 }, { name: "Marvelous_Designer", icon: L7 }, { name: "anima", icon: R7 }, { name: "Cascadeur", icon: O7 }, { name: "Adobe_After_Effects", icon: b7 }, { name: "Adobe_Photoshop", icon: T7 }, { name: "Topez_Video_AI", icon: E7 }], Q7 = [{ title: "Excellence", company_name: "superiority", icon: z7, iconBg: "#383E56", date: "We ensure meticulous attention to detail and superior quality in every project.", points: ["Uncompromising Quality: We use the latest tools and techniques to produce photorealistic renders and animations that are second to none.", "Continuous Improvement: We constantly seek to improve our skills, stay updated with industry trends, and incorporate new technologies to provide the best possible service.", "Attention to Detail: Every project is approached with a keen eye for detail, ensuring that the final output not only meets but exceeds our clients' expectations.", "Client Satisfaction: Our goal is to deliver results that not only satisfy but also impress our clients, helping them achieve their goals with stunning visualizations."] }, { title: "Innovation", company_name: "originality", icon: G7, iconBg: "#E6DEDD", date: "We use cutting-edge technologies and creative techniques to stand out in 3D visualizations.", points: ["Cutting-Edge Techniques: We continually explore and integrate the latest advancements in 3D modeling, rendering, and animation to stay ahead of the curve.", "Creative Solutions: We approach each project with a fresh perspective, devising unique and effective solutions that bring your vision to life in new and exciting ways.", "Advanced Technology: By leveraging state-of-the-art software and tools like 3ds Max, V-Ray, and After Effects, we ensure that our work is both technically superior and visually stunning.", "Future-Forward Thinking: We stay informed about industry trends and emerging technologies, allowing us to anticipate and meet the evolving needs of our clients."] }, { title: "Customer Focus", company_name: "client-centricity", icon: U7, iconBg: "#383E56", date: "We prioritize your needs and satisfaction, working closely to bring your vision to life, on time and within budget.", points: ["Personalized Service: We tailor our approach to each client, offering customized solutions that align with your specific vision and goals.", "Collaborative Partnership: We work closely with you throughout the project, maintaining open communication and involving you in key decisions to ensure the final result exceeds your expectations.", "Responsive Support: We are always available to answer questions, address concerns, and provide updates, ensuring a smooth and stress-free experience.", "Exceeding Expectations: Our goal is to not only meet but surpass your expectations by delivering exceptional quality and value in every project."] }, { title: "Integrity", company_name: "ethics", icon: k7, iconBg: "#E6DEDD", date: "We operate with honesty, transparency, and professionalism, fostering lasting trust-based relationships.", points: ["Honesty: We provide clear, truthful information and realistic timelines, ensuring that you always know what to expect.", "Transparency: We maintain open communication about our processes, pricing, and progress, fostering trust and confidence.", "Professionalism: We uphold the highest standards of conduct in all our interactions, treating every client with respect and courtesy.", "Accountability: We take responsibility for our work and stand by our commitments, ensuring that we deliver on our promises and address any issues promptly."] }], Z7 = [{ testimonial: "Thank you, Mohsin. Your work is truly excellent, and there’s something unique in your drawings. Keep moving forward—our company, Building Design Center, will always be there to support you.", name: "Engr MA Jaher", designation: "Owner", company: "Building Design Center", image: "https://scontent.fdac22-2.fna.fbcdn.net/v/t39.30808-6/234735651_335276541545005_7681929504864495761_n.jpg?_nc_cat=104&ccb=1-7&_nc_sid=833d8c&_nc_ohc=elKi3Vo82bwQ7kNvgFQyVCw&_nc_zt=23&_nc_ht=scontent.fdac22-2.fna&_nc_gid=AM5174rz6Ga7XtqQXpJKj-2&oh=00_AYDMqe4j3PVrSphANJerYCQXYgfbGSoow2Lffk9Suyh3SQ&oe=671EDB22" }, { testimonial: "Working with Mahmud has elevated my interior designs. His 3D visualizations are innovative and truly bring my concepts to life. I highly value our collaboration!", name: "Engr Monwar Murshed ", designation: "Co-partner", company: "Cad Consultancy", image: "https://scontent.fdac22-2.fna.fbcdn.net/v/t39.30808-6/315649378_862638228430213_7002447124227815218_n.jpg?_nc_cat=101&ccb=1-7&_nc_sid=6ee11a&_nc_ohc=CKMN7WeypTMQ7kNvgHLyZ06&_nc_zt=23&_nc_ht=scontent.fdac22-2.fna&_nc_gid=AbvxMEfX-yUPLO7Op3zR0TU&oh=00_AYBhlOYAAZTBn5vNJVlbwWClpoqxrytz2uEVcHWa6Jw8vQ&oe=671DBB02" }, { testimonial: "Mahmud exceeded my expectations on a complex project. His attention to detail and passion for 3D visualization make him an invaluable asset. I highly recommend his services!", name: "Reajul Islam", designation: "Junior Architect", company: "ArchiBase", image: "https://scontent.fdac22-2.fna.fbcdn.net/v/t39.30808-6/367401280_253116404284165_2697635483810052654_n.jpg?_nc_cat=110&ccb=1-7&_nc_sid=6ee11a&_nc_ohc=90qfIJVdZ9MQ7kNvgHZcQxw&_nc_zt=23&_nc_ht=scontent.fdac22-2.fna&_nc_gid=AKxlILhyuhGspK9eN96e-zr&oh=00_AYAVdTUqNYjxQ3L2MTxq1JmjdX5b3CtOG7xOMPOT-BkcXg&oe=671DBB05" }], q7 = [{ name: "Demon screaming", description: "Experience a haunting 3D animation of a demon screaming over a stormy sea, crafted in 3ds Max and rendered with V-Ray for chilling realism.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: H7, source_code_link: "https://" }, { name: "Boy & Beach", description: "A boy stands on the beach, feeling the wind stir the waves and sky around him, in this evocative scene created in 3ds Max and V-Ray.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: V7, source_code_link: "https://" }, { name: "Egg cracking", description: "An AI attempts to wear an egg as a uniform, resulting in a humorous crack, all brought to life in this imaginative scene created with 3ds Max and V-Ray.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: j7, source_code_link: "https://" }, { name: "Potato Slices", description: "A vibrant potato slice showcases its fresh, crispy texture, beautifully rendered in 3ds Max and V-Ray.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: J7, source_code_link: "https://" }, { name: "Mango juice", description: "Juicy mangoes are being washed, highlighting their vibrant color and freshness, beautifully created in 3ds Max and V-Ray.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: W7, source_code_link: "https://" }, { name: "Dragon Robot", description: "A formidable dragon robot, designed with intricate details and fierce aesthetics, brought to life using 3ds Max and V-Ray.", tags: [{ name: "3ds max", color: "blue-text-gradient" }, { name: "v-ray", color: "green-text-gradient" }, { name: "After Effects", color: "pink-text-gradient" }], image: X7, source_code_link: "https://" }], $7 = () => { const [n, e] = z.useState(""), [t, i] = z.useState(!1), [r, s] = z.useState(!1); return z.useEffect(() => { const o = () => { window.scrollY > 100 ? s(!0) : s(!1) }; return window.addEventListener("scroll", o), () => window.removeEventListener("scroll", o) }, []), ye("nav", { className: `${Mi.paddingX} w-full flex items-center py-5 fixed top-0 z-20 ${r ? "bg-primary" : "bg-transparent"}`, children: st("div", { className: "w-full flex justify-between items-center max-w-7xl mx-auto", children: [st("a", { href: "https://glem.studio", className: "flex items-center gap-2", onClick: () => { e(""), window.scrollTo(0, 0) }, children: [ye("img", { src: y7, alt: "logo", className: "w-9 h-9 object-contain" }), st("p", { className: "text-white text-[18px] font-bold cursor-pointer flex", children: ["Glem  ", ye("span", { className: "sm:block hidden", children: "Studio" })] })] }), ye("ul", { className: "list-none hidden sm:flex flex-row gap-10", children: $T.map(o => ye("li", { className: `${n === o.title ? "text-white" : "text-secondary"} hover:text-white text-[18px] font-medium cursor-pointer`, onClick: () => e(o.title), children: ye("a", { href: `#${o.id}`, children: o.title }) }, o.id)) }), st("div", { className: "sm:hidden flex flex-1 justify-end items-center", children: [ye("img", { src: t ? S7 : w7, alt: "menu", className: "w-[28px] h-[28px] object-contain", onClick: () => i(!t) }), ye("div", { className: `${t ? "flex" : "hidden"} p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`, children: ye("ul", { className: "list-none flex justify-end items-start flex-1 flex-col gap-4", children: $T.map(o => ye("li", { className: `font-poppins font-medium cursor-pointer text-[16px] ${n === o.title ? "text-white" : "text-secondary"}`, onClick: () => { i(!t), e(o.title) }, children: ye("a", { href: `#${o.id}`, children: o.title }) }, o.id)) }) })] })] }) }) }; var nL = {}; Object.defineProperty(nL, "__esModule", { value: !0 }); var Yc = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, ej = function () { function n(e, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (e, t, i) { return t && n(e.prototype, t), i && n(e, i), e } }(), iL = z, tj = ij(iL), nj = hm; function ij(n) { return n && n.__esModule ? n : { default: n } } function rj(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } function sj(n, e) { if (!n) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e && (typeof e == "object" || typeof e == "function") ? e : n } function oj(n, e) { if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e); n.prototype = Object.create(e && e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(n, e) : n.__proto__ = e) } var aj = function (n) { oj(e, n); function e(t) { rj(this, e); var i = sj(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t)); i.state = { style: {} }; var r = { reverse: !1, max: 35, perspective: 1e3, easing: "cubic-bezier(.03,.98,.52,.99)", scale: "1.1", speed: "1000", transition: !0, axis: null, reset: !0 }; return i.width = null, i.height = null, i.left = null, i.top = null, i.transitionTimeout = null, i.updateCall = null, i.element = null, i.settings = Object.assign({}, r, i.props.options), i.reverse = i.settings.reverse ? -1 : 1, i.onMouseEnter = i.onMouseEnter.bind(i, i.props.onMouseEnter), i.onMouseMove = i.onMouseMove.bind(i, i.props.onMouseMove), i.onMouseLeave = i.onMouseLeave.bind(i, i.props.onMouseLeave), i } return ej(e, [{ key: "componentDidMount", value: function () { this.element = (0, nj.findDOMNode)(this) } }, { key: "componentWillUnmount", value: function () { clearTimeout(this.transitionTimeout), cancelAnimationFrame(this.updateCall) } }, { key: "onMouseEnter", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return this.updateElementPosition(), this.setState(Object.assign({}, this.state, { style: Yc({}, this.state.style, { willChange: "transform" }) })), this.setTransition(), i(r) } }, { key: "reset", value: function () { var i = this; window.requestAnimationFrame(function () { i.setState(Object.assign({}, i.state, { style: Yc({}, i.state.style, { transform: "perspective(" + i.settings.perspective + "px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)" }) })) }) } }, { key: "onMouseMove", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return r.persist(), this.updateCall !== null && window.cancelAnimationFrame(this.updateCall), this.event = r, this.updateCall = requestAnimationFrame(this.update.bind(this, r)), i(r) } }, { key: "setTransition", value: function () { var i = this; clearTimeout(this.transitionTimeout), this.setState(Object.assign({}, this.state, { style: Yc({}, this.state.style, { transition: this.settings.speed + "ms " + this.settings.easing }) })), this.transitionTimeout = setTimeout(function () { i.setState(Object.assign({}, i.state, { style: Yc({}, i.state.style, { transition: "" }) })) }, this.settings.speed) } }, { key: "onMouseLeave", value: function () { var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function () { }, r = arguments[1]; return this.setTransition(), this.settings.reset && this.reset(), i(r) } }, { key: "getValues", value: function (i) { var r = (i.nativeEvent.clientX - this.left) / this.width, s = (i.nativeEvent.clientY - this.top) / this.height, o = Math.min(Math.max(r, 0), 1), a = Math.min(Math.max(s, 0), 1), l = (this.reverse * (this.settings.max / 2 - o * this.settings.max)).toFixed(2), f = (this.reverse * (a * this.settings.max - this.settings.max / 2)).toFixed(2), d = o * 100, h = a * 100; return { tiltX: l, tiltY: f, percentageX: d, percentageY: h } } }, { key: "updateElementPosition", value: function () { var i = this.element.getBoundingClientRect(); this.width = this.element.offsetWidth, this.height = this.element.offsetHeight, this.left = i.left, this.top = i.top } }, { key: "update", value: function (i) { var r = this.getValues(i); this.setState(Object.assign({}, this.state, { style: Yc({}, this.state.style, { transform: "perspective(" + this.settings.perspective + "px) rotateX(" + (this.settings.axis === "x" ? 0 : r.tiltY) + "deg) rotateY(" + (this.settings.axis === "y" ? 0 : r.tiltX) + "deg) scale3d(" + this.settings.scale + ", " + this.settings.scale + ", " + this.settings.scale + ")" }) })), this.updateCall = null } }, { key: "render", value: function () { var i = Object.assign({}, this.props.style, this.state.style); return tj.default.createElement("div", { style: i, className: this.props.className, onMouseEnter: this.onMouseEnter, onMouseMove: this.onMouseMove, onMouseLeave: this.onMouseLeave }, this.props.children) } }]), e }(iL.Component), rL = nL.default = aj; const Gg = n => ({ hidden: { y: -50, opacity: 0 }, show: { y: 0, opacity: 1, transition: { type: "spring", duration: 1.25, delay: n } } }), Nd = (n, e, t, i) => ({ hidden: { x: n === "left" ? 100 : n === "right" ? -100 : 0, y: n === "up" ? 100 : n === "down" ? -100 : 0, opacity: 0 }, show: { x: 0, y: 0, opacity: 1, transition: { type: e, delay: t, duration: i, ease: "easeOut" } } }), eb = (n, e, t, i) => ({ hidden: { x: n === "left" ? "-100%" : n === "right" ? "100%" : 0, y: n === "up" || n === "down" ? "100%" : 0 }, show: { x: 0, y: 0, transition: { type: e, delay: t, duration: i, ease: "easeOut" } } }), lj = (n, e) => ({ hidden: {}, show: { transition: { staggerChildren: n, delayChildren: e || 0 } } }), qu = (n, e) => function () { return st(gr.section, { variants: lj(), initial: "hidden", whileInView: "show", viewport: { once: !0, amount: .25 }, className: `${Mi.padding} max-w-7xl mx-auto relative z-0`, children: [ye("span", { className: "hash-span", id: e, children: " " }), ye(n, {})] }) }, uj = ({ index: n, source_to_go_to: e, title: t, icon: i }) => ye(rL, { className: "xs:w-[250px] w-full", children: ye(gr.div, { variants: Nd("right", "spring", n * .5, .75), className: "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card", children: st("div", { onClick: () => window.open(e, "_blank"), options: { max: 45, scale: 1, speed: 450 }, className: "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col", children: [ye("img", { src: i, alt: "Architectural-visualization", className: "w-16 h-16 object-contain" }), ye("h3", { className: "text-white text-[20px] font-bold text-center", children: t })] }) }) }), cj = () => st(G1, { children: [st(gr.div, { variants: Gg(), children: [ye("p", { className: Mi.sectionSubText, children: "Introduction" }), ye("h2", { className: Mi.sectionHeadText, children: "Welcome to Glem Studio" })] }), ye(gr.p, { variants: Nd("", "", .1, 1), className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]", children: "At Glem Studio, We specialize in creating stunning 3D visualizations for architects, designers, and developers. With over 3 years of experience, we deliver high-quality, photorealistic renders and animations that bring your projects to life. Our expertise in 3ds Max, V-Ray, and After Effects ensures every detail is meticulously crafted to meet your vision. Explore our Portfolio and Contact Us today to see how we can transform your ideas into captivating visuals." }), ye("div", { className: "mt-20 flex flex-wrap gap-10", children: Y7.map((n, e) => ye(uj, { index: e, ...n }, n.title)) }), ye("div", { className: "mt-20 flex flex-wrap gap-10", children: ye("div", { class: "youtube-container", children: ye("iframe", { src: "https://www.youtube.com/embed/56IdMVQUm5A?autoplay=0&mute=0&loop=0&color=white&controls=0&modestbranding=1&playsinline=1&rel=0&enablejsapi=1&playlist=56IdMVQUm5A", title: "YouTube video player", frameborder: "0", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowfullscreen: !0 }) }) })] }), fj = qu(cj, "about"), dj = () => ye("div", { className: "flex flex-row flex-wrap justify-center gap-10", children: K7.map(n => ye("div", { className: "w-28 h-28", children: ye(r8, { icon: n.icon }) }, n.name)) }), hj = qu(dj, ""); var Hg = {}, qm = {}, pj = { get exports() { return qm }, set exports(n) { qm = n } };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (n) { (function () { var e = {}.hasOwnProperty; function t() { for (var i = [], r = 0; r < arguments.length; r++) { var s = arguments[r]; if (s) { var o = typeof s; if (o === "string" || o === "number") i.push(s); else if (Array.isArray(s)) { if (s.length) { var a = t.apply(null, s); a && i.push(a) } } else if (o === "object") { if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) { i.push(s.toString()); continue } for (var l in s) e.call(s, l) && s[l] && i.push(l) } } } return i.join(" ") } n.exports ? (t.default = t, n.exports = t) : window.classNames = t })() })(pj); Hg.__esModule = !0; Hg.default = void 0; var mj = tM(z), co = tM(Vm), gj = tM(qm); function tM(n) { return n && n.__esModule ? n : { default: n } } const sL = ({ animate: n = !0, className: e = "", layout: t = "2-columns", lineColor: i = "#FFF", children: r }) => (typeof window == "object" && document.documentElement.style.setProperty("--line-color", i), mj.default.createElement("div", { className: (0, gj.default)(e, "vertical-timeline", { "vertical-timeline--animate": n, "vertical-timeline--two-columns": t === "2-columns", "vertical-timeline--one-column-left": t === "1-column" || t === "1-column-left", "vertical-timeline--one-column-right": t === "1-column-right" }) }, r)); sL.propTypes = { children: co.default.oneOfType([co.default.arrayOf(co.default.node), co.default.node]).isRequired, className: co.default.string, animate: co.default.bool, layout: co.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]), lineColor: co.default.string }; var yj = sL; Hg.default = yj; var Vg = {}; function I1() { return I1 = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n }, I1.apply(this, arguments) } function vj(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, F1(n, e) } function F1(n, e) { return F1 = Object.setPrototypeOf || function (i, r) { return i.__proto__ = r, i }, F1(n, e) } function xj(n, e) { if (n == null) return {}; var t = {}, i = Object.keys(n), r, s; for (s = 0; s < i.length; s++)r = i[s], !(e.indexOf(r) >= 0) && (t[r] = n[r]); return t } var N1 = new Map, Hp = new WeakMap, tb = 0, oL = void 0; function Aj(n) { oL = n } function _j(n) { return n ? (Hp.has(n) || (tb += 1, Hp.set(n, tb.toString())), Hp.get(n)) : "0" } function Mj(n) { return Object.keys(n).sort().filter(function (e) { return n[e] !== void 0 }).map(function (e) { return e + "_" + (e === "root" ? _j(n.root) : n[e]) }).toString() } function wj(n) { var e = Mj(n), t = N1.get(e); if (!t) { var i = new Map, r, s = new IntersectionObserver(function (o) { o.forEach(function (a) { var l, f = a.isIntersecting && r.some(function (d) { return a.intersectionRatio >= d }); n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = f), (l = i.get(a.target)) == null || l.forEach(function (d) { d(f, a) }) }) }, n); r = s.thresholds || (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0]), t = { id: e, observer: s, elements: i }, N1.set(e, t) } return t } function nM(n, e, t, i) { if (t === void 0 && (t = {}), i === void 0 && (i = oL), typeof window.IntersectionObserver > "u" && i !== void 0) { var r = n.getBoundingClientRect(); return e(i, { isIntersecting: i, target: n, intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0, time: 0, boundingClientRect: r, intersectionRect: r, rootBounds: r }), function () { } } var s = wj(t), o = s.id, a = s.observer, l = s.elements, f = l.get(n) || []; return l.has(n) || l.set(n, f), f.push(e), a.observe(n), function () { f.splice(f.indexOf(e), 1), f.length === 0 && (l.delete(n), a.unobserve(n)), l.size === 0 && (a.disconnect(), N1.delete(o)) } } var Sj = ["children", "as", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"]; function nb(n) { return typeof n.children != "function" } var $m = function (n) { vj(e, n); function e(i) { var r; return r = n.call(this, i) || this, r.node = null, r._unobserveCb = null, r.handleNode = function (s) { r.node && (r.unobserve(), !s && !r.props.triggerOnce && !r.props.skip && r.setState({ inView: !!r.props.initialInView, entry: void 0 })), r.node = s || null, r.observeNode() }, r.handleChange = function (s, o) { s && r.props.triggerOnce && r.unobserve(), nb(r.props) || r.setState({ inView: s, entry: o }), r.props.onChange && r.props.onChange(s, o) }, r.state = { inView: !!i.initialInView, entry: void 0 }, r } var t = e.prototype; return t.componentDidUpdate = function (r) { (r.rootMargin !== this.props.rootMargin || r.root !== this.props.root || r.threshold !== this.props.threshold || r.skip !== this.props.skip || r.trackVisibility !== this.props.trackVisibility || r.delay !== this.props.delay) && (this.unobserve(), this.observeNode()) }, t.componentWillUnmount = function () { this.unobserve(), this.node = null }, t.observeNode = function () { if (!(!this.node || this.props.skip)) { var r = this.props, s = r.threshold, o = r.root, a = r.rootMargin, l = r.trackVisibility, f = r.delay, d = r.fallbackInView; this._unobserveCb = nM(this.node, this.handleChange, { threshold: s, root: o, rootMargin: a, trackVisibility: l, delay: f }, d) } }, t.unobserve = function () { this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null) }, t.render = function () { if (!nb(this.props)) { var r = this.state, s = r.inView, o = r.entry; return this.props.children({ inView: s, entry: o, ref: this.handleNode }) } var a = this.props, l = a.children, f = a.as, d = xj(a, Sj); return z.createElement(f || "div", I1({ ref: this.handleNode }, d), l) }, e }(z.Component); $m.displayName = "InView"; $m.defaultProps = { threshold: 0, triggerOnce: !1, initialInView: !1 }; function Cj(n) { var e = n === void 0 ? {} : n, t = e.threshold, i = e.delay, r = e.trackVisibility, s = e.rootMargin, o = e.root, a = e.triggerOnce, l = e.skip, f = e.initialInView, d = e.fallbackInView, h = z.useRef(), p = z.useState({ inView: !!f }), m = p[0], v = p[1], y = z.useCallback(function (A) { h.current !== void 0 && (h.current(), h.current = void 0), !l && A && (h.current = nM(A, function (_, w) { v({ inView: _, entry: w }), w.isIntersecting && a && h.current && (h.current(), h.current = void 0) }, { root: o, rootMargin: s, threshold: t, trackVisibility: r, delay: i }, d)) }, [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, d, i]); z.useEffect(function () { !h.current && m.entry && !a && !l && v({ inView: !!f }) }); var x = [y, m.inView, m.entry]; return x.ref = x[0], x.inView = x[1], x.entry = x[2], x } const Ej = Object.freeze(Object.defineProperty({ __proto__: null, InView: $m, default: $m, defaultFallbackInView: Aj, observe: nM, useInView: Cj }, Symbol.toStringTag, { value: "Module" })), Tj = iD(Ej); Vg.__esModule = !0; Vg.default = void 0; var fo = iM(z), Yt = iM(Vm), Vp = iM(qm), bj = Tj; function iM(n) { return n && n.__esModule ? n : { default: n } } const aL = ({ children: n = "", className: e = "", contentArrowStyle: t = null, contentStyle: i = null, date: r = "", dateClassName: s = "", icon: o = null, iconClassName: a = "", iconOnClick: l = null, onTimelineElementClick: f = null, iconStyle: d = null, id: h = "", position: p = "", style: m = null, textClassName: v = "", intersectionObserverProps: y = { rootMargin: "0px 0px -40px 0px", triggerOnce: !0 }, visible: x = !1 }) => fo.default.createElement(bj.InView, y, ({ inView: A, ref: _ }) => fo.default.createElement("div", { ref: _, id: h, className: (0, Vp.default)(e, "vertical-timeline-element", { "vertical-timeline-element--left": p === "left", "vertical-timeline-element--right": p === "right", "vertical-timeline-element--no-children": n === "" }), style: m }, fo.default.createElement(fo.default.Fragment, null, fo.default.createElement("span", { style: d, onClick: l, className: (0, Vp.default)(a, "vertical-timeline-element-icon", { "bounce-in": A || x, "is-hidden": !(A || x) }) }, o), fo.default.createElement("div", { style: i, onClick: f, className: (0, Vp.default)(v, "vertical-timeline-element-content", { "bounce-in": A || x, "is-hidden": !(A || x) }) }, fo.default.createElement("div", { style: t, className: "vertical-timeline-element-content-arrow" }), n, fo.default.createElement("span", { className: (0, Vp.default)(s, "vertical-timeline-element-date") }, r))))); aL.propTypes = { children: Yt.default.oneOfType([Yt.default.arrayOf(Yt.default.node), Yt.default.node]), className: Yt.default.string, contentArrowStyle: Yt.default.shape({}), contentStyle: Yt.default.shape({}), date: Yt.default.node, dateClassName: Yt.default.string, icon: Yt.default.element, iconClassName: Yt.default.string, iconStyle: Yt.default.shape({}), iconOnClick: Yt.default.func, onTimelineElementClick: Yt.default.func, id: Yt.default.string, position: Yt.default.string, style: Yt.default.shape({}), textClassName: Yt.default.string, visible: Yt.default.bool, intersectionObserverProps: Yt.default.shape({ root: Yt.default.object, rootMargin: Yt.default.string, threshold: Yt.default.number, triggerOnce: Yt.default.bool }) }; var Pj = aL; Vg.default = Pj; var lL = { VerticalTimeline: Hg.default, VerticalTimelineElement: Vg.default }; const Bj = ({ experience: n }) => st(lL.VerticalTimelineElement, { contentStyle: { background: "#1d1836", color: "#fff" }, contentArrowStyle: { borderRight: "7px solid  #232631" }, date: n.date, iconStyle: { background: n.iconBg }, icon: ye("div", { className: "flex justify-center items-center w-full h-full", children: ye("img", { src: n.icon, alt: n.company_name, className: "w-[60%] h-[60%] object-contain" }) }), children: [st("div", { children: [ye("h3", { className: "text-white text-[24px] font-bold", children: n.title }), ye("p", { className: "text-secondary text-[16px] font-semibold", style: { margin: 0 }, children: n.company_name })] }), ye("ul", { className: "mt-5 list-disc ml-5 space-y-2", children: n.points.map((e, t) => ye("li", { className: "text-white-100 text-[14px] pl-1 tracking-wider", children: e }, `experience-point-${t}`)) })] }), Rj = () => st(G1, { children: [st(gr.div, { variants: Gg(), children: [ye("p", { className: `${Mi.sectionSubText} text-center`, children: "Our Values" }), ye("h2", { className: `${Mi.sectionHeadText} text-center`, children: "We give you much more…" })] }), ye("div", { className: "mt-20 flex flex-col", children: ye(lL.VerticalTimeline, { children: Q7.map((n, e) => ye(Bj, { experience: n }, `experience-${e}`)) }) })] }), Lj = qu(Rj, "work"), Dj = ({ index: n, name: e, description: t, tags: i, image: r, source_code_link: s }) => ye(gr.div, { variants: Nd("up", "spring", n * .5, .75), children: st(rL, { options: { max: 45, scale: 1, speed: 450 }, className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full", children: [st("div", { className: "relative w-full h-[230px]", children: [ye("img", { src: r, alt: "project_image", className: "w-full h-full object-cover rounded-2xl" }), ye("div", { className: "absolute inset-0 flex justify-end m-3 card-img_hover", children: ye("div", { onClick: () => window.location.href = s, className: "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer", children: ye("img", { src: M7, alt: "source code", className: "w-1/2 h-1/2 object-contain" }) }) })] }), st("div", { className: "mt-5", children: [ye("h3", { className: "text-white font-bold text-[24px]", children: e }), ye("p", { className: "mt-2 text-secondary text-[14px]", children: t })] }), ye("div", { className: "mt-4 flex flex-wrap gap-2", children: i.map(o => st("p", { className: `text-[14px] ${o.color}`, children: ["#", o.name] }, `${e}-${o.name}`)) })] }) }), Ij = () => st(G1, { children: [st(gr.div, { variants: Gg(), children: [ye("p", { className: `${Mi.sectionSubText} `, children: "My work" }), ye("h2", { className: `${Mi.sectionHeadText}`, children: "Projects." })] }), ye("div", { className: "w-full flex", children: ye(gr.p, { variants: Nd("", "", .1, 1), className: "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]", children: "The following projects showcase my skills and experience in architecture, interior design, 3D visualization, and 3D product animation. Each project is briefly described, highlighting the design concepts, technical solutions, and creative processes involved. These examples reflect my ability to bring complex designs to life, work with various tools and technologies, and manage projects from concept to completion." }) }), ye("div", { className: "mt-20 flex flex-wrap gap-7", children: q7.map((n, e) => ye(Dj, { index: e, ...n }, `project-${e}`)) })] }), Fj = qu(Ij, ""), Nj = ({ index: n, testimonial: e, name: t, designation: i, company: r, image: s }) => st(gr.div, { variants: Nd("", "spring", n * .5, .75), className: "bg-black-200 p-10 rounded-3xl xs:w-[320px] w-full", children: [ye("p", { className: "text-white font-black text-[48px]", children: '"' }), st("div", { className: "mt-1", children: [ye("p", { className: "text-white tracking-wider text-[18px]", children: e }), st("div", { className: "mt-7 flex justify-between items-center gap-1", children: [st("div", { className: "flex-1 flex flex-col", children: [st("p", { className: "text-white font-medium text-[16px]", children: [ye("span", { className: "blue-text-gradient", children: "@" }), " ", t] }), st("p", { className: "mt-1 text-secondary text-[12px]", children: [i, " of ", r] })] }), ye("img", { src: s, alt: `feedback_by-${t}`, className: "w-10 h-10 rounded-full object-cover" })] })] })] }), Oj = () => st("div", { className: "mt-12 bg-black-100 rounded-[20px]", children: [ye("div", { className: `bg-tertiary rounded-2xl ${Mi.padding} min-h-[300px]`, children: st(gr.div, { variants: Gg(), children: [ye("p", { className: Mi.sectionSubText, children: "What others say" }), ye("h2", { className: Mi.sectionHeadText, children: "Testimonials." })] }) }), ye("div", { className: `-mt-20 pb-14 ${Mi.paddingX} flex flex-wrap gap-7`, children: Z7.map((n, e) => ye(Nj, { index: e, ...n }, n.name)) })] }), kj = qu(Oj, ""), sd = { _origin: "https://api.emailjs.com" }, Uj = (n, e = "https://api.emailjs.com") => { sd._userID = n, sd._origin = e }, uL = (n, e, t) => { if (!n) throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!t) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class ib { constructor(e) { this.status = e ? e.status : 0, this.text = e ? e.responseText : "Network Error" } } const cL = (n, e, t = {}) => new Promise((i, r) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: o }) => { const a = new ib(o); a.status === 200 || a.text === "OK" ? i(a) : r(a) }), s.addEventListener("error", ({ target: o }) => { r(new ib(o)) }), s.open("POST", sd._origin + n, !0), Object.keys(t).forEach(o => { s.setRequestHeader(o, t[o]) }), s.send(e) }), zj = (n, e, t, i) => { const r = i || sd._userID; return uL(r, n, e), cL("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.10.0", user_id: r, service_id: n, template_id: e, template_params: t }), { "Content-type": "application/json" }) }, Gj = n => { let e; if (typeof n == "string" ? e = document.querySelector(n) : e = n, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, Hj = (n, e, t, i) => { const r = i || sd._userID, s = Gj(t); uL(r, n, e); const o = new FormData(s); return o.append("lib_version", "3.10.0"), o.append("service_id", n), o.append("template_id", e), o.append("user_id", r), cL("/api/v1.0/email/send-form", o) }, Vj = { init: Uj, send: zj, sendForm: Hj }, Wj = () => { const n = z.useRef(), [e, t] = z.useState({ name: "", email: "", message: "" }), [i, r] = z.useState(!1), s = a => { const { target: l } = a, { name: f, value: d } = l; t({ ...e, [f]: d }) }, o = a => { a.preventDefault(), r(!0), Vj.send("service_a0ns2tg", "template_uuk2lx6", { from_name: e.name, to_name: "Mahmud Mohsin", from_email: e.email, to_email: "mahmudmohsinmoon@gmail.com", message: e.message }, "WeEUIfl9pFiNJlOYa").then(() => { r(!1), alert("Thank you. I will get back to you as soon as possible."), t({ name: "", email: "", message: "" }) }, l => { r(!1), console.error(l), alert("Ahh, something went wrong. Please try again.") }) }; return st("div", { className: "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden", children: [st(gr.div, { variants: eb("left", "tween", .2, 1), className: "flex-[0.75] bg-black-100 p-8 rounded-2xl", children: [ye("p", { className: Mi.sectionSubText, children: "Get in touch" }), ye("h3", { className: Mi.sectionHeadText, children: "Contact." }), st("form", { ref: n, onSubmit: o, className: "mt-12 flex flex-col gap-8", children: [st("label", { className: "flex flex-col", children: [ye("span", { className: "text-white font-medium mb-4", children: "Your Name" }), ye("input", { type: "text", name: "name", value: e.name, onChange: s, placeholder: "What's your good name?", className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium" })] }), st("label", { className: "flex flex-col", children: [ye("span", { className: "text-white font-medium mb-4", children: "Your email" }), ye("input", { type: "email", name: "email", value: e.email, onChange: s, placeholder: "What's your web address?", className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium" })] }), st("label", { className: "flex flex-col", children: [ye("span", { className: "text-white font-medium mb-4", children: "Your Message" }), ye("textarea", { rows: 7, name: "message", value: e.message, onChange: s, placeholder: "What you want to say?", className: "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium" })] }), ye("button", { type: "submit", className: "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary", children: i ? "Sending..." : "Send" })] }), ye("br", {}), st("div", { style: { textAlign: "center" }, children: [ye("a", { href: "https://wa.me/+8801980872856", target: "_blank", rel: "noopener noreferrer", children: "On WhatsApp" }), " ", ye("br", {}), ye("br", {}), ye("a", { href: "https://t.me/+8801980872856", target: "_blank", rel: "noopener noreferrer", children: "On Telegram" })] })] }), ye(gr.div, { variants: eb("right", "tween", .2, 1), className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]", children: ye(n8, {}) })] }) }, jj = qu(Wj, "contact"), Jj = () => ye(QF, { children: st("div", { className: "relative z-0 bg-primary", children: [st("div", { className: "bg-hero-pattern bg-cover bg-no-repeat bg-center", children: [ye($7, {}), ye("iframe", { className: "model-iframe", src: "https://mohsin2moon.github.io/gt/" })] }), ye(fj, {}), ye(Lj, {}), ye(hj, {}), ye(Fj, {}), ye(kj, {}), st("div", { className: "relative z-0", children: [ye(jj, {}), ye(o8, {})] })] }) }); Ev.createRoot(document.getElementById("root")).render(ye(tg.StrictMode, { children: ye(Jj, {}) }));
